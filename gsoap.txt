gsoap不需要重写现有的C/C++应用。但是，不能用unions，指针和空指针来作为远程方法调用参数的数据结构中元素。


gSOAP运行环境实例是一个struct soap类型的变量。当客户端程序访问远程方法前或当服务端程序能够接收一个请求前，必须先将这个运行环境变量初始化。在2.x版中新增了3个函数来负责这些事情：

函数                                       解释

soap_init(struct soap *soap)               初始化环境变量（只需执行一次）
struct soap *soap_new()                     定义并初始化环境变量并返回一个该变量的指针
struct soap *soap_copy(struct soap *soap)   定义一个环境变量并从已有的环境变量中拷贝环境信息

int main()

{

   struct soap *soap;
   soap = soap_new(); // 定义并初始化环境变量
   if (!soap) // 如果不能定义，退出
   soap_call_ns__method1(soap, ...); // 调用远程函数
   soap_call_ns__method2(soap, ...); // 调用另一个远程函数
   soap_end(soap); // 清除环境变量
   free(soap); // 释放环境变量空间
}

服务端代码在调用soap_serve函数前，需要定义相关环境变量:

int main()
{
   struct soap soap;
   soap_init(&soap);
   soap_serve(&soap);

}

或者像下面这样:
   soap_serve(soap_new());

soap_serve函数用来处理一个或多个（当允许HTTP keep-alive时，参见18.11节中的SOAP_IO_KEEPALIVE标志）请求。

一个web服务可以用多线程技术来处理请求：

int main()

{
   struct soap soap1, soap2;

   pthread_t tid;

   soap_init(&soap1);

   if (soap_bind(&soap1, host, port, backlog) < 0) exit(1);
   if (soap_accept(&soap1) < 0) exit(1);
   pthread_create(&tid,NULL, (void*(*)(void*))soap_serve, (void*)&soap1);
   soap_init(&soap2);
   soap_call_ns__method(&soap2, ...); // 调用远程方法
   soap_end(&soap2);
   pthread_join(tid, NULL); // 等待线程结束
   soap_end(&soap1); // 释放环境变量
}

在上面的例子中，需要两个环境变量信息。而在1.x版本中，由于静态分配环境变量，多线程技术是不被允许的（只有一个线程可以用这个环境变量调用远程方法或处理请求信息）。

8.1 如何使用gSOAP编译环境来编译SOAP客户端程序

通常，一个SOAP客户端应用的实现需要为每个客户端需要调用的远程方法提供一个存根例程（stub routine）。存根例程主要负责编码参数信息；将包含参数信息的调用请求发送给制定的SOAP服务；等待返回结果；将结果中的参数信息编码。客户端程序调用访问远程方法的存根例程就像调用本地方法一样。用C/C++手工别写一个存根例程是个十分痛苦的差使，尤其当远程方法的参数中包含特定的数据结构（如：记录、数组、图等）时。幸运的是，gSOAP包中的'wsdl2h'WSDL解析器和'soapcpp2’存根及架构编译器能够将web服务客户端及服务端的开发工作自动化。

'soapcpp2’存根及架构编译器是可以生成构建C++ SOAP客户端所需的C++源码的预编译器。该预编译器的输入参数是一个标准的C/C++头文件。这个头文件可以由WSDL解析器根据相关的WSDL文档自动生成。

8.1.1 例子

XMethods Delayed Stock Quote 服务提供一个getQuote方法（由'wsdl2h'WSDL解析器生成的quote.h定义）。这个方法根据提供的股票名称返回相应的股票价格。下面是这个方法的WSDL文档信息：

Endpoint URL: http://services.xmethods.net:80/soap
SOAP action: "" (2 quotes)
Remote method namespace: urn:xmethods-delayed-quotes
Remote method name: getQuote
Input parameter: symbol of type xsd:string
Output parameter: Result of type xsd:float

下面是由WSDL解析器生成的getQuote.h头文件（实际的文件内容与'wsdl2h'版本及生成选项有关）：

//gSOAP ns1 service name: net_DOTxmethods_DOTservices_DOTstockquote_DOTStockQuoteBinding
//gSOAP ns1 service type: net_DOTxmethods_DOTservices_DOTstockquote_DOTStockQuotePortType
//gSOAP ns1 service port: http://66.28.98.121:9090/soap
//gSOAP ns1 service namespace: urn:xmethods-delayed-quotes
//gSOAP ns1 service documentation: Definitions generated by the gSOAP WSDL parser 1.0
//gSOAP ns1 service method-style: getQuote rpc
//gSOAP ns1 service method-encoding: getQuote http://schemas.xmlsoap.org/soap/encoding/
//gSOAP ns1 service method-action: getQuote urn:xmethods-delayed-quotes#getQuote
int ns1__getQuote(char *symbol, float &Result);

这个头文件用C/C++代码为gSOAP预编译器指定了web服务的细节。远程方法被定义为函数ns1__getQuote，同时指定了客户端调用web服务所需
的所有细节信息。
`
getQuote远程方法需要一个名为symbol的字符串作为输入参数，同时需要一个名为Result的浮点数作为输出参数。预编译器生成的远程方法调用函数中，最后一个参数必须是输出参数，该参数以引用方式传递或定义为指针类型。除此之外的所有参数都是输入参数，这些参数必须以传值方式传递。函数返回一个整型值，其值说明web服务调用成功或出现的错误。具体的错误代码信息参见10.2节。

预编译器根据getQuote.h中定义的信息来生成存根例程的代码框架。这个存根例程可以在客户端程序中随处调用。存根例程被声明为下面的样子：
int soap_call_ns1__getQuote(struct soap *soap, char *URL, char *action, char *symbol, float &Result);

存根例程保存在soapClient.cpp文件中；URL是web服务的URL；action指明了web服务需要的SOAP action。XMethods Delayed Stock Quote服务的URL是http://66.28.98.121:9090/soap，action是"" (2 quotes)。你可以动态的改变URL及action。如果上述两个变量定义为NULL，则会使用头文件中定义的信息。下面的例子调用远程方法获取IBM的股票信息：


#include "soapH.h" // 包含生成的存根例程定义
#include "net_DOT_xmethods_DOT_services_DOT_stockquote_DOT_StockQuoteBinding.nsmap" // 包含命名空间表

int main()
{
   struct soap soap; // gSOAP运行环境
   float quote;
   soap_init(&soap); // 初始化运行环境（只执行一次）
   if (soap_call_ns1__getQuote(&soap, NULL, NULL, "IBM", &quote) == SOAP_OK)
      std::cout << "Current IBM Stock Quote = " << quote << std::endl;
   else // an error occurred
      soap_print_fault(&soap, stderr); // 在stderr中显示错误信息
   
   soap_destroy(&soap); // 删除类实例（仅用于C++中）
   soap_end(&soap); // 清除运行环境变量
   soap_done(&soap); // 卸载运行环境变量

   return 0;
}

下面的函数可以用来建立一个gSOAP运行环境（struct soap）：

soap_init(struct soap *soap) 初始化运行环境变量（只需要执行一次）
soap_init1(struct soap *soap, soap_mode iomode) 初始化运行环境变量同时设置in/out模式
soap_init2(struct soap *soap, soap_mode imode, soap_mode omode) 初始化运行环境变量同时分别设置in/out模式

struct soap *soap_new() 定义、初始化运行环境并返回一个执行运行环境的指针
struct soap *soap_new1(soap_mode iomode) 定义、初始化运行环境并返回一个执行运行环境的指针并设置in/out模式
struct soap *soap_new2(soap_mode imode, soap_mode omode) 定义、初始化运行环境并返回一个执行运行环境的指针并分别设置in/out模式

struct soap *soap_copy(struct soap *soap) 定义一个新的环境变量并将现有环境信息赋值给新的变量
soap_done(struct soap *soap) 重置、关闭连接，清除环境变量

环境变量可以在程序中任意次数的使用。每个新的线程就需要一个新的环境变量实例。当例子中的客户端程序执行时，SOAP请求通过soap_call_ns1__getQuote函数来调用，它生成下面的SOAP RPC请求信息：

服务返回的信息通过存根例程来解析，并保存在soap_call_ns1__getQuote函数的quote参数中。客户端程序可以在任意时间多次调用远程方法。请看下面的例子：

struct soap soap;
float quotes[3]; char *myportfolio[] = {"IBM", "MSDN"};
soap_init(&soap); // need to initialize only once
for (int i = 0; i < 3; i++)
   if (soap_call_ns1__getQuote(&soap, "http://services.xmethods.net:80/soap", "", myportfolio[i], &quotes[i]) != SOAP_OK)
      break;
if (soap.error) // an error occurred
   soap_print_fault(&soap, stderr);

命名空间前缀及命名空间名称同时也被用来验证SOAP信息的内容有效性。存根例程通过命名空间表中的信息来验证服务返回信息。命名空间表在运行时被取出用于解析命名空间绑定，反序列化数据结构，解码并验证服务返回信息。命名空间表不应该包含在gSOAP预编译器所需输入的头文件中。

Delayed Stock Quote服务客户端的命名空间表如下：
struct Namespace namespaces[] =
{   // {"命名前缀", "空间名称"}
   {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, // 必须是第一行
   {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, // 必须是第二行
   {"xsi", "http://www.w3.org/2001/XMLSchema-instance"}, // 必须是第三行
   {"xsd", "http://www.w3.org/2001/XMLSchema"}, // 2001 XML 大纲
   {"ns1", "urn:xmethods-delayed-quotes"}, // 通过服务描述获取
   {NULL, NULL} // 结束
};

第一行命名空间是SOAP1.1协议默认命名空间。事实上，命名空间表就是用来让程序员可以规定SOAP编码方式，能够用包含命名空间的命名空间前缀来满足指定SOAP服务的命名空间需求的。举例来说，使用前面命名空间表中定义的命名空间前缀ns1，存根例程就可以对getQuote方法的请求进行编码。这个过程由gSOAP预编译器通过在getQuote.h文件中定义的包含前缀ns1的ns1__getQuote函数自动完成。通常，如果要在远程方法名，结构名，类名，字段名等结构或类中使用命名空间前缀，就必须在命名空间表中进行定义。命名空间表将会被存根例程封装，并按下面的形式输出：

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
   xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   xmlns:ns1="urn:xmethods-delayed-quotes"
   SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
...

这个命名空间绑定将被SOAP服务用来验证SOAP请求。

8.1.3 例子

使用命名空间前缀可以解决在不同的服务中使用相同名称的远程方法的问题，看下面的例子：
// Contents of file "getQuote.h":
int ns1__getQuote(char *symbol, float &Result);
int ns2__getQuote(char *ticker, char *&quote);

这个例子允许客户端程序使用不同的命名空间以便连接到不同的服务程序执行其中的远程方法。命名空间前缀也可以用在类声明中使用，在XML大纲中区分同名但不同命名空间的SOAP值。例如：

class e__Address // an electronic address
{
   char *email;
   char *url;
};
class s__Address // a street address
{
   char *street;
   int number;
   char *city;
};

在生成的序列化函数中，使用e__Address的一个实例来表示e命名空间前缀的一个地址元素类型。

<e:Address xsi:type="e:Address">
<email xsi:type="string">me@home</email>
<url xsi:type="string">www.me.com</url>
</e:Address>

用s__Address的一个实例来表示s命名空间前缀的一个地址元素类型。
<s:Address xsi:type="s:Address">

客户端程序的命名空间表必须有e和s的数据类型定义：
struct Namespace namespaces[] =
{ ...
   {"e", "http://www.me.com/schemas/electronic-address"},
   {"s", "http://www.me.com/schemas/street-address"},

命名空间表必须作为客户端程序的一部分，使客户端程序在运行时可以对数据进行序列化及反序列化。


8.1.5 XSD 类型编码
许多SOAP服务需要在SOAP负载中使用XML编码。在gSOAP预编译器中使用的默认编码为SOAP RPC编码。然而，使用XSD类型编码可以改善互操作性。XSD类型在头文件中用typedef定义。举个例子，下面的定义将C/C++类型转换为XSD类型：
// Contents of header file:

typedef char *xsd__string; // encode xsd__string value as the xsd:string schema type
typedef char *xsd__anyURI; // encode xsd__anyURI value as the xsd:anyURI schema type
typedef float xsd__float; // encode xsd__float value as the xsd:float schema type

这些简单的声明告诉gSOAP预编译器当远程方法参数中使用上述定义的类型时，就把相关的C++类型转当作内建的XSD类型进行编码、解码。同时，使用typedef不需要使用内建C++类型的客户端或服务端程序更改现有代码（但只是当参数为简单的C++类型时，请参看11.2.2节来使用XSD类型表示组合的数据类型）。

// Contents of file "getQuote.h":
typedef char *xsd__string;
typedef float xsd__float;

int ns1__getQuote(xsd__string symbol, xsd__float &Result);

8.1.7 如何改变回传元素的名称
SOAP返回消息中的元素命名没有固定的方式，但是推荐使用方法名加Response结尾。例如，getQuote方法的返回参数为getQuoteResponse。
struct ns1__getQuoteResponse {xsd__float Result;};
int ns1__getQuote(xsd__string symbol, struct ns1__getQuoteResponse &r);

类或结构体的定义也可以在函数内部进行，如:
int ns1__getQuote(xsd__string symbol, struct ns1__getQuoteResponse {xsd__float Result;} &r);

8.1.9 如何指定多个输出参数
gSOAP预编译器将远程方法的最后一个参数作为输出参数，其余的参数都作为输入参数。如果要使用多个输出参数，就必须将输出参数定义为结构或类的形式。
如果使用同一个变量作为输入、输出参数，也可以用结构体来定义。看下面的例子：
int X_rox__copy_name(char *name, struct X_rox__copy_nameResponse {char *name;} &r);

8.1.13 如何指定匿名参数名
SOAP1.1协议允许使用匿名参数。也就是说，远程方法的输出参数名不必与客户端的参数名严格保持一致。同样，远程方法的输入参数名也不必与客户端的参数名严格保持一致。虽然这种转换在SOAP1.2版本中不被提倡，但是gSOAP预编译器可以生成支持匿名参数的存根例程。只要在远程方法调用函数中的参数名称省略就可以使用匿名参数了。看下面的例子：

8.1.15 如何定义没有输出参数的方法
要指定一个没有输出参数的方法，需要将输出参数类型定义为一个空的结构体指针。

enum ns__event { off, on, stand_by };
int ns__signal(enum ns__event in, struct ns__signalResponse { } *out);

因为输出结构体为空，所以就没有输出参数了。如果编译器不支持空结构体，就指定一个包含void*类型变量的结构体。
有些SOAP资源用空的输出参数作为单向SOAP消息使用。但是，我们使用异步调用方式来支持单向消息。我们将在8.3节中详细讨论。
