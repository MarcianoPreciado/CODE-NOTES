/* soapC.c
   Generated by gSOAP 2.8.14 from jnuy.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.14 2013-03-19 04:13:29 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(soap, NULL, NULL, "ns1:m_tz_update1Response");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, NULL, NULL, "ns1:m_tz_update1");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response:
		return soap_in_PointerTo_ns1__TZ_USCOREDay1Response(soap, NULL, NULL, "ns1:TZ_Day1Response");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1:
		return soap_in_PointerTo_ns1__TZ_USCOREDay1(soap, NULL, NULL, "ns1:TZ_Day1");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, NULL, NULL, "ns1:hb_fp_dy_end1Response");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, NULL, NULL, "ns1:hb_fp_dy_end1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response:
		return soap_in_PointerTo_ns1__get_USCOREyue1Response(soap, NULL, NULL, "ns1:get_yue1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1:
		return soap_in_PointerTo_ns1__get_USCOREyue1(soap, NULL, NULL, "ns1:get_yue1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response:
		return soap_in_PointerTo_ns1__get_USCOREyyzd1Response(soap, NULL, NULL, "ns1:get_yyzd1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1:
		return soap_in_PointerTo_ns1__get_USCOREyyzd1(soap, NULL, NULL, "ns1:get_yyzd1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response:
		return soap_in_PointerTo_ns1__get_USCOREhbfp1Response(soap, NULL, NULL, "ns1:get_hbfp1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1:
		return soap_in_PointerTo_ns1__get_USCOREhbfp1(soap, NULL, NULL, "ns1:get_hbfp1");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response(soap, NULL, NULL, "ns1:hbtsf_update1Response");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdate1(soap, NULL, NULL, "ns1:hbtsf_update1");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response(soap, NULL, NULL, "ns1:hbwsh_update1Response");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdate1(soap, NULL, NULL, "ns1:hbwsh_update1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response:
		return soap_in_PointerTo_ns1__get_USCOREmx1Response(soap, NULL, NULL, "ns1:get_mx1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1:
		return soap_in_PointerTo_ns1__get_USCOREmx1(soap, NULL, NULL, "ns1:get_mx1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh1Response(soap, NULL, NULL, "ns1:get_hbwsh1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh1(soap, NULL, NULL, "ns1:get_hbwsh1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response:
		return soap_in_PointerTo_ns1__get_USCOREhbgs1Response(soap, NULL, NULL, "ns1:get_hbgs1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1:
		return soap_in_PointerTo_ns1__get_USCOREhbgs1(soap, NULL, NULL, "ns1:get_hbgs1");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse:
		return soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(soap, NULL, NULL, "ns1:fp_dy_endResponse");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREend:
		return soap_in_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, NULL, NULL, "ns1:fp_dy_end");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse:
		return soap_in_PointerTo_ns1__get_USCOREzbfpResponse(soap, NULL, NULL, "ns1:get_zbfpResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfp:
		return soap_in_PointerTo_ns1__get_USCOREzbfp(soap, NULL, NULL, "ns1:get_zbfp");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(soap, NULL, NULL, "ns1:ZB_TZ_MonthResponse");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonth:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, NULL, NULL, "ns1:ZB_TZ_Month");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(soap, NULL, NULL, "ns1:ZB_TZ_DayResponse");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDay:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, NULL, NULL, "ns1:ZB_TZ_Day");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__tsf_USCOREupdateResponse(soap, NULL, NULL, "ns1:tsf_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdate:
		return soap_in_PointerTo_ns1__tsf_USCOREupdate(soap, NULL, NULL, "ns1:tsf_update");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__wsh_USCOREupdateResponse(soap, NULL, NULL, "ns1:wsh_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdate:
		return soap_in_PointerTo_ns1__wsh_USCOREupdate(soap, NULL, NULL, "ns1:wsh_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse:
		return soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(soap, NULL, NULL, "ns1:get_zb_mxResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmx:
		return soap_in_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, NULL, NULL, "ns1:get_zb_mx");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse:
		return soap_in_PointerTo_ns1__get_USCOREwshResponse(soap, NULL, NULL, "ns1:get_wshResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwsh:
		return soap_in_PointerTo_ns1__get_USCOREwsh(soap, NULL, NULL, "ns1:get_wsh");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, NULL, NULL, "ns1:hb_fp_dy_endResponse");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, NULL, NULL, "ns1:hb_fp_dy_end");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, NULL, NULL, "ns1:hbtsf_yue_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate:
		return soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, NULL, NULL, "ns1:hbtsf_yue_update");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, NULL, NULL, "ns1:hbwsh_yue_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate:
		return soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, NULL, NULL, "ns1:hbwsh_yue_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse:
		return soap_in_PointerTo_ns1__get_USCOREyueResponse(soap, NULL, NULL, "ns1:get_yueResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue:
		return soap_in_PointerTo_ns1__get_USCOREyue(soap, NULL, NULL, "ns1:get_yue");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(soap, NULL, NULL, "ns1:get_hbwsh_yueResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyue:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, NULL, NULL, "ns1:get_hbwsh_yue");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse:
		return soap_in_PointerTo_ns1__get_USCOREyyzdResponse(soap, NULL, NULL, "ns1:get_yyzdResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd:
		return soap_in_PointerTo_ns1__get_USCOREyyzd(soap, NULL, NULL, "ns1:get_yyzd");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse:
		return soap_in_PointerTo_ns1__get_USCOREhbfpResponse(soap, NULL, NULL, "ns1:get_hbfpResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp:
		return soap_in_PointerTo_ns1__get_USCOREhbfp(soap, NULL, NULL, "ns1:get_hbfp");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, NULL, NULL, "ns1:m_zb_tz_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		return soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, NULL, NULL, "ns1:m_zb_tz_update");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(soap, NULL, NULL, "ns1:m_tz_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, NULL, NULL, "ns1:m_tz_update");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse:
		return soap_in_PointerTo_ns1__TZ_USCOREMonthResponse(soap, NULL, NULL, "ns1:TZ_MonthResponse");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonth:
		return soap_in_PointerTo_ns1__TZ_USCOREMonth(soap, NULL, NULL, "ns1:TZ_Month");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse:
		return soap_in_PointerTo_ns1__TZ_USCOREDayResponse(soap, NULL, NULL, "ns1:TZ_DayResponse");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay:
		return soap_in_PointerTo_ns1__TZ_USCOREDay(soap, NULL, NULL, "ns1:TZ_Day");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse(soap, NULL, NULL, "ns1:hbtsf_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdate(soap, NULL, NULL, "ns1:hbtsf_update");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse(soap, NULL, NULL, "ns1:hbwsh_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdate(soap, NULL, NULL, "ns1:hbwsh_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse:
		return soap_in_PointerTo_ns1__get_USCOREmxResponse(soap, NULL, NULL, "ns1:get_mxResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx:
		return soap_in_PointerTo_ns1__get_USCOREmx(soap, NULL, NULL, "ns1:get_mx");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse:
		return soap_in_PointerTo_ns1__get_USCOREhbwshResponse(soap, NULL, NULL, "ns1:get_hbwshResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh(soap, NULL, NULL, "ns1:get_hbwsh");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse:
		return soap_in_PointerTo_ns1__get_USCOREhbgsResponse(soap, NULL, NULL, "ns1:get_hbgsResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs:
		return soap_in_PointerTo_ns1__get_USCOREhbgs(soap, NULL, NULL, "ns1:get_hbgs");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response:
		return soap_in_PointerTo_ns1__FromBASE64Response(soap, NULL, NULL, "ns1:FromBASE64Response");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64:
		return soap_in_PointerTo_ns1__FromBASE64(soap, NULL, NULL, "ns1:FromBASE64");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response:
		return soap_in_PointerTo_ns1__ToBASE64Response(soap, NULL, NULL, "ns1:ToBASE64Response");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64:
		return soap_in_PointerTo_ns1__ToBASE64(soap, NULL, NULL, "ns1:ToBASE64");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response:
		return soap_in_PointerTo_ns1__CheckSHA1Response(soap, NULL, NULL, "ns1:CheckSHA1Response");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1:
		return soap_in_PointerTo_ns1__CheckSHA1(soap, NULL, NULL, "ns1:CheckSHA1");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse:
		return soap_in_PointerTo_ns1__GetHostInfoResponse(soap, NULL, NULL, "ns1:GetHostInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfo:
		return soap_in_PointerTo_ns1__GetHostInfo(soap, NULL, NULL, "ns1:GetHostInfo");
	case SOAP_TYPE_PointerTo_ns1__GetDNSResponse:
		return soap_in_PointerTo_ns1__GetDNSResponse(soap, NULL, NULL, "ns1:GetDNSResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDNS:
		return soap_in_PointerTo_ns1__GetDNS(soap, NULL, NULL, "ns1:GetDNS");
	case SOAP_TYPE_PointerTo_ns1__GetTimeResponse:
		return soap_in_PointerTo_ns1__GetTimeResponse(soap, NULL, NULL, "ns1:GetTimeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTime:
		return soap_in_PointerTo_ns1__GetTime(soap, NULL, NULL, "ns1:GetTime");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, NULL, NULL, "ns1:m_tz_update1Response-m_tz_update1Result");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result:
		return soap_in_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, NULL, NULL, "ns1:TZ_Day1Response-TZ_Day1Result");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, NULL, NULL, "ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result:
		return soap_in_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, NULL, NULL, "ns1:get_yue1Response-get_yue1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result:
		return soap_in_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, NULL, NULL, "ns1:get_yyzd1Response-get_yyzd1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result:
		return soap_in_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, NULL, NULL, "ns1:get_hbfp1Response-get_hbfp1Result");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, NULL, NULL, "ns1:hbtsf_update1Response-hbtsf_update1Result");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, NULL, NULL, "ns1:hbwsh_update1Response-hbwsh_update1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result:
		return soap_in_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, NULL, NULL, "ns1:get_mx1Response-get_mx1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, NULL, NULL, "ns1:get_hbwsh1Response-get_hbwsh1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result:
		return soap_in_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, NULL, NULL, "ns1:get_hbgs1Response-get_hbgs1Result");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult:
		return soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, NULL, NULL, "ns1:fp_dy_endResponse-fp_dy_endResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult:
		return soap_in_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, NULL, NULL, "ns1:get_zbfpResponse-get_zbfpResult");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, NULL, NULL, "ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult:
		return soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, NULL, NULL, "ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult:
		return soap_in_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, NULL, NULL, "ns1:tsf_updateResponse-tsf_updateResult");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult:
		return soap_in_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, NULL, NULL, "ns1:wsh_updateResponse-wsh_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult:
		return soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, NULL, NULL, "ns1:get_zb_mxResponse-get_zb_mxResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult:
		return soap_in_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, NULL, NULL, "ns1:get_wshResponse-get_wshResult");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult:
		return soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, NULL, NULL, "ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult:
		return soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, NULL, NULL, "ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult:
		return soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, NULL, NULL, "ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult:
		return soap_in_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, NULL, NULL, "ns1:get_yueResponse-get_yueResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult:
		return soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, NULL, NULL, "ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult:
		return soap_in_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, NULL, NULL, "ns1:get_yyzdResponse-get_yyzdResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult:
		return soap_in_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, NULL, NULL, "ns1:get_hbfpResponse-get_hbfpResult");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult:
		return soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, NULL, NULL, "ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult:
		return soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, NULL, NULL, "ns1:m_tz_updateResponse-m_tz_updateResult");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult:
		return soap_in_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, NULL, NULL, "ns1:TZ_MonthResponse-TZ_MonthResult");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult:
		return soap_in_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, NULL, NULL, "ns1:TZ_DayResponse-TZ_DayResult");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult:
		return soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, NULL, NULL, "ns1:hbtsf_updateResponse-hbtsf_updateResult");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult:
		return soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, NULL, NULL, "ns1:hbwsh_updateResponse-hbwsh_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult:
		return soap_in_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, NULL, NULL, "ns1:get_mxResponse-get_mxResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult:
		return soap_in_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, NULL, NULL, "ns1:get_hbwshResponse-get_hbwshResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult:
		return soap_in_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, NULL, NULL, "ns1:get_hbgsResponse-get_hbgsResult");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response_FromBASE64Result:
		return soap_in_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, NULL, NULL, "ns1:FromBASE64Response-FromBASE64Result");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response_ToBASE64Result:
		return soap_in_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, NULL, NULL, "ns1:ToBASE64Response-ToBASE64Result");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result:
		return soap_in_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, NULL, NULL, "ns1:CheckSHA1Response-CheckSHA1Result");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult:
		return soap_in_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, NULL, NULL, "ns1:GetHostInfoResponse-GetHostInfoResult");
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:m_tz_update1Response-m_tz_update1Result"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result;
			return soap_in__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_tz_update1Response"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response;
			return soap_in__ns1__m_USCOREtz_USCOREupdate1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_tz_update1"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1;
			return soap_in__ns1__m_USCOREtz_USCOREupdate1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_Day1Response-TZ_Day1Result"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result;
			return soap_in__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_Day1Response"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDay1Response;
			return soap_in__ns1__TZ_USCOREDay1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_Day1"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDay1;
			return soap_in__ns1__TZ_USCOREDay1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_end1Response"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_end1"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yue1Response-get_yue1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result;
			return soap_in__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yue1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyue1Response;
			return soap_in__ns1__get_USCOREyue1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yue1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyue1;
			return soap_in__ns1__get_USCOREyue1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzd1Response-get_yyzd1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result;
			return soap_in__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzd1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzd1Response;
			return soap_in__ns1__get_USCOREyyzd1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzd1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzd1;
			return soap_in__ns1__get_USCOREyyzd1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfp1Response-get_hbfp1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result;
			return soap_in__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfp1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfp1Response;
			return soap_in__ns1__get_USCOREhbfp1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfp1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfp1;
			return soap_in__ns1__get_USCOREhbfp1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_update1Response-hbtsf_update1Result"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result;
			return soap_in__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_update1Response"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response;
			return soap_in__ns1__hbtsf_USCOREupdate1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_update1"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdate1;
			return soap_in__ns1__hbtsf_USCOREupdate1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_update1Response-hbwsh_update1Result"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result;
			return soap_in__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_update1Response"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response;
			return soap_in__ns1__hbwsh_USCOREupdate1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_update1"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdate1;
			return soap_in__ns1__hbwsh_USCOREupdate1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mx1Response-get_mx1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result;
			return soap_in__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mx1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmx1Response;
			return soap_in__ns1__get_USCOREmx1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mx1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmx1;
			return soap_in__ns1__get_USCOREmx1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh1Response-get_hbwsh1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result;
			return soap_in__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh1Response;
			return soap_in__ns1__get_USCOREhbwsh1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh1;
			return soap_in__ns1__get_USCOREhbwsh1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgs1Response-get_hbgs1Result"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result;
			return soap_in__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgs1Response"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgs1Response;
			return soap_in__ns1__get_USCOREhbgs1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgs1"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgs1;
			return soap_in__ns1__get_USCOREhbgs1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fp_dy_endResponse-fp_dy_endResult"))
		{	*type = SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult;
			return soap_in__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fp_dy_endResponse"))
		{	*type = SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse;
			return soap_in__ns1__fp_USCOREdy_USCOREendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fp_dy_end"))
		{	*type = SOAP_TYPE__ns1__fp_USCOREdy_USCOREend;
			return soap_in__ns1__fp_USCOREdy_USCOREend(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zbfpResponse-get_zbfpResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult;
			return soap_in__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zbfpResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzbfpResponse;
			return soap_in__ns1__get_USCOREzbfpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zbfp"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzbfp;
			return soap_in__ns1__get_USCOREzbfp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult;
			return soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_MonthResponse"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse;
			return soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_Month"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth;
			return soap_in__ns1__ZB_USCORETZ_USCOREMonth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult;
			return soap_in__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_DayResponse"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse;
			return soap_in__ns1__ZB_USCORETZ_USCOREDayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZB_TZ_Day"))
		{	*type = SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay;
			return soap_in__ns1__ZB_USCORETZ_USCOREDay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tsf_updateResponse-tsf_updateResult"))
		{	*type = SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult;
			return soap_in__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tsf_updateResponse"))
		{	*type = SOAP_TYPE__ns1__tsf_USCOREupdateResponse;
			return soap_in__ns1__tsf_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tsf_update"))
		{	*type = SOAP_TYPE__ns1__tsf_USCOREupdate;
			return soap_in__ns1__tsf_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wsh_updateResponse-wsh_updateResult"))
		{	*type = SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult;
			return soap_in__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wsh_updateResponse"))
		{	*type = SOAP_TYPE__ns1__wsh_USCOREupdateResponse;
			return soap_in__ns1__wsh_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wsh_update"))
		{	*type = SOAP_TYPE__ns1__wsh_USCOREupdate;
			return soap_in__ns1__wsh_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zb_mxResponse-get_zb_mxResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult;
			return soap_in__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zb_mxResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse;
			return soap_in__ns1__get_USCOREzb_USCOREmxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_zb_mx"))
		{	*type = SOAP_TYPE__ns1__get_USCOREzb_USCOREmx;
			return soap_in__ns1__get_USCOREzb_USCOREmx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_wshResponse-get_wshResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult;
			return soap_in__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_wshResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREwshResponse;
			return soap_in__ns1__get_USCOREwshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_wsh"))
		{	*type = SOAP_TYPE__ns1__get_USCOREwsh;
			return soap_in__ns1__get_USCOREwsh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_endResponse"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hb_fp_dy_end"))
		{	*type = SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend;
			return soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult;
			return soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_yue_updateResponse"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse;
			return soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_yue_update"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate;
			return soap_in__ns1__hbtsf_USCOREyue_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult;
			return soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_yue_updateResponse"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse;
			return soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_yue_update"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate;
			return soap_in__ns1__hbwsh_USCOREyue_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yueResponse-get_yueResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult;
			return soap_in__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yueResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyueResponse;
			return soap_in__ns1__get_USCOREyueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yue"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyue;
			return soap_in__ns1__get_USCOREyue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult;
			return soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh_yueResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse;
			return soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh_yue"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue;
			return soap_in__ns1__get_USCOREhbwsh_USCOREyue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzdResponse-get_yyzdResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult;
			return soap_in__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzdResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzdResponse;
			return soap_in__ns1__get_USCOREyyzdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_yyzd"))
		{	*type = SOAP_TYPE__ns1__get_USCOREyyzd;
			return soap_in__ns1__get_USCOREyyzd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfpResponse-get_hbfpResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult;
			return soap_in__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfpResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfpResponse;
			return soap_in__ns1__get_USCOREhbfpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbfp"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbfp;
			return soap_in__ns1__get_USCOREhbfp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult"))
		{	*type = SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult;
			return soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_zb_tz_updateResponse"))
		{	*type = SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse;
			return soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_zb_tz_update"))
		{	*type = SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate;
			return soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_tz_updateResponse-m_tz_updateResult"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult;
			return soap_in__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_tz_updateResponse"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse;
			return soap_in__ns1__m_USCOREtz_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:m_tz_update"))
		{	*type = SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate;
			return soap_in__ns1__m_USCOREtz_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_MonthResponse-TZ_MonthResult"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult;
			return soap_in__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_MonthResponse"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREMonthResponse;
			return soap_in__ns1__TZ_USCOREMonthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_Month"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREMonth;
			return soap_in__ns1__TZ_USCOREMonth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_DayResponse-TZ_DayResult"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult;
			return soap_in__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_DayResponse"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDayResponse;
			return soap_in__ns1__TZ_USCOREDayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TZ_Day"))
		{	*type = SOAP_TYPE__ns1__TZ_USCOREDay;
			return soap_in__ns1__TZ_USCOREDay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_updateResponse-hbtsf_updateResult"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult;
			return soap_in__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_updateResponse"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse;
			return soap_in__ns1__hbtsf_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbtsf_update"))
		{	*type = SOAP_TYPE__ns1__hbtsf_USCOREupdate;
			return soap_in__ns1__hbtsf_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_updateResponse-hbwsh_updateResult"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult;
			return soap_in__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_updateResponse"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse;
			return soap_in__ns1__hbwsh_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hbwsh_update"))
		{	*type = SOAP_TYPE__ns1__hbwsh_USCOREupdate;
			return soap_in__ns1__hbwsh_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mxResponse-get_mxResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult;
			return soap_in__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mxResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmxResponse;
			return soap_in__ns1__get_USCOREmxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mx"))
		{	*type = SOAP_TYPE__ns1__get_USCOREmx;
			return soap_in__ns1__get_USCOREmx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwshResponse-get_hbwshResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult;
			return soap_in__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwshResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwshResponse;
			return soap_in__ns1__get_USCOREhbwshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbwsh"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbwsh;
			return soap_in__ns1__get_USCOREhbwsh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgsResponse-get_hbgsResult"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult;
			return soap_in__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgsResponse"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgsResponse;
			return soap_in__ns1__get_USCOREhbgsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_hbgs"))
		{	*type = SOAP_TYPE__ns1__get_USCOREhbgs;
			return soap_in__ns1__get_USCOREhbgs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FromBASE64Response-FromBASE64Result"))
		{	*type = SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result;
			return soap_in__ns1__FromBASE64Response_FromBASE64Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FromBASE64Response"))
		{	*type = SOAP_TYPE__ns1__FromBASE64Response;
			return soap_in__ns1__FromBASE64Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FromBASE64"))
		{	*type = SOAP_TYPE__ns1__FromBASE64;
			return soap_in__ns1__FromBASE64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToBASE64Response-ToBASE64Result"))
		{	*type = SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result;
			return soap_in__ns1__ToBASE64Response_ToBASE64Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToBASE64Response"))
		{	*type = SOAP_TYPE__ns1__ToBASE64Response;
			return soap_in__ns1__ToBASE64Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToBASE64"))
		{	*type = SOAP_TYPE__ns1__ToBASE64;
			return soap_in__ns1__ToBASE64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSHA1Response-CheckSHA1Result"))
		{	*type = SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result;
			return soap_in__ns1__CheckSHA1Response_CheckSHA1Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSHA1Response"))
		{	*type = SOAP_TYPE__ns1__CheckSHA1Response;
			return soap_in__ns1__CheckSHA1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSHA1"))
		{	*type = SOAP_TYPE__ns1__CheckSHA1;
			return soap_in__ns1__CheckSHA1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHostInfoResponse-GetHostInfoResult"))
		{	*type = SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult;
			return soap_in__ns1__GetHostInfoResponse_GetHostInfoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHostInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetHostInfoResponse;
			return soap_in__ns1__GetHostInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHostInfo"))
		{	*type = SOAP_TYPE__ns1__GetHostInfo;
			return soap_in__ns1__GetHostInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDNSResponse"))
		{	*type = SOAP_TYPE__ns1__GetDNSResponse;
			return soap_in__ns1__GetDNSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDNS"))
		{	*type = SOAP_TYPE__ns1__GetDNS;
			return soap_in__ns1__GetDNS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetTimeResponse;
			return soap_in__ns1__GetTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTime"))
		{	*type = SOAP_TYPE__ns1__GetTime;
			return soap_in__ns1__GetTime(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result:
		return soap_out__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, "ns1:m_tz_update1Response-m_tz_update1Result", id, (const struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response:
		return soap_out__ns1__m_USCOREtz_USCOREupdate1Response(soap, "ns1:m_tz_update1Response", id, (const struct _ns1__m_USCOREtz_USCOREupdate1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1:
		return soap_out__ns1__m_USCOREtz_USCOREupdate1(soap, "ns1:m_tz_update1", id, (const struct _ns1__m_USCOREtz_USCOREupdate1 *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result:
		return soap_out__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, "ns1:TZ_Day1Response-TZ_Day1Result", id, (const struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDay1Response:
		return soap_out__ns1__TZ_USCOREDay1Response(soap, "ns1:TZ_Day1Response", id, (const struct _ns1__TZ_USCOREDay1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDay1:
		return soap_out__ns1__TZ_USCOREDay1(soap, "ns1:TZ_Day1", id, (const struct _ns1__TZ_USCOREDay1 *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, "ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, "ns1:hb_fp_dy_end1Response", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, "ns1:hb_fp_dy_end1", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result:
		return soap_out__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, "ns1:get_yue1Response-get_yue1Result", id, (const struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyue1Response:
		return soap_out__ns1__get_USCOREyue1Response(soap, "ns1:get_yue1Response", id, (const struct _ns1__get_USCOREyue1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyue1:
		return soap_out__ns1__get_USCOREyue1(soap, "ns1:get_yue1", id, (const struct _ns1__get_USCOREyue1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result:
		return soap_out__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, "ns1:get_yyzd1Response-get_yyzd1Result", id, (const struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzd1Response:
		return soap_out__ns1__get_USCOREyyzd1Response(soap, "ns1:get_yyzd1Response", id, (const struct _ns1__get_USCOREyyzd1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzd1:
		return soap_out__ns1__get_USCOREyyzd1(soap, "ns1:get_yyzd1", id, (const struct _ns1__get_USCOREyyzd1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result:
		return soap_out__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, "ns1:get_hbfp1Response-get_hbfp1Result", id, (const struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfp1Response:
		return soap_out__ns1__get_USCOREhbfp1Response(soap, "ns1:get_hbfp1Response", id, (const struct _ns1__get_USCOREhbfp1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfp1:
		return soap_out__ns1__get_USCOREhbfp1(soap, "ns1:get_hbfp1", id, (const struct _ns1__get_USCOREhbfp1 *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result:
		return soap_out__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, "ns1:hbtsf_update1Response-hbtsf_update1Result", id, (const struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response:
		return soap_out__ns1__hbtsf_USCOREupdate1Response(soap, "ns1:hbtsf_update1Response", id, (const struct _ns1__hbtsf_USCOREupdate1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1:
		return soap_out__ns1__hbtsf_USCOREupdate1(soap, "ns1:hbtsf_update1", id, (const struct _ns1__hbtsf_USCOREupdate1 *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result:
		return soap_out__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, "ns1:hbwsh_update1Response-hbwsh_update1Result", id, (const struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response:
		return soap_out__ns1__hbwsh_USCOREupdate1Response(soap, "ns1:hbwsh_update1Response", id, (const struct _ns1__hbwsh_USCOREupdate1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1:
		return soap_out__ns1__hbwsh_USCOREupdate1(soap, "ns1:hbwsh_update1", id, (const struct _ns1__hbwsh_USCOREupdate1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result:
		return soap_out__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, "ns1:get_mx1Response-get_mx1Result", id, (const struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmx1Response:
		return soap_out__ns1__get_USCOREmx1Response(soap, "ns1:get_mx1Response", id, (const struct _ns1__get_USCOREmx1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmx1:
		return soap_out__ns1__get_USCOREmx1(soap, "ns1:get_mx1", id, (const struct _ns1__get_USCOREmx1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result:
		return soap_out__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, "ns1:get_hbwsh1Response-get_hbwsh1Result", id, (const struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh1Response:
		return soap_out__ns1__get_USCOREhbwsh1Response(soap, "ns1:get_hbwsh1Response", id, (const struct _ns1__get_USCOREhbwsh1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh1:
		return soap_out__ns1__get_USCOREhbwsh1(soap, "ns1:get_hbwsh1", id, (const struct _ns1__get_USCOREhbwsh1 *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result:
		return soap_out__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, "ns1:get_hbgs1Response-get_hbgs1Result", id, (const struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgs1Response:
		return soap_out__ns1__get_USCOREhbgs1Response(soap, "ns1:get_hbgs1Response", id, (const struct _ns1__get_USCOREhbgs1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgs1:
		return soap_out__ns1__get_USCOREhbgs1(soap, "ns1:get_hbgs1", id, (const struct _ns1__get_USCOREhbgs1 *)ptr, NULL);
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult:
		return soap_out__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, "ns1:fp_dy_endResponse-fp_dy_endResult", id, (const struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *)ptr, NULL);
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse:
		return soap_out__ns1__fp_USCOREdy_USCOREendResponse(soap, "ns1:fp_dy_endResponse", id, (const struct _ns1__fp_USCOREdy_USCOREendResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREend:
		return soap_out__ns1__fp_USCOREdy_USCOREend(soap, "ns1:fp_dy_end", id, (const struct _ns1__fp_USCOREdy_USCOREend *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult:
		return soap_out__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, "ns1:get_zbfpResponse-get_zbfpResult", id, (const struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzbfpResponse:
		return soap_out__ns1__get_USCOREzbfpResponse(soap, "ns1:get_zbfpResponse", id, (const struct _ns1__get_USCOREzbfpResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzbfp:
		return soap_out__ns1__get_USCOREzbfp(soap, "ns1:get_zbfp", id, (const struct _ns1__get_USCOREzbfp *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult:
		return soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, "ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult", id, (const struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse:
		return soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, "ns1:ZB_TZ_MonthResponse", id, (const struct _ns1__ZB_USCORETZ_USCOREMonthResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth:
		return soap_out__ns1__ZB_USCORETZ_USCOREMonth(soap, "ns1:ZB_TZ_Month", id, (const struct _ns1__ZB_USCORETZ_USCOREMonth *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult:
		return soap_out__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, "ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult", id, (const struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse:
		return soap_out__ns1__ZB_USCORETZ_USCOREDayResponse(soap, "ns1:ZB_TZ_DayResponse", id, (const struct _ns1__ZB_USCORETZ_USCOREDayResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay:
		return soap_out__ns1__ZB_USCORETZ_USCOREDay(soap, "ns1:ZB_TZ_Day", id, (const struct _ns1__ZB_USCORETZ_USCOREDay *)ptr, NULL);
	case SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult:
		return soap_out__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, "ns1:tsf_updateResponse-tsf_updateResult", id, (const struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__tsf_USCOREupdateResponse:
		return soap_out__ns1__tsf_USCOREupdateResponse(soap, "ns1:tsf_updateResponse", id, (const struct _ns1__tsf_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__tsf_USCOREupdate:
		return soap_out__ns1__tsf_USCOREupdate(soap, "ns1:tsf_update", id, (const struct _ns1__tsf_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult:
		return soap_out__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, "ns1:wsh_updateResponse-wsh_updateResult", id, (const struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__wsh_USCOREupdateResponse:
		return soap_out__ns1__wsh_USCOREupdateResponse(soap, "ns1:wsh_updateResponse", id, (const struct _ns1__wsh_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__wsh_USCOREupdate:
		return soap_out__ns1__wsh_USCOREupdate(soap, "ns1:wsh_update", id, (const struct _ns1__wsh_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult:
		return soap_out__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, "ns1:get_zb_mxResponse-get_zb_mxResult", id, (const struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse:
		return soap_out__ns1__get_USCOREzb_USCOREmxResponse(soap, "ns1:get_zb_mxResponse", id, (const struct _ns1__get_USCOREzb_USCOREmxResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmx:
		return soap_out__ns1__get_USCOREzb_USCOREmx(soap, "ns1:get_zb_mx", id, (const struct _ns1__get_USCOREzb_USCOREmx *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult:
		return soap_out__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, "ns1:get_wshResponse-get_wshResult", id, (const struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREwshResponse:
		return soap_out__ns1__get_USCOREwshResponse(soap, "ns1:get_wshResponse", id, (const struct _ns1__get_USCOREwshResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREwsh:
		return soap_out__ns1__get_USCOREwsh(soap, "ns1:get_wsh", id, (const struct _ns1__get_USCOREwsh *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, "ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, "ns1:hb_fp_dy_endResponse", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend:
		return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, "ns1:hb_fp_dy_end", id, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult:
		return soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, "ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult", id, (const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse:
		return soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, "ns1:hbtsf_yue_updateResponse", id, (const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate:
		return soap_out__ns1__hbtsf_USCOREyue_USCOREupdate(soap, "ns1:hbtsf_yue_update", id, (const struct _ns1__hbtsf_USCOREyue_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult:
		return soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, "ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult", id, (const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse:
		return soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, "ns1:hbwsh_yue_updateResponse", id, (const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate:
		return soap_out__ns1__hbwsh_USCOREyue_USCOREupdate(soap, "ns1:hbwsh_yue_update", id, (const struct _ns1__hbwsh_USCOREyue_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult:
		return soap_out__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, "ns1:get_yueResponse-get_yueResult", id, (const struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyueResponse:
		return soap_out__ns1__get_USCOREyueResponse(soap, "ns1:get_yueResponse", id, (const struct _ns1__get_USCOREyueResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyue:
		return soap_out__ns1__get_USCOREyue(soap, "ns1:get_yue", id, (const struct _ns1__get_USCOREyue *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult:
		return soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, "ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult", id, (const struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse:
		return soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, "ns1:get_hbwsh_yueResponse", id, (const struct _ns1__get_USCOREhbwsh_USCOREyueResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue:
		return soap_out__ns1__get_USCOREhbwsh_USCOREyue(soap, "ns1:get_hbwsh_yue", id, (const struct _ns1__get_USCOREhbwsh_USCOREyue *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult:
		return soap_out__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, "ns1:get_yyzdResponse-get_yyzdResult", id, (const struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzdResponse:
		return soap_out__ns1__get_USCOREyyzdResponse(soap, "ns1:get_yyzdResponse", id, (const struct _ns1__get_USCOREyyzdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREyyzd:
		return soap_out__ns1__get_USCOREyyzd(soap, "ns1:get_yyzd", id, (const struct _ns1__get_USCOREyyzd *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult:
		return soap_out__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, "ns1:get_hbfpResponse-get_hbfpResult", id, (const struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfpResponse:
		return soap_out__ns1__get_USCOREhbfpResponse(soap, "ns1:get_hbfpResponse", id, (const struct _ns1__get_USCOREhbfpResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbfp:
		return soap_out__ns1__get_USCOREhbfp(soap, "ns1:get_hbfp", id, (const struct _ns1__get_USCOREhbfp *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult:
		return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, "ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult", id, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse:
		return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, "ns1:m_zb_tz_updateResponse", id, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, "ns1:m_zb_tz_update", id, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult:
		return soap_out__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, "ns1:m_tz_updateResponse-m_tz_updateResult", id, (const struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse:
		return soap_out__ns1__m_USCOREtz_USCOREupdateResponse(soap, "ns1:m_tz_updateResponse", id, (const struct _ns1__m_USCOREtz_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate:
		return soap_out__ns1__m_USCOREtz_USCOREupdate(soap, "ns1:m_tz_update", id, (const struct _ns1__m_USCOREtz_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult:
		return soap_out__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, "ns1:TZ_MonthResponse-TZ_MonthResult", id, (const struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREMonthResponse:
		return soap_out__ns1__TZ_USCOREMonthResponse(soap, "ns1:TZ_MonthResponse", id, (const struct _ns1__TZ_USCOREMonthResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREMonth:
		return soap_out__ns1__TZ_USCOREMonth(soap, "ns1:TZ_Month", id, (const struct _ns1__TZ_USCOREMonth *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult:
		return soap_out__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, "ns1:TZ_DayResponse-TZ_DayResult", id, (const struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDayResponse:
		return soap_out__ns1__TZ_USCOREDayResponse(soap, "ns1:TZ_DayResponse", id, (const struct _ns1__TZ_USCOREDayResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__TZ_USCOREDay:
		return soap_out__ns1__TZ_USCOREDay(soap, "ns1:TZ_Day", id, (const struct _ns1__TZ_USCOREDay *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult:
		return soap_out__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, "ns1:hbtsf_updateResponse-hbtsf_updateResult", id, (const struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse:
		return soap_out__ns1__hbtsf_USCOREupdateResponse(soap, "ns1:hbtsf_updateResponse", id, (const struct _ns1__hbtsf_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate:
		return soap_out__ns1__hbtsf_USCOREupdate(soap, "ns1:hbtsf_update", id, (const struct _ns1__hbtsf_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult:
		return soap_out__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, "ns1:hbwsh_updateResponse-hbwsh_updateResult", id, (const struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse:
		return soap_out__ns1__hbwsh_USCOREupdateResponse(soap, "ns1:hbwsh_updateResponse", id, (const struct _ns1__hbwsh_USCOREupdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate:
		return soap_out__ns1__hbwsh_USCOREupdate(soap, "ns1:hbwsh_update", id, (const struct _ns1__hbwsh_USCOREupdate *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult:
		return soap_out__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, "ns1:get_mxResponse-get_mxResult", id, (const struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmxResponse:
		return soap_out__ns1__get_USCOREmxResponse(soap, "ns1:get_mxResponse", id, (const struct _ns1__get_USCOREmxResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREmx:
		return soap_out__ns1__get_USCOREmx(soap, "ns1:get_mx", id, (const struct _ns1__get_USCOREmx *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult:
		return soap_out__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, "ns1:get_hbwshResponse-get_hbwshResult", id, (const struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwshResponse:
		return soap_out__ns1__get_USCOREhbwshResponse(soap, "ns1:get_hbwshResponse", id, (const struct _ns1__get_USCOREhbwshResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbwsh:
		return soap_out__ns1__get_USCOREhbwsh(soap, "ns1:get_hbwsh", id, (const struct _ns1__get_USCOREhbwsh *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult:
		return soap_out__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, "ns1:get_hbgsResponse-get_hbgsResult", id, (const struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgsResponse:
		return soap_out__ns1__get_USCOREhbgsResponse(soap, "ns1:get_hbgsResponse", id, (const struct _ns1__get_USCOREhbgsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__get_USCOREhbgs:
		return soap_out__ns1__get_USCOREhbgs(soap, "ns1:get_hbgs", id, (const struct _ns1__get_USCOREhbgs *)ptr, NULL);
	case SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result:
		return soap_out__ns1__FromBASE64Response_FromBASE64Result(soap, "ns1:FromBASE64Response-FromBASE64Result", id, (const struct _ns1__FromBASE64Response_FromBASE64Result *)ptr, NULL);
	case SOAP_TYPE__ns1__FromBASE64Response:
		return soap_out__ns1__FromBASE64Response(soap, "ns1:FromBASE64Response", id, (const struct _ns1__FromBASE64Response *)ptr, NULL);
	case SOAP_TYPE__ns1__FromBASE64:
		return soap_out__ns1__FromBASE64(soap, "ns1:FromBASE64", id, (const struct _ns1__FromBASE64 *)ptr, NULL);
	case SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result:
		return soap_out__ns1__ToBASE64Response_ToBASE64Result(soap, "ns1:ToBASE64Response-ToBASE64Result", id, (const struct _ns1__ToBASE64Response_ToBASE64Result *)ptr, NULL);
	case SOAP_TYPE__ns1__ToBASE64Response:
		return soap_out__ns1__ToBASE64Response(soap, "ns1:ToBASE64Response", id, (const struct _ns1__ToBASE64Response *)ptr, NULL);
	case SOAP_TYPE__ns1__ToBASE64:
		return soap_out__ns1__ToBASE64(soap, "ns1:ToBASE64", id, (const struct _ns1__ToBASE64 *)ptr, NULL);
	case SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result:
		return soap_out__ns1__CheckSHA1Response_CheckSHA1Result(soap, "ns1:CheckSHA1Response-CheckSHA1Result", id, (const struct _ns1__CheckSHA1Response_CheckSHA1Result *)ptr, NULL);
	case SOAP_TYPE__ns1__CheckSHA1Response:
		return soap_out__ns1__CheckSHA1Response(soap, "ns1:CheckSHA1Response", id, (const struct _ns1__CheckSHA1Response *)ptr, NULL);
	case SOAP_TYPE__ns1__CheckSHA1:
		return soap_out__ns1__CheckSHA1(soap, "ns1:CheckSHA1", id, (const struct _ns1__CheckSHA1 *)ptr, NULL);
	case SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult:
		return soap_out__ns1__GetHostInfoResponse_GetHostInfoResult(soap, "ns1:GetHostInfoResponse-GetHostInfoResult", id, (const struct _ns1__GetHostInfoResponse_GetHostInfoResult *)ptr, NULL);
	case SOAP_TYPE__ns1__GetHostInfoResponse:
		return soap_out__ns1__GetHostInfoResponse(soap, "ns1:GetHostInfoResponse", id, (const struct _ns1__GetHostInfoResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetHostInfo:
		return soap_out__ns1__GetHostInfo(soap, "ns1:GetHostInfo", id, (const struct _ns1__GetHostInfo *)ptr, NULL);
	case SOAP_TYPE__ns1__GetDNSResponse:
		return soap_out__ns1__GetDNSResponse(soap, "ns1:GetDNSResponse", id, (const struct _ns1__GetDNSResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetDNS:
		return soap_out__ns1__GetDNS(soap, "ns1:GetDNS", id, (const struct _ns1__GetDNS *)ptr, NULL);
	case SOAP_TYPE__ns1__GetTimeResponse:
		return soap_out__ns1__GetTimeResponse(soap, "ns1:GetTimeResponse", id, (const struct _ns1__GetTimeResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetTime:
		return soap_out__ns1__GetTime(soap, "ns1:GetTime", id, (const struct _ns1__GetTime *)ptr, NULL);
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdate1Response *const*)ptr, "ns1:m_tz_update1Response");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdate1 *const*)ptr, "ns1:m_tz_update1");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response:
		return soap_out_PointerTo_ns1__TZ_USCOREDay1Response(soap, tag, id, (struct _ns1__TZ_USCOREDay1Response *const*)ptr, "ns1:TZ_Day1Response");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1:
		return soap_out_PointerTo_ns1__TZ_USCOREDay1(soap, tag, id, (struct _ns1__TZ_USCOREDay1 *const*)ptr, "ns1:TZ_Day1");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *const*)ptr, "ns1:hb_fp_dy_end1Response");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *const*)ptr, "ns1:hb_fp_dy_end1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response:
		return soap_out_PointerTo_ns1__get_USCOREyue1Response(soap, tag, id, (struct _ns1__get_USCOREyue1Response *const*)ptr, "ns1:get_yue1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1:
		return soap_out_PointerTo_ns1__get_USCOREyue1(soap, tag, id, (struct _ns1__get_USCOREyue1 *const*)ptr, "ns1:get_yue1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response:
		return soap_out_PointerTo_ns1__get_USCOREyyzd1Response(soap, tag, id, (struct _ns1__get_USCOREyyzd1Response *const*)ptr, "ns1:get_yyzd1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1:
		return soap_out_PointerTo_ns1__get_USCOREyyzd1(soap, tag, id, (struct _ns1__get_USCOREyyzd1 *const*)ptr, "ns1:get_yyzd1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response:
		return soap_out_PointerTo_ns1__get_USCOREhbfp1Response(soap, tag, id, (struct _ns1__get_USCOREhbfp1Response *const*)ptr, "ns1:get_hbfp1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1:
		return soap_out_PointerTo_ns1__get_USCOREhbfp1(soap, tag, id, (struct _ns1__get_USCOREhbfp1 *const*)ptr, "ns1:get_hbfp1");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response(soap, tag, id, (struct _ns1__hbtsf_USCOREupdate1Response *const*)ptr, "ns1:hbtsf_update1Response");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdate1(soap, tag, id, (struct _ns1__hbtsf_USCOREupdate1 *const*)ptr, "ns1:hbtsf_update1");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response(soap, tag, id, (struct _ns1__hbwsh_USCOREupdate1Response *const*)ptr, "ns1:hbwsh_update1Response");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdate1(soap, tag, id, (struct _ns1__hbwsh_USCOREupdate1 *const*)ptr, "ns1:hbwsh_update1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response:
		return soap_out_PointerTo_ns1__get_USCOREmx1Response(soap, tag, id, (struct _ns1__get_USCOREmx1Response *const*)ptr, "ns1:get_mx1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1:
		return soap_out_PointerTo_ns1__get_USCOREmx1(soap, tag, id, (struct _ns1__get_USCOREmx1 *const*)ptr, "ns1:get_mx1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh1Response(soap, tag, id, (struct _ns1__get_USCOREhbwsh1Response *const*)ptr, "ns1:get_hbwsh1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh1(soap, tag, id, (struct _ns1__get_USCOREhbwsh1 *const*)ptr, "ns1:get_hbwsh1");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response:
		return soap_out_PointerTo_ns1__get_USCOREhbgs1Response(soap, tag, id, (struct _ns1__get_USCOREhbgs1Response *const*)ptr, "ns1:get_hbgs1Response");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1:
		return soap_out_PointerTo_ns1__get_USCOREhbgs1(soap, tag, id, (struct _ns1__get_USCOREhbgs1 *const*)ptr, "ns1:get_hbgs1");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse:
		return soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(soap, tag, id, (struct _ns1__fp_USCOREdy_USCOREendResponse *const*)ptr, "ns1:fp_dy_endResponse");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREend:
		return soap_out_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, tag, id, (struct _ns1__fp_USCOREdy_USCOREend *const*)ptr, "ns1:fp_dy_end");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse:
		return soap_out_PointerTo_ns1__get_USCOREzbfpResponse(soap, tag, id, (struct _ns1__get_USCOREzbfpResponse *const*)ptr, "ns1:get_zbfpResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfp:
		return soap_out_PointerTo_ns1__get_USCOREzbfp(soap, tag, id, (struct _ns1__get_USCOREzbfp *const*)ptr, "ns1:get_zbfp");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREMonthResponse *const*)ptr, "ns1:ZB_TZ_MonthResponse");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonth:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREMonth *const*)ptr, "ns1:ZB_TZ_Month");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREDayResponse *const*)ptr, "ns1:ZB_TZ_DayResponse");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDay:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREDay *const*)ptr, "ns1:ZB_TZ_Day");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__tsf_USCOREupdateResponse(soap, tag, id, (struct _ns1__tsf_USCOREupdateResponse *const*)ptr, "ns1:tsf_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdate:
		return soap_out_PointerTo_ns1__tsf_USCOREupdate(soap, tag, id, (struct _ns1__tsf_USCOREupdate *const*)ptr, "ns1:tsf_update");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__wsh_USCOREupdateResponse(soap, tag, id, (struct _ns1__wsh_USCOREupdateResponse *const*)ptr, "ns1:wsh_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdate:
		return soap_out_PointerTo_ns1__wsh_USCOREupdate(soap, tag, id, (struct _ns1__wsh_USCOREupdate *const*)ptr, "ns1:wsh_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse:
		return soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(soap, tag, id, (struct _ns1__get_USCOREzb_USCOREmxResponse *const*)ptr, "ns1:get_zb_mxResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmx:
		return soap_out_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, tag, id, (struct _ns1__get_USCOREzb_USCOREmx *const*)ptr, "ns1:get_zb_mx");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse:
		return soap_out_PointerTo_ns1__get_USCOREwshResponse(soap, tag, id, (struct _ns1__get_USCOREwshResponse *const*)ptr, "ns1:get_wshResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwsh:
		return soap_out_PointerTo_ns1__get_USCOREwsh(soap, tag, id, (struct _ns1__get_USCOREwsh *const*)ptr, "ns1:get_wsh");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *const*)ptr, "ns1:hb_fp_dy_endResponse");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *const*)ptr, "ns1:hb_fp_dy_end");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag, id, (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *const*)ptr, "ns1:hbtsf_yue_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate:
		return soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, id, (struct _ns1__hbtsf_USCOREyue_USCOREupdate *const*)ptr, "ns1:hbtsf_yue_update");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag, id, (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *const*)ptr, "ns1:hbwsh_yue_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate:
		return soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, id, (struct _ns1__hbwsh_USCOREyue_USCOREupdate *const*)ptr, "ns1:hbwsh_yue_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse:
		return soap_out_PointerTo_ns1__get_USCOREyueResponse(soap, tag, id, (struct _ns1__get_USCOREyueResponse *const*)ptr, "ns1:get_yueResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue:
		return soap_out_PointerTo_ns1__get_USCOREyue(soap, tag, id, (struct _ns1__get_USCOREyue *const*)ptr, "ns1:get_yue");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag, id, (struct _ns1__get_USCOREhbwsh_USCOREyueResponse *const*)ptr, "ns1:get_hbwsh_yueResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyue:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, tag, id, (struct _ns1__get_USCOREhbwsh_USCOREyue *const*)ptr, "ns1:get_hbwsh_yue");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse:
		return soap_out_PointerTo_ns1__get_USCOREyyzdResponse(soap, tag, id, (struct _ns1__get_USCOREyyzdResponse *const*)ptr, "ns1:get_yyzdResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd:
		return soap_out_PointerTo_ns1__get_USCOREyyzd(soap, tag, id, (struct _ns1__get_USCOREyyzd *const*)ptr, "ns1:get_yyzd");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse:
		return soap_out_PointerTo_ns1__get_USCOREhbfpResponse(soap, tag, id, (struct _ns1__get_USCOREhbfpResponse *const*)ptr, "ns1:get_hbfpResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp:
		return soap_out_PointerTo_ns1__get_USCOREhbfp(soap, tag, id, (struct _ns1__get_USCOREhbfp *const*)ptr, "ns1:get_hbfp");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag, id, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *const*)ptr, "ns1:m_zb_tz_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		return soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, id, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *const*)ptr, "ns1:m_zb_tz_update");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdateResponse *const*)ptr, "ns1:m_tz_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdate *const*)ptr, "ns1:m_tz_update");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse:
		return soap_out_PointerTo_ns1__TZ_USCOREMonthResponse(soap, tag, id, (struct _ns1__TZ_USCOREMonthResponse *const*)ptr, "ns1:TZ_MonthResponse");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonth:
		return soap_out_PointerTo_ns1__TZ_USCOREMonth(soap, tag, id, (struct _ns1__TZ_USCOREMonth *const*)ptr, "ns1:TZ_Month");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse:
		return soap_out_PointerTo_ns1__TZ_USCOREDayResponse(soap, tag, id, (struct _ns1__TZ_USCOREDayResponse *const*)ptr, "ns1:TZ_DayResponse");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay:
		return soap_out_PointerTo_ns1__TZ_USCOREDay(soap, tag, id, (struct _ns1__TZ_USCOREDay *const*)ptr, "ns1:TZ_Day");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse(soap, tag, id, (struct _ns1__hbtsf_USCOREupdateResponse *const*)ptr, "ns1:hbtsf_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdate(soap, tag, id, (struct _ns1__hbtsf_USCOREupdate *const*)ptr, "ns1:hbtsf_update");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse(soap, tag, id, (struct _ns1__hbwsh_USCOREupdateResponse *const*)ptr, "ns1:hbwsh_updateResponse");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdate(soap, tag, id, (struct _ns1__hbwsh_USCOREupdate *const*)ptr, "ns1:hbwsh_update");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse:
		return soap_out_PointerTo_ns1__get_USCOREmxResponse(soap, tag, id, (struct _ns1__get_USCOREmxResponse *const*)ptr, "ns1:get_mxResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx:
		return soap_out_PointerTo_ns1__get_USCOREmx(soap, tag, id, (struct _ns1__get_USCOREmx *const*)ptr, "ns1:get_mx");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse:
		return soap_out_PointerTo_ns1__get_USCOREhbwshResponse(soap, tag, id, (struct _ns1__get_USCOREhbwshResponse *const*)ptr, "ns1:get_hbwshResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh(soap, tag, id, (struct _ns1__get_USCOREhbwsh *const*)ptr, "ns1:get_hbwsh");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse:
		return soap_out_PointerTo_ns1__get_USCOREhbgsResponse(soap, tag, id, (struct _ns1__get_USCOREhbgsResponse *const*)ptr, "ns1:get_hbgsResponse");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs:
		return soap_out_PointerTo_ns1__get_USCOREhbgs(soap, tag, id, (struct _ns1__get_USCOREhbgs *const*)ptr, "ns1:get_hbgs");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response:
		return soap_out_PointerTo_ns1__FromBASE64Response(soap, tag, id, (struct _ns1__FromBASE64Response *const*)ptr, "ns1:FromBASE64Response");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64:
		return soap_out_PointerTo_ns1__FromBASE64(soap, tag, id, (struct _ns1__FromBASE64 *const*)ptr, "ns1:FromBASE64");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response:
		return soap_out_PointerTo_ns1__ToBASE64Response(soap, tag, id, (struct _ns1__ToBASE64Response *const*)ptr, "ns1:ToBASE64Response");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64:
		return soap_out_PointerTo_ns1__ToBASE64(soap, tag, id, (struct _ns1__ToBASE64 *const*)ptr, "ns1:ToBASE64");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response:
		return soap_out_PointerTo_ns1__CheckSHA1Response(soap, tag, id, (struct _ns1__CheckSHA1Response *const*)ptr, "ns1:CheckSHA1Response");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1:
		return soap_out_PointerTo_ns1__CheckSHA1(soap, tag, id, (struct _ns1__CheckSHA1 *const*)ptr, "ns1:CheckSHA1");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse:
		return soap_out_PointerTo_ns1__GetHostInfoResponse(soap, tag, id, (struct _ns1__GetHostInfoResponse *const*)ptr, "ns1:GetHostInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfo:
		return soap_out_PointerTo_ns1__GetHostInfo(soap, tag, id, (struct _ns1__GetHostInfo *const*)ptr, "ns1:GetHostInfo");
	case SOAP_TYPE_PointerTo_ns1__GetDNSResponse:
		return soap_out_PointerTo_ns1__GetDNSResponse(soap, tag, id, (struct _ns1__GetDNSResponse *const*)ptr, "ns1:GetDNSResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDNS:
		return soap_out_PointerTo_ns1__GetDNS(soap, tag, id, (struct _ns1__GetDNS *const*)ptr, "ns1:GetDNS");
	case SOAP_TYPE_PointerTo_ns1__GetTimeResponse:
		return soap_out_PointerTo_ns1__GetTimeResponse(soap, tag, id, (struct _ns1__GetTimeResponse *const*)ptr, "ns1:GetTimeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTime:
		return soap_out_PointerTo_ns1__GetTime(soap, tag, id, (struct _ns1__GetTime *const*)ptr, "ns1:GetTime");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *const*)ptr, "ns1:m_tz_update1Response-m_tz_update1Result");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result:
		return soap_out_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag, id, (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *const*)ptr, "ns1:TZ_Day1Response-TZ_Day1Result");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *const*)ptr, "ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result:
		return soap_out_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag, id, (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *const*)ptr, "ns1:get_yue1Response-get_yue1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result:
		return soap_out_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag, id, (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *const*)ptr, "ns1:get_yyzd1Response-get_yyzd1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result:
		return soap_out_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag, id, (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *const*)ptr, "ns1:get_hbfp1Response-get_hbfp1Result");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag, id, (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *const*)ptr, "ns1:hbtsf_update1Response-hbtsf_update1Result");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag, id, (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *const*)ptr, "ns1:hbwsh_update1Response-hbwsh_update1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result:
		return soap_out_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag, id, (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *const*)ptr, "ns1:get_mx1Response-get_mx1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag, id, (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *const*)ptr, "ns1:get_hbwsh1Response-get_hbwsh1Result");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result:
		return soap_out_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag, id, (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *const*)ptr, "ns1:get_hbgs1Response-get_hbgs1Result");
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult:
		return soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag, id, (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *const*)ptr, "ns1:fp_dy_endResponse-fp_dy_endResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult:
		return soap_out_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag, id, (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *const*)ptr, "ns1:get_zbfpResponse-get_zbfpResult");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *const*)ptr, "ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult");
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult:
		return soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag, id, (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *const*)ptr, "ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult");
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult:
		return soap_out_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag, id, (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *const*)ptr, "ns1:tsf_updateResponse-tsf_updateResult");
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult:
		return soap_out_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag, id, (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *const*)ptr, "ns1:wsh_updateResponse-wsh_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult:
		return soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag, id, (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *const*)ptr, "ns1:get_zb_mxResponse-get_zb_mxResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult:
		return soap_out_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag, id, (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *const*)ptr, "ns1:get_wshResponse-get_wshResult");
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult:
		return soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag, id, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *const*)ptr, "ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult:
		return soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag, id, (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *const*)ptr, "ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult:
		return soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag, id, (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *const*)ptr, "ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult:
		return soap_out_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag, id, (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *const*)ptr, "ns1:get_yueResponse-get_yueResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult:
		return soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag, id, (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *const*)ptr, "ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult:
		return soap_out_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag, id, (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *const*)ptr, "ns1:get_yyzdResponse-get_yyzdResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult:
		return soap_out_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag, id, (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *const*)ptr, "ns1:get_hbfpResponse-get_hbfpResult");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult:
		return soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag, id, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *const*)ptr, "ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult");
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult:
		return soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag, id, (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *const*)ptr, "ns1:m_tz_updateResponse-m_tz_updateResult");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult:
		return soap_out_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag, id, (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *const*)ptr, "ns1:TZ_MonthResponse-TZ_MonthResult");
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult:
		return soap_out_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag, id, (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *const*)ptr, "ns1:TZ_DayResponse-TZ_DayResult");
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult:
		return soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag, id, (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *const*)ptr, "ns1:hbtsf_updateResponse-hbtsf_updateResult");
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult:
		return soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag, id, (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *const*)ptr, "ns1:hbwsh_updateResponse-hbwsh_updateResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult:
		return soap_out_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag, id, (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *const*)ptr, "ns1:get_mxResponse-get_mxResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult:
		return soap_out_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag, id, (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *const*)ptr, "ns1:get_hbwshResponse-get_hbwshResult");
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult:
		return soap_out_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag, id, (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *const*)ptr, "ns1:get_hbgsResponse-get_hbgsResult");
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response_FromBASE64Result:
		return soap_out_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, tag, id, (struct _ns1__FromBASE64Response_FromBASE64Result *const*)ptr, "ns1:FromBASE64Response-FromBASE64Result");
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response_ToBASE64Result:
		return soap_out_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, tag, id, (struct _ns1__ToBASE64Response_ToBASE64Result *const*)ptr, "ns1:ToBASE64Response-ToBASE64Result");
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result:
		return soap_out_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, tag, id, (struct _ns1__CheckSHA1Response_CheckSHA1Result *const*)ptr, "ns1:CheckSHA1Response-CheckSHA1Result");
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult:
		return soap_out_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag, id, (struct _ns1__GetHostInfoResponse_GetHostInfoResult *const*)ptr, "ns1:GetHostInfoResponse-GetHostInfoResult");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate1_:
		soap_serialize___ns1__m_USCOREtz_USCOREupdate1_(soap, (const struct __ns1__m_USCOREtz_USCOREupdate1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREDay1_:
		soap_serialize___ns1__TZ_USCOREDay1_(soap, (const struct __ns1__TZ_USCOREDay1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend1_:
		soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(soap, (const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyue1_:
		soap_serialize___ns1__get_USCOREyue1_(soap, (const struct __ns1__get_USCOREyue1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyyzd1_:
		soap_serialize___ns1__get_USCOREyyzd1_(soap, (const struct __ns1__get_USCOREyyzd1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbfp1_:
		soap_serialize___ns1__get_USCOREhbfp1_(soap, (const struct __ns1__get_USCOREhbfp1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREupdate1_:
		soap_serialize___ns1__hbtsf_USCOREupdate1_(soap, (const struct __ns1__hbtsf_USCOREupdate1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREupdate1_:
		soap_serialize___ns1__hbwsh_USCOREupdate1_(soap, (const struct __ns1__hbwsh_USCOREupdate1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREmx1_:
		soap_serialize___ns1__get_USCOREmx1_(soap, (const struct __ns1__get_USCOREmx1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh1_:
		soap_serialize___ns1__get_USCOREhbwsh1_(soap, (const struct __ns1__get_USCOREhbwsh1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbgs1_:
		soap_serialize___ns1__get_USCOREhbgs1_(soap, (const struct __ns1__get_USCOREhbgs1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__fp_USCOREdy_USCOREend_:
		soap_serialize___ns1__fp_USCOREdy_USCOREend_(soap, (const struct __ns1__fp_USCOREdy_USCOREend_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREzbfp_:
		soap_serialize___ns1__get_USCOREzbfp_(soap, (const struct __ns1__get_USCOREzbfp_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ZB_USCORETZ_USCOREMonth_:
		soap_serialize___ns1__ZB_USCORETZ_USCOREMonth_(soap, (const struct __ns1__ZB_USCORETZ_USCOREMonth_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ZB_USCORETZ_USCOREDay_:
		soap_serialize___ns1__ZB_USCORETZ_USCOREDay_(soap, (const struct __ns1__ZB_USCORETZ_USCOREDay_ *)ptr);
		break;
	case SOAP_TYPE___ns1__tsf_USCOREupdate_:
		soap_serialize___ns1__tsf_USCOREupdate_(soap, (const struct __ns1__tsf_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__wsh_USCOREupdate_:
		soap_serialize___ns1__wsh_USCOREupdate_(soap, (const struct __ns1__wsh_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREzb_USCOREmx_:
		soap_serialize___ns1__get_USCOREzb_USCOREmx_(soap, (const struct __ns1__get_USCOREzb_USCOREmx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREwsh_:
		soap_serialize___ns1__get_USCOREwsh_(soap, (const struct __ns1__get_USCOREwsh_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend_:
		soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend_(soap, (const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREyue_USCOREupdate_:
		soap_serialize___ns1__hbtsf_USCOREyue_USCOREupdate_(soap, (const struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREyue_USCOREupdate_:
		soap_serialize___ns1__hbwsh_USCOREyue_USCOREupdate_(soap, (const struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyue_:
		soap_serialize___ns1__get_USCOREyue_(soap, (const struct __ns1__get_USCOREyue_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh_USCOREyue_:
		soap_serialize___ns1__get_USCOREhbwsh_USCOREyue_(soap, (const struct __ns1__get_USCOREhbwsh_USCOREyue_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyyzd_:
		soap_serialize___ns1__get_USCOREyyzd_(soap, (const struct __ns1__get_USCOREyyzd_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbfp_:
		soap_serialize___ns1__get_USCOREhbfp_(soap, (const struct __ns1__get_USCOREhbfp_ *)ptr);
		break;
	case SOAP_TYPE___ns1__m_USCOREzb_USCOREtz_USCOREupdate_:
		soap_serialize___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(soap, (const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate_:
		soap_serialize___ns1__m_USCOREtz_USCOREupdate_(soap, (const struct __ns1__m_USCOREtz_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREMonth_:
		soap_serialize___ns1__TZ_USCOREMonth_(soap, (const struct __ns1__TZ_USCOREMonth_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREDay_:
		soap_serialize___ns1__TZ_USCOREDay_(soap, (const struct __ns1__TZ_USCOREDay_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREupdate_:
		soap_serialize___ns1__hbtsf_USCOREupdate_(soap, (const struct __ns1__hbtsf_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREupdate_:
		soap_serialize___ns1__hbwsh_USCOREupdate_(soap, (const struct __ns1__hbwsh_USCOREupdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREmx_:
		soap_serialize___ns1__get_USCOREmx_(soap, (const struct __ns1__get_USCOREmx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh_:
		soap_serialize___ns1__get_USCOREhbwsh_(soap, (const struct __ns1__get_USCOREhbwsh_ *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbgs_:
		soap_serialize___ns1__get_USCOREhbgs_(soap, (const struct __ns1__get_USCOREhbgs_ *)ptr);
		break;
	case SOAP_TYPE___ns1__FromBASE64_:
		soap_serialize___ns1__FromBASE64_(soap, (const struct __ns1__FromBASE64_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ToBASE64_:
		soap_serialize___ns1__ToBASE64_(soap, (const struct __ns1__ToBASE64_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSHA1_:
		soap_serialize___ns1__CheckSHA1_(soap, (const struct __ns1__CheckSHA1_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHostInfo_:
		soap_serialize___ns1__GetHostInfo_(soap, (const struct __ns1__GetHostInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDNS_:
		soap_serialize___ns1__GetDNS_(soap, (const struct __ns1__GetDNS_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTime_:
		soap_serialize___ns1__GetTime_(soap, (const struct __ns1__GetTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate1:
		soap_serialize___ns1__m_USCOREtz_USCOREupdate1(soap, (const struct __ns1__m_USCOREtz_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREDay1:
		soap_serialize___ns1__TZ_USCOREDay1(soap, (const struct __ns1__TZ_USCOREDay1 *)ptr);
		break;
	case SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, (const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyue1:
		soap_serialize___ns1__get_USCOREyue1(soap, (const struct __ns1__get_USCOREyue1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyyzd1:
		soap_serialize___ns1__get_USCOREyyzd1(soap, (const struct __ns1__get_USCOREyyzd1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbfp1:
		soap_serialize___ns1__get_USCOREhbfp1(soap, (const struct __ns1__get_USCOREhbfp1 *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREupdate1:
		soap_serialize___ns1__hbtsf_USCOREupdate1(soap, (const struct __ns1__hbtsf_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREupdate1:
		soap_serialize___ns1__hbwsh_USCOREupdate1(soap, (const struct __ns1__hbwsh_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREmx1:
		soap_serialize___ns1__get_USCOREmx1(soap, (const struct __ns1__get_USCOREmx1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh1:
		soap_serialize___ns1__get_USCOREhbwsh1(soap, (const struct __ns1__get_USCOREhbwsh1 *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbgs1:
		soap_serialize___ns1__get_USCOREhbgs1(soap, (const struct __ns1__get_USCOREhbgs1 *)ptr);
		break;
	case SOAP_TYPE___ns1__fp_USCOREdy_USCOREend:
		soap_serialize___ns1__fp_USCOREdy_USCOREend(soap, (const struct __ns1__fp_USCOREdy_USCOREend *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREzbfp:
		soap_serialize___ns1__get_USCOREzbfp(soap, (const struct __ns1__get_USCOREzbfp *)ptr);
		break;
	case SOAP_TYPE___ns1__ZB_USCORETZ_USCOREMonth:
		soap_serialize___ns1__ZB_USCORETZ_USCOREMonth(soap, (const struct __ns1__ZB_USCORETZ_USCOREMonth *)ptr);
		break;
	case SOAP_TYPE___ns1__ZB_USCORETZ_USCOREDay:
		soap_serialize___ns1__ZB_USCORETZ_USCOREDay(soap, (const struct __ns1__ZB_USCORETZ_USCOREDay *)ptr);
		break;
	case SOAP_TYPE___ns1__tsf_USCOREupdate:
		soap_serialize___ns1__tsf_USCOREupdate(soap, (const struct __ns1__tsf_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__wsh_USCOREupdate:
		soap_serialize___ns1__wsh_USCOREupdate(soap, (const struct __ns1__wsh_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREzb_USCOREmx:
		soap_serialize___ns1__get_USCOREzb_USCOREmx(soap, (const struct __ns1__get_USCOREzb_USCOREmx *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREwsh:
		soap_serialize___ns1__get_USCOREwsh(soap, (const struct __ns1__get_USCOREwsh *)ptr);
		break;
	case SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend:
		soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, (const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREyue_USCOREupdate:
		soap_serialize___ns1__hbtsf_USCOREyue_USCOREupdate(soap, (const struct __ns1__hbtsf_USCOREyue_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREyue_USCOREupdate:
		soap_serialize___ns1__hbwsh_USCOREyue_USCOREupdate(soap, (const struct __ns1__hbwsh_USCOREyue_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyue:
		soap_serialize___ns1__get_USCOREyue(soap, (const struct __ns1__get_USCOREyue *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh_USCOREyue:
		soap_serialize___ns1__get_USCOREhbwsh_USCOREyue(soap, (const struct __ns1__get_USCOREhbwsh_USCOREyue *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREyyzd:
		soap_serialize___ns1__get_USCOREyyzd(soap, (const struct __ns1__get_USCOREyyzd *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbfp:
		soap_serialize___ns1__get_USCOREhbfp(soap, (const struct __ns1__get_USCOREhbfp *)ptr);
		break;
	case SOAP_TYPE___ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		soap_serialize___ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, (const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate:
		soap_serialize___ns1__m_USCOREtz_USCOREupdate(soap, (const struct __ns1__m_USCOREtz_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREMonth:
		soap_serialize___ns1__TZ_USCOREMonth(soap, (const struct __ns1__TZ_USCOREMonth *)ptr);
		break;
	case SOAP_TYPE___ns1__TZ_USCOREDay:
		soap_serialize___ns1__TZ_USCOREDay(soap, (const struct __ns1__TZ_USCOREDay *)ptr);
		break;
	case SOAP_TYPE___ns1__hbtsf_USCOREupdate:
		soap_serialize___ns1__hbtsf_USCOREupdate(soap, (const struct __ns1__hbtsf_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__hbwsh_USCOREupdate:
		soap_serialize___ns1__hbwsh_USCOREupdate(soap, (const struct __ns1__hbwsh_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREmx:
		soap_serialize___ns1__get_USCOREmx(soap, (const struct __ns1__get_USCOREmx *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbwsh:
		soap_serialize___ns1__get_USCOREhbwsh(soap, (const struct __ns1__get_USCOREhbwsh *)ptr);
		break;
	case SOAP_TYPE___ns1__get_USCOREhbgs:
		soap_serialize___ns1__get_USCOREhbgs(soap, (const struct __ns1__get_USCOREhbgs *)ptr);
		break;
	case SOAP_TYPE___ns1__FromBASE64:
		soap_serialize___ns1__FromBASE64(soap, (const struct __ns1__FromBASE64 *)ptr);
		break;
	case SOAP_TYPE___ns1__ToBASE64:
		soap_serialize___ns1__ToBASE64(soap, (const struct __ns1__ToBASE64 *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSHA1:
		soap_serialize___ns1__CheckSHA1(soap, (const struct __ns1__CheckSHA1 *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHostInfo:
		soap_serialize___ns1__GetHostInfo(soap, (const struct __ns1__GetHostInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDNS:
		soap_serialize___ns1__GetDNS(soap, (const struct __ns1__GetDNS *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTime:
		soap_serialize___ns1__GetTime(soap, (const struct __ns1__GetTime *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result:
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, (const struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response:
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response(soap, (const struct _ns1__m_USCOREtz_USCOREupdate1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1:
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1(soap, (const struct _ns1__m_USCOREtz_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result:
		soap_serialize__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, (const struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDay1Response:
		soap_serialize__ns1__TZ_USCOREDay1Response(soap, (const struct _ns1__TZ_USCOREDay1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDay1:
		soap_serialize__ns1__TZ_USCOREDay1(soap, (const struct _ns1__TZ_USCOREDay1 *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result:
		soap_serialize__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, (const struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyue1Response:
		soap_serialize__ns1__get_USCOREyue1Response(soap, (const struct _ns1__get_USCOREyue1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyue1:
		soap_serialize__ns1__get_USCOREyue1(soap, (const struct _ns1__get_USCOREyue1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result:
		soap_serialize__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, (const struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzd1Response:
		soap_serialize__ns1__get_USCOREyyzd1Response(soap, (const struct _ns1__get_USCOREyyzd1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzd1:
		soap_serialize__ns1__get_USCOREyyzd1(soap, (const struct _ns1__get_USCOREyyzd1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result:
		soap_serialize__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, (const struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfp1Response:
		soap_serialize__ns1__get_USCOREhbfp1Response(soap, (const struct _ns1__get_USCOREhbfp1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfp1:
		soap_serialize__ns1__get_USCOREhbfp1(soap, (const struct _ns1__get_USCOREhbfp1 *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result:
		soap_serialize__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, (const struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response:
		soap_serialize__ns1__hbtsf_USCOREupdate1Response(soap, (const struct _ns1__hbtsf_USCOREupdate1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate1:
		soap_serialize__ns1__hbtsf_USCOREupdate1(soap, (const struct _ns1__hbtsf_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result:
		soap_serialize__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, (const struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response:
		soap_serialize__ns1__hbwsh_USCOREupdate1Response(soap, (const struct _ns1__hbwsh_USCOREupdate1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate1:
		soap_serialize__ns1__hbwsh_USCOREupdate1(soap, (const struct _ns1__hbwsh_USCOREupdate1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result:
		soap_serialize__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, (const struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmx1Response:
		soap_serialize__ns1__get_USCOREmx1Response(soap, (const struct _ns1__get_USCOREmx1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmx1:
		soap_serialize__ns1__get_USCOREmx1(soap, (const struct _ns1__get_USCOREmx1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result:
		soap_serialize__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, (const struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh1Response:
		soap_serialize__ns1__get_USCOREhbwsh1Response(soap, (const struct _ns1__get_USCOREhbwsh1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh1:
		soap_serialize__ns1__get_USCOREhbwsh1(soap, (const struct _ns1__get_USCOREhbwsh1 *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result:
		soap_serialize__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, (const struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgs1Response:
		soap_serialize__ns1__get_USCOREhbgs1Response(soap, (const struct _ns1__get_USCOREhbgs1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgs1:
		soap_serialize__ns1__get_USCOREhbgs1(soap, (const struct _ns1__get_USCOREhbgs1 *)ptr);
		break;
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult:
		soap_serialize__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, (const struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *)ptr);
		break;
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse:
		soap_serialize__ns1__fp_USCOREdy_USCOREendResponse(soap, (const struct _ns1__fp_USCOREdy_USCOREendResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__fp_USCOREdy_USCOREend:
		soap_serialize__ns1__fp_USCOREdy_USCOREend(soap, (const struct _ns1__fp_USCOREdy_USCOREend *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult:
		soap_serialize__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, (const struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzbfpResponse:
		soap_serialize__ns1__get_USCOREzbfpResponse(soap, (const struct _ns1__get_USCOREzbfpResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzbfp:
		soap_serialize__ns1__get_USCOREzbfp(soap, (const struct _ns1__get_USCOREzbfp *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult:
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, (const struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse:
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, (const struct _ns1__ZB_USCORETZ_USCOREMonthResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth:
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonth(soap, (const struct _ns1__ZB_USCORETZ_USCOREMonth *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult:
		soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, (const struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse:
		soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse(soap, (const struct _ns1__ZB_USCORETZ_USCOREDayResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay:
		soap_serialize__ns1__ZB_USCORETZ_USCOREDay(soap, (const struct _ns1__ZB_USCORETZ_USCOREDay *)ptr);
		break;
	case SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult:
		soap_serialize__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, (const struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__tsf_USCOREupdateResponse:
		soap_serialize__ns1__tsf_USCOREupdateResponse(soap, (const struct _ns1__tsf_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__tsf_USCOREupdate:
		soap_serialize__ns1__tsf_USCOREupdate(soap, (const struct _ns1__tsf_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult:
		soap_serialize__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, (const struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__wsh_USCOREupdateResponse:
		soap_serialize__ns1__wsh_USCOREupdateResponse(soap, (const struct _ns1__wsh_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__wsh_USCOREupdate:
		soap_serialize__ns1__wsh_USCOREupdate(soap, (const struct _ns1__wsh_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult:
		soap_serialize__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, (const struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse:
		soap_serialize__ns1__get_USCOREzb_USCOREmxResponse(soap, (const struct _ns1__get_USCOREzb_USCOREmxResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREzb_USCOREmx:
		soap_serialize__ns1__get_USCOREzb_USCOREmx(soap, (const struct _ns1__get_USCOREzb_USCOREmx *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult:
		soap_serialize__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, (const struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREwshResponse:
		soap_serialize__ns1__get_USCOREwshResponse(soap, (const struct _ns1__get_USCOREwshResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREwsh:
		soap_serialize__ns1__get_USCOREwsh(soap, (const struct _ns1__get_USCOREwsh *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend:
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, (const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult:
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, (const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse:
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, (const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate:
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdate(soap, (const struct _ns1__hbtsf_USCOREyue_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult:
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, (const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse:
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, (const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate:
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdate(soap, (const struct _ns1__hbwsh_USCOREyue_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult:
		soap_serialize__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, (const struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyueResponse:
		soap_serialize__ns1__get_USCOREyueResponse(soap, (const struct _ns1__get_USCOREyueResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyue:
		soap_serialize__ns1__get_USCOREyue(soap, (const struct _ns1__get_USCOREyue *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult:
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, (const struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse:
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, (const struct _ns1__get_USCOREhbwsh_USCOREyueResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue:
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyue(soap, (const struct _ns1__get_USCOREhbwsh_USCOREyue *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult:
		soap_serialize__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, (const struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzdResponse:
		soap_serialize__ns1__get_USCOREyyzdResponse(soap, (const struct _ns1__get_USCOREyyzdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREyyzd:
		soap_serialize__ns1__get_USCOREyyzd(soap, (const struct _ns1__get_USCOREyyzd *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult:
		soap_serialize__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, (const struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfpResponse:
		soap_serialize__ns1__get_USCOREhbfpResponse(soap, (const struct _ns1__get_USCOREhbfpResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbfp:
		soap_serialize__ns1__get_USCOREhbfp(soap, (const struct _ns1__get_USCOREhbfp *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult:
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse:
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, (const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult:
		soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, (const struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse:
		soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse(soap, (const struct _ns1__m_USCOREtz_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate:
		soap_serialize__ns1__m_USCOREtz_USCOREupdate(soap, (const struct _ns1__m_USCOREtz_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult:
		soap_serialize__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, (const struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREMonthResponse:
		soap_serialize__ns1__TZ_USCOREMonthResponse(soap, (const struct _ns1__TZ_USCOREMonthResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREMonth:
		soap_serialize__ns1__TZ_USCOREMonth(soap, (const struct _ns1__TZ_USCOREMonth *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult:
		soap_serialize__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, (const struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDayResponse:
		soap_serialize__ns1__TZ_USCOREDayResponse(soap, (const struct _ns1__TZ_USCOREDayResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__TZ_USCOREDay:
		soap_serialize__ns1__TZ_USCOREDay(soap, (const struct _ns1__TZ_USCOREDay *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult:
		soap_serialize__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, (const struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse:
		soap_serialize__ns1__hbtsf_USCOREupdateResponse(soap, (const struct _ns1__hbtsf_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__hbtsf_USCOREupdate:
		soap_serialize__ns1__hbtsf_USCOREupdate(soap, (const struct _ns1__hbtsf_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult:
		soap_serialize__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, (const struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse:
		soap_serialize__ns1__hbwsh_USCOREupdateResponse(soap, (const struct _ns1__hbwsh_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__hbwsh_USCOREupdate:
		soap_serialize__ns1__hbwsh_USCOREupdate(soap, (const struct _ns1__hbwsh_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult:
		soap_serialize__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, (const struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmxResponse:
		soap_serialize__ns1__get_USCOREmxResponse(soap, (const struct _ns1__get_USCOREmxResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREmx:
		soap_serialize__ns1__get_USCOREmx(soap, (const struct _ns1__get_USCOREmx *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult:
		soap_serialize__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, (const struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwshResponse:
		soap_serialize__ns1__get_USCOREhbwshResponse(soap, (const struct _ns1__get_USCOREhbwshResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbwsh:
		soap_serialize__ns1__get_USCOREhbwsh(soap, (const struct _ns1__get_USCOREhbwsh *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult:
		soap_serialize__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, (const struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgsResponse:
		soap_serialize__ns1__get_USCOREhbgsResponse(soap, (const struct _ns1__get_USCOREhbgsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__get_USCOREhbgs:
		soap_serialize__ns1__get_USCOREhbgs(soap, (const struct _ns1__get_USCOREhbgs *)ptr);
		break;
	case SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result:
		soap_serialize__ns1__FromBASE64Response_FromBASE64Result(soap, (const struct _ns1__FromBASE64Response_FromBASE64Result *)ptr);
		break;
	case SOAP_TYPE__ns1__FromBASE64Response:
		soap_serialize__ns1__FromBASE64Response(soap, (const struct _ns1__FromBASE64Response *)ptr);
		break;
	case SOAP_TYPE__ns1__FromBASE64:
		soap_serialize__ns1__FromBASE64(soap, (const struct _ns1__FromBASE64 *)ptr);
		break;
	case SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result:
		soap_serialize__ns1__ToBASE64Response_ToBASE64Result(soap, (const struct _ns1__ToBASE64Response_ToBASE64Result *)ptr);
		break;
	case SOAP_TYPE__ns1__ToBASE64Response:
		soap_serialize__ns1__ToBASE64Response(soap, (const struct _ns1__ToBASE64Response *)ptr);
		break;
	case SOAP_TYPE__ns1__ToBASE64:
		soap_serialize__ns1__ToBASE64(soap, (const struct _ns1__ToBASE64 *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result:
		soap_serialize__ns1__CheckSHA1Response_CheckSHA1Result(soap, (const struct _ns1__CheckSHA1Response_CheckSHA1Result *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckSHA1Response:
		soap_serialize__ns1__CheckSHA1Response(soap, (const struct _ns1__CheckSHA1Response *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckSHA1:
		soap_serialize__ns1__CheckSHA1(soap, (const struct _ns1__CheckSHA1 *)ptr);
		break;
	case SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult:
		soap_serialize__ns1__GetHostInfoResponse_GetHostInfoResult(soap, (const struct _ns1__GetHostInfoResponse_GetHostInfoResult *)ptr);
		break;
	case SOAP_TYPE__ns1__GetHostInfoResponse:
		soap_serialize__ns1__GetHostInfoResponse(soap, (const struct _ns1__GetHostInfoResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetHostInfo:
		soap_serialize__ns1__GetHostInfo(soap, (const struct _ns1__GetHostInfo *)ptr);
		break;
	case SOAP_TYPE__ns1__GetDNSResponse:
		soap_serialize__ns1__GetDNSResponse(soap, (const struct _ns1__GetDNSResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetDNS:
		soap_serialize__ns1__GetDNS(soap, (const struct _ns1__GetDNS *)ptr);
		break;
	case SOAP_TYPE__ns1__GetTimeResponse:
		soap_serialize__ns1__GetTimeResponse(soap, (const struct _ns1__GetTimeResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetTime:
		soap_serialize__ns1__GetTime(soap, (const struct _ns1__GetTime *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(soap, (struct _ns1__m_USCOREtz_USCOREupdate1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, (struct _ns1__m_USCOREtz_USCOREupdate1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response:
		soap_serialize_PointerTo_ns1__TZ_USCOREDay1Response(soap, (struct _ns1__TZ_USCOREDay1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1:
		soap_serialize_PointerTo_ns1__TZ_USCOREDay1(soap, (struct _ns1__TZ_USCOREDay1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response:
		soap_serialize_PointerTo_ns1__get_USCOREyue1Response(soap, (struct _ns1__get_USCOREyue1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1:
		soap_serialize_PointerTo_ns1__get_USCOREyue1(soap, (struct _ns1__get_USCOREyue1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response:
		soap_serialize_PointerTo_ns1__get_USCOREyyzd1Response(soap, (struct _ns1__get_USCOREyyzd1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1:
		soap_serialize_PointerTo_ns1__get_USCOREyyzd1(soap, (struct _ns1__get_USCOREyyzd1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response:
		soap_serialize_PointerTo_ns1__get_USCOREhbfp1Response(soap, (struct _ns1__get_USCOREhbfp1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1:
		soap_serialize_PointerTo_ns1__get_USCOREhbfp1(soap, (struct _ns1__get_USCOREhbfp1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1Response(soap, (struct _ns1__hbtsf_USCOREupdate1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1(soap, (struct _ns1__hbtsf_USCOREupdate1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1Response(soap, (struct _ns1__hbwsh_USCOREupdate1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1(soap, (struct _ns1__hbwsh_USCOREupdate1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response:
		soap_serialize_PointerTo_ns1__get_USCOREmx1Response(soap, (struct _ns1__get_USCOREmx1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1:
		soap_serialize_PointerTo_ns1__get_USCOREmx1(soap, (struct _ns1__get_USCOREmx1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh1Response(soap, (struct _ns1__get_USCOREhbwsh1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh1(soap, (struct _ns1__get_USCOREhbwsh1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response:
		soap_serialize_PointerTo_ns1__get_USCOREhbgs1Response(soap, (struct _ns1__get_USCOREhbgs1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1:
		soap_serialize_PointerTo_ns1__get_USCOREhbgs1(soap, (struct _ns1__get_USCOREhbgs1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse:
		soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(soap, (struct _ns1__fp_USCOREdy_USCOREendResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREend:
		soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, (struct _ns1__fp_USCOREdy_USCOREend *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse:
		soap_serialize_PointerTo_ns1__get_USCOREzbfpResponse(soap, (struct _ns1__get_USCOREzbfpResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfp:
		soap_serialize_PointerTo_ns1__get_USCOREzbfp(soap, (struct _ns1__get_USCOREzbfp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(soap, (struct _ns1__ZB_USCORETZ_USCOREMonthResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonth:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, (struct _ns1__ZB_USCORETZ_USCOREMonth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(soap, (struct _ns1__ZB_USCORETZ_USCOREDayResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDay:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, (struct _ns1__ZB_USCORETZ_USCOREDay *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__tsf_USCOREupdateResponse(soap, (struct _ns1__tsf_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdate:
		soap_serialize_PointerTo_ns1__tsf_USCOREupdate(soap, (struct _ns1__tsf_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__wsh_USCOREupdateResponse(soap, (struct _ns1__wsh_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdate:
		soap_serialize_PointerTo_ns1__wsh_USCOREupdate(soap, (struct _ns1__wsh_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse:
		soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(soap, (struct _ns1__get_USCOREzb_USCOREmxResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmx:
		soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, (struct _ns1__get_USCOREzb_USCOREmx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse:
		soap_serialize_PointerTo_ns1__get_USCOREwshResponse(soap, (struct _ns1__get_USCOREwshResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwsh:
		soap_serialize_PointerTo_ns1__get_USCOREwsh(soap, (struct _ns1__get_USCOREwsh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, (struct _ns1__hbtsf_USCOREyue_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, (struct _ns1__hbwsh_USCOREyue_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse:
		soap_serialize_PointerTo_ns1__get_USCOREyueResponse(soap, (struct _ns1__get_USCOREyueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue:
		soap_serialize_PointerTo_ns1__get_USCOREyue(soap, (struct _ns1__get_USCOREyue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(soap, (struct _ns1__get_USCOREhbwsh_USCOREyueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyue:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, (struct _ns1__get_USCOREhbwsh_USCOREyue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse:
		soap_serialize_PointerTo_ns1__get_USCOREyyzdResponse(soap, (struct _ns1__get_USCOREyyzdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd:
		soap_serialize_PointerTo_ns1__get_USCOREyyzd(soap, (struct _ns1__get_USCOREyyzd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse:
		soap_serialize_PointerTo_ns1__get_USCOREhbfpResponse(soap, (struct _ns1__get_USCOREhbfpResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp:
		soap_serialize_PointerTo_ns1__get_USCOREhbfp(soap, (struct _ns1__get_USCOREhbfp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate:
		soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(soap, (struct _ns1__m_USCOREtz_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, (struct _ns1__m_USCOREtz_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse:
		soap_serialize_PointerTo_ns1__TZ_USCOREMonthResponse(soap, (struct _ns1__TZ_USCOREMonthResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonth:
		soap_serialize_PointerTo_ns1__TZ_USCOREMonth(soap, (struct _ns1__TZ_USCOREMonth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse:
		soap_serialize_PointerTo_ns1__TZ_USCOREDayResponse(soap, (struct _ns1__TZ_USCOREDayResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay:
		soap_serialize_PointerTo_ns1__TZ_USCOREDay(soap, (struct _ns1__TZ_USCOREDay *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdateResponse(soap, (struct _ns1__hbtsf_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate(soap, (struct _ns1__hbtsf_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdateResponse(soap, (struct _ns1__hbwsh_USCOREupdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate(soap, (struct _ns1__hbwsh_USCOREupdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse:
		soap_serialize_PointerTo_ns1__get_USCOREmxResponse(soap, (struct _ns1__get_USCOREmxResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx:
		soap_serialize_PointerTo_ns1__get_USCOREmx(soap, (struct _ns1__get_USCOREmx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse:
		soap_serialize_PointerTo_ns1__get_USCOREhbwshResponse(soap, (struct _ns1__get_USCOREhbwshResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh(soap, (struct _ns1__get_USCOREhbwsh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse:
		soap_serialize_PointerTo_ns1__get_USCOREhbgsResponse(soap, (struct _ns1__get_USCOREhbgsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs:
		soap_serialize_PointerTo_ns1__get_USCOREhbgs(soap, (struct _ns1__get_USCOREhbgs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response:
		soap_serialize_PointerTo_ns1__FromBASE64Response(soap, (struct _ns1__FromBASE64Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FromBASE64:
		soap_serialize_PointerTo_ns1__FromBASE64(soap, (struct _ns1__FromBASE64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response:
		soap_serialize_PointerTo_ns1__ToBASE64Response(soap, (struct _ns1__ToBASE64Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ToBASE64:
		soap_serialize_PointerTo_ns1__ToBASE64(soap, (struct _ns1__ToBASE64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response:
		soap_serialize_PointerTo_ns1__CheckSHA1Response(soap, (struct _ns1__CheckSHA1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1:
		soap_serialize_PointerTo_ns1__CheckSHA1(soap, (struct _ns1__CheckSHA1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse:
		soap_serialize_PointerTo_ns1__GetHostInfoResponse(soap, (struct _ns1__GetHostInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHostInfo:
		soap_serialize_PointerTo_ns1__GetHostInfo(soap, (struct _ns1__GetHostInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDNSResponse:
		soap_serialize_PointerTo_ns1__GetDNSResponse(soap, (struct _ns1__GetDNSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDNS:
		soap_serialize_PointerTo_ns1__GetDNS(soap, (struct _ns1__GetDNS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTimeResponse:
		soap_serialize_PointerTo_ns1__GetTimeResponse(soap, (struct _ns1__GetTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTime:
		soap_serialize_PointerTo_ns1__GetTime(soap, (struct _ns1__GetTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result:
		soap_serialize_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result:
		soap_serialize_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result:
		soap_serialize_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result:
		soap_serialize_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result:
		soap_serialize_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result:
		soap_serialize_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult:
		soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult:
		soap_serialize_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult:
		soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult:
		soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult:
		soap_serialize_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult:
		soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult:
		soap_serialize_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult:
		soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult:
		soap_serialize_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult:
		soap_serialize_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult:
		soap_serialize_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult:
		soap_serialize_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult:
		soap_serialize_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult:
		soap_serialize_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult:
		soap_serialize_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult:
		soap_serialize_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FromBASE64Response_FromBASE64Result:
		soap_serialize_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, (struct _ns1__FromBASE64Response_FromBASE64Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ToBASE64Response_ToBASE64Result:
		soap_serialize_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, (struct _ns1__ToBASE64Response_ToBASE64Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result:
		soap_serialize_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, (struct _ns1__CheckSHA1Response_CheckSHA1Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult:
		soap_serialize_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, (struct _ns1__GetHostInfoResponse_GetHostInfoResult *const*)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREtz_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, &a->ns1__m_USCOREtz_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREtz_USCOREupdate1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, "ns1:m_tz_update1", -1, &a->ns1__m_USCOREtz_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate1_ * SOAP_FMAC4 soap_in___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, const char *tag, struct __ns1__m_USCOREtz_USCOREupdate1_ *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREtz_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREtz_USCOREupdate1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate1_, sizeof(struct __ns1__m_USCOREtz_USCOREupdate1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREtz_USCOREupdate1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREtz_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, "ns1:m_tz_update1", &a->ns1__m_USCOREtz_USCOREupdate1, ""))
				{	soap_flag_ns1__m_USCOREtz_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREtz_USCOREupdate1_(soap, tag?tag:"-ns1:m_tz_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate1_ * SOAP_FMAC4 soap_get___ns1__m_USCOREtz_USCOREupdate1_(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREtz_USCOREupdate1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREDay1_(struct soap *soap, struct __ns1__TZ_USCOREDay1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREDay1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREDay1_(struct soap *soap, const struct __ns1__TZ_USCOREDay1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDay1(soap, &a->ns1__TZ_USCOREDay1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREDay1_(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREDay1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1(soap, "ns1:TZ_Day1", -1, &a->ns1__TZ_USCOREDay1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay1_ * SOAP_FMAC4 soap_in___ns1__TZ_USCOREDay1_(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREDay1_ *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREDay1 = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREDay1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREDay1_, sizeof(struct __ns1__TZ_USCOREDay1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREDay1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDay1(soap, "ns1:TZ_Day1", &a->ns1__TZ_USCOREDay1, ""))
				{	soap_flag_ns1__TZ_USCOREDay1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREDay1_(struct soap *soap, const struct __ns1__TZ_USCOREDay1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREDay1_(soap, tag?tag:"-ns1:TZ_Day1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay1_ * SOAP_FMAC4 soap_get___ns1__TZ_USCOREDay1_(struct soap *soap, struct __ns1__TZ_USCOREDay1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREDay1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hb_USCOREfp_USCOREdy_USCOREend1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, const char *tag, int id, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, "ns1:hb_fp_dy_end1", -1, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ * SOAP_FMAC4 soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, const char *tag, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *a, const char *type)
{
	size_t soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1 = 1;
	short soap_flag;
	a = (struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend1_, sizeof(struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, "ns1:hb_fp_dy_end1", &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1, ""))
				{	soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(soap, tag?tag:"-ns1:hb_fp_dy_end1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ * SOAP_FMAC4 soap_get___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyue1_(struct soap *soap, struct __ns1__get_USCOREyue1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyue1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyue1_(struct soap *soap, const struct __ns1__get_USCOREyue1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyue1(soap, &a->ns1__get_USCOREyue1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyue1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyue1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyue1(soap, "ns1:get_yue1", -1, &a->ns1__get_USCOREyue1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREyue1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREyue1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyue1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyue1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyue1_, sizeof(struct __ns1__get_USCOREyue1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyue1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyue1(soap, "ns1:get_yue1", &a->ns1__get_USCOREyue1, ""))
				{	soap_flag_ns1__get_USCOREyue1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyue1_(struct soap *soap, const struct __ns1__get_USCOREyue1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyue1_(soap, tag?tag:"-ns1:get_yue1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREyue1_(struct soap *soap, struct __ns1__get_USCOREyue1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyue1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyyzd1_(struct soap *soap, struct __ns1__get_USCOREyyzd1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyyzd1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyyzd1_(struct soap *soap, const struct __ns1__get_USCOREyyzd1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzd1(soap, &a->ns1__get_USCOREyyzd1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyyzd1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyyzd1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1(soap, "ns1:get_yyzd1", -1, &a->ns1__get_USCOREyyzd1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREyyzd1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREyyzd1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyyzd1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyyzd1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyyzd1_, sizeof(struct __ns1__get_USCOREyyzd1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyyzd1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyyzd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzd1(soap, "ns1:get_yyzd1", &a->ns1__get_USCOREyyzd1, ""))
				{	soap_flag_ns1__get_USCOREyyzd1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyyzd1_(struct soap *soap, const struct __ns1__get_USCOREyyzd1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyyzd1_(soap, tag?tag:"-ns1:get_yyzd1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREyyzd1_(struct soap *soap, struct __ns1__get_USCOREyyzd1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyyzd1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbfp1_(struct soap *soap, struct __ns1__get_USCOREhbfp1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbfp1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbfp1_(struct soap *soap, const struct __ns1__get_USCOREhbfp1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfp1(soap, &a->ns1__get_USCOREhbfp1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbfp1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbfp1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1(soap, "ns1:get_hbfp1", -1, &a->ns1__get_USCOREhbfp1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbfp1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbfp1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbfp1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbfp1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbfp1_, sizeof(struct __ns1__get_USCOREhbfp1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbfp1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbfp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfp1(soap, "ns1:get_hbfp1", &a->ns1__get_USCOREhbfp1, ""))
				{	soap_flag_ns1__get_USCOREhbfp1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbfp1_(struct soap *soap, const struct __ns1__get_USCOREhbfp1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbfp1_(soap, tag?tag:"-ns1:get_hbfp1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbfp1_(struct soap *soap, struct __ns1__get_USCOREhbfp1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbfp1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREupdate1_(struct soap *soap, struct __ns1__hbtsf_USCOREupdate1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREupdate1_(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1(soap, &a->ns1__hbtsf_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREupdate1_(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREupdate1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1(soap, "ns1:hbtsf_update1", -1, &a->ns1__hbtsf_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate1_ * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREupdate1_(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREupdate1_ *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREupdate1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREupdate1_, sizeof(struct __ns1__hbtsf_USCOREupdate1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREupdate1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdate1(soap, "ns1:hbtsf_update1", &a->ns1__hbtsf_USCOREupdate1, ""))
				{	soap_flag_ns1__hbtsf_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREupdate1_(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREupdate1_(soap, tag?tag:"-ns1:hbtsf_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate1_ * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREupdate1_(struct soap *soap, struct __ns1__hbtsf_USCOREupdate1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREupdate1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREupdate1_(struct soap *soap, struct __ns1__hbwsh_USCOREupdate1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREupdate1_(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1(soap, &a->ns1__hbwsh_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREupdate1_(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREupdate1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1(soap, "ns1:hbwsh_update1", -1, &a->ns1__hbwsh_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate1_ * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREupdate1_(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREupdate1_ *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREupdate1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREupdate1_, sizeof(struct __ns1__hbwsh_USCOREupdate1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREupdate1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdate1(soap, "ns1:hbwsh_update1", &a->ns1__hbwsh_USCOREupdate1, ""))
				{	soap_flag_ns1__hbwsh_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREupdate1_(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREupdate1_(soap, tag?tag:"-ns1:hbwsh_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate1_ * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREupdate1_(struct soap *soap, struct __ns1__hbwsh_USCOREupdate1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREupdate1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREmx1_(struct soap *soap, struct __ns1__get_USCOREmx1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREmx1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREmx1_(struct soap *soap, const struct __ns1__get_USCOREmx1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmx1(soap, &a->ns1__get_USCOREmx1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREmx1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREmx1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREmx1(soap, "ns1:get_mx1", -1, &a->ns1__get_USCOREmx1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREmx1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREmx1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREmx1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREmx1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREmx1_, sizeof(struct __ns1__get_USCOREmx1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREmx1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREmx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmx1(soap, "ns1:get_mx1", &a->ns1__get_USCOREmx1, ""))
				{	soap_flag_ns1__get_USCOREmx1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREmx1_(struct soap *soap, const struct __ns1__get_USCOREmx1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREmx1_(soap, tag?tag:"-ns1:get_mx1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREmx1_(struct soap *soap, struct __ns1__get_USCOREmx1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREmx1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh1_(struct soap *soap, struct __ns1__get_USCOREhbwsh1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh1_(struct soap *soap, const struct __ns1__get_USCOREhbwsh1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh1(soap, &a->ns1__get_USCOREhbwsh1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1(soap, "ns1:get_hbwsh1", -1, &a->ns1__get_USCOREhbwsh1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh1_, sizeof(struct __ns1__get_USCOREhbwsh1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh1(soap, "ns1:get_hbwsh1", &a->ns1__get_USCOREhbwsh1, ""))
				{	soap_flag_ns1__get_USCOREhbwsh1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh1_(struct soap *soap, const struct __ns1__get_USCOREhbwsh1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh1_(soap, tag?tag:"-ns1:get_hbwsh1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh1_(struct soap *soap, struct __ns1__get_USCOREhbwsh1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbgs1_(struct soap *soap, struct __ns1__get_USCOREhbgs1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbgs1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbgs1_(struct soap *soap, const struct __ns1__get_USCOREhbgs1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgs1(soap, &a->ns1__get_USCOREhbgs1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbgs1_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbgs1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1(soap, "ns1:get_hbgs1", -1, &a->ns1__get_USCOREhbgs1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs1_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbgs1_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbgs1_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbgs1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbgs1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbgs1_, sizeof(struct __ns1__get_USCOREhbgs1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbgs1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbgs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgs1(soap, "ns1:get_hbgs1", &a->ns1__get_USCOREhbgs1, ""))
				{	soap_flag_ns1__get_USCOREhbgs1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbgs1_(struct soap *soap, const struct __ns1__get_USCOREhbgs1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbgs1_(soap, tag?tag:"-ns1:get_hbgs1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs1_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbgs1_(struct soap *soap, struct __ns1__get_USCOREhbgs1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbgs1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, struct __ns1__fp_USCOREdy_USCOREend_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fp_USCOREdy_USCOREend = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, const struct __ns1__fp_USCOREdy_USCOREend_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, &a->ns1__fp_USCOREdy_USCOREend);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, const char *tag, int id, const struct __ns1__fp_USCOREdy_USCOREend_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, "ns1:fp_dy_end", -1, &a->ns1__fp_USCOREdy_USCOREend, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fp_USCOREdy_USCOREend_ * SOAP_FMAC4 soap_in___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, const char *tag, struct __ns1__fp_USCOREdy_USCOREend_ *a, const char *type)
{
	size_t soap_flag_ns1__fp_USCOREdy_USCOREend = 1;
	short soap_flag;
	a = (struct __ns1__fp_USCOREdy_USCOREend_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fp_USCOREdy_USCOREend_, sizeof(struct __ns1__fp_USCOREdy_USCOREend_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fp_USCOREdy_USCOREend_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fp_USCOREdy_USCOREend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, "ns1:fp_dy_end", &a->ns1__fp_USCOREdy_USCOREend, ""))
				{	soap_flag_ns1__fp_USCOREdy_USCOREend--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, const struct __ns1__fp_USCOREdy_USCOREend_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fp_USCOREdy_USCOREend_(soap, tag?tag:"-ns1:fp_dy_end", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fp_USCOREdy_USCOREend_ * SOAP_FMAC4 soap_get___ns1__fp_USCOREdy_USCOREend_(struct soap *soap, struct __ns1__fp_USCOREdy_USCOREend_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fp_USCOREdy_USCOREend_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREzbfp_(struct soap *soap, struct __ns1__get_USCOREzbfp_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREzbfp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREzbfp_(struct soap *soap, const struct __ns1__get_USCOREzbfp_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzbfp(soap, &a->ns1__get_USCOREzbfp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREzbfp_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREzbfp_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREzbfp(soap, "ns1:get_zbfp", -1, &a->ns1__get_USCOREzbfp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzbfp_ * SOAP_FMAC4 soap_in___ns1__get_USCOREzbfp_(struct soap *soap, const char *tag, struct __ns1__get_USCOREzbfp_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREzbfp = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREzbfp_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREzbfp_, sizeof(struct __ns1__get_USCOREzbfp_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREzbfp_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREzbfp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzbfp(soap, "ns1:get_zbfp", &a->ns1__get_USCOREzbfp, ""))
				{	soap_flag_ns1__get_USCOREzbfp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREzbfp_(struct soap *soap, const struct __ns1__get_USCOREzbfp_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREzbfp_(soap, tag?tag:"-ns1:get_zbfp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzbfp_ * SOAP_FMAC4 soap_get___ns1__get_USCOREzbfp_(struct soap *soap, struct __ns1__get_USCOREzbfp_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREzbfp_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREMonth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ZB_USCORETZ_USCOREMonth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREMonth_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, &a->ns1__ZB_USCORETZ_USCOREMonth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, const char *tag, int id, const struct __ns1__ZB_USCORETZ_USCOREMonth_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, "ns1:ZB_TZ_Month", -1, &a->ns1__ZB_USCORETZ_USCOREMonth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREMonth_ * SOAP_FMAC4 soap_in___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, const char *tag, struct __ns1__ZB_USCORETZ_USCOREMonth_ *a, const char *type)
{
	size_t soap_flag_ns1__ZB_USCORETZ_USCOREMonth = 1;
	short soap_flag;
	a = (struct __ns1__ZB_USCORETZ_USCOREMonth_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ZB_USCORETZ_USCOREMonth_, sizeof(struct __ns1__ZB_USCORETZ_USCOREMonth_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ZB_USCORETZ_USCOREMonth_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ZB_USCORETZ_USCOREMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, "ns1:ZB_TZ_Month", &a->ns1__ZB_USCORETZ_USCOREMonth, ""))
				{	soap_flag_ns1__ZB_USCORETZ_USCOREMonth--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREMonth_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ZB_USCORETZ_USCOREMonth_(soap, tag?tag:"-ns1:ZB_TZ_Month", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREMonth_ * SOAP_FMAC4 soap_get___ns1__ZB_USCORETZ_USCOREMonth_(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREMonth_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ZB_USCORETZ_USCOREMonth_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREDay_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ZB_USCORETZ_USCOREDay = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREDay_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, &a->ns1__ZB_USCORETZ_USCOREDay);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, const char *tag, int id, const struct __ns1__ZB_USCORETZ_USCOREDay_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, "ns1:ZB_TZ_Day", -1, &a->ns1__ZB_USCORETZ_USCOREDay, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREDay_ * SOAP_FMAC4 soap_in___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, const char *tag, struct __ns1__ZB_USCORETZ_USCOREDay_ *a, const char *type)
{
	size_t soap_flag_ns1__ZB_USCORETZ_USCOREDay = 1;
	short soap_flag;
	a = (struct __ns1__ZB_USCORETZ_USCOREDay_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ZB_USCORETZ_USCOREDay_, sizeof(struct __ns1__ZB_USCORETZ_USCOREDay_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ZB_USCORETZ_USCOREDay_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ZB_USCORETZ_USCOREDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, "ns1:ZB_TZ_Day", &a->ns1__ZB_USCORETZ_USCOREDay, ""))
				{	soap_flag_ns1__ZB_USCORETZ_USCOREDay--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREDay_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ZB_USCORETZ_USCOREDay_(soap, tag?tag:"-ns1:ZB_TZ_Day", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREDay_ * SOAP_FMAC4 soap_get___ns1__ZB_USCORETZ_USCOREDay_(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREDay_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ZB_USCORETZ_USCOREDay_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__tsf_USCOREupdate_(struct soap *soap, struct __ns1__tsf_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__tsf_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__tsf_USCOREupdate_(struct soap *soap, const struct __ns1__tsf_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__tsf_USCOREupdate(soap, &a->ns1__tsf_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__tsf_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__tsf_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__tsf_USCOREupdate(soap, "ns1:tsf_update", -1, &a->ns1__tsf_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__tsf_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__tsf_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__tsf_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__tsf_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__tsf_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__tsf_USCOREupdate_, sizeof(struct __ns1__tsf_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__tsf_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__tsf_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__tsf_USCOREupdate(soap, "ns1:tsf_update", &a->ns1__tsf_USCOREupdate, ""))
				{	soap_flag_ns1__tsf_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__tsf_USCOREupdate_(struct soap *soap, const struct __ns1__tsf_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__tsf_USCOREupdate_(soap, tag?tag:"-ns1:tsf_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__tsf_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__tsf_USCOREupdate_(struct soap *soap, struct __ns1__tsf_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__tsf_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wsh_USCOREupdate_(struct soap *soap, struct __ns1__wsh_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wsh_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wsh_USCOREupdate_(struct soap *soap, const struct __ns1__wsh_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__wsh_USCOREupdate(soap, &a->ns1__wsh_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wsh_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__wsh_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__wsh_USCOREupdate(soap, "ns1:wsh_update", -1, &a->ns1__wsh_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wsh_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__wsh_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__wsh_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__wsh_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__wsh_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wsh_USCOREupdate_, sizeof(struct __ns1__wsh_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wsh_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wsh_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__wsh_USCOREupdate(soap, "ns1:wsh_update", &a->ns1__wsh_USCOREupdate, ""))
				{	soap_flag_ns1__wsh_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wsh_USCOREupdate_(struct soap *soap, const struct __ns1__wsh_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wsh_USCOREupdate_(soap, tag?tag:"-ns1:wsh_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wsh_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__wsh_USCOREupdate_(struct soap *soap, struct __ns1__wsh_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wsh_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, struct __ns1__get_USCOREzb_USCOREmx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREzb_USCOREmx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, const struct __ns1__get_USCOREzb_USCOREmx_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, &a->ns1__get_USCOREzb_USCOREmx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREzb_USCOREmx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, "ns1:get_zb_mx", -1, &a->ns1__get_USCOREzb_USCOREmx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzb_USCOREmx_ * SOAP_FMAC4 soap_in___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, const char *tag, struct __ns1__get_USCOREzb_USCOREmx_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREzb_USCOREmx = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREzb_USCOREmx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREzb_USCOREmx_, sizeof(struct __ns1__get_USCOREzb_USCOREmx_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREzb_USCOREmx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREzb_USCOREmx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, "ns1:get_zb_mx", &a->ns1__get_USCOREzb_USCOREmx, ""))
				{	soap_flag_ns1__get_USCOREzb_USCOREmx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, const struct __ns1__get_USCOREzb_USCOREmx_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREzb_USCOREmx_(soap, tag?tag:"-ns1:get_zb_mx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzb_USCOREmx_ * SOAP_FMAC4 soap_get___ns1__get_USCOREzb_USCOREmx_(struct soap *soap, struct __ns1__get_USCOREzb_USCOREmx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREzb_USCOREmx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREwsh_(struct soap *soap, struct __ns1__get_USCOREwsh_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREwsh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREwsh_(struct soap *soap, const struct __ns1__get_USCOREwsh_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREwsh(soap, &a->ns1__get_USCOREwsh);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREwsh_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREwsh_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREwsh(soap, "ns1:get_wsh", -1, &a->ns1__get_USCOREwsh, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREwsh_ * SOAP_FMAC4 soap_in___ns1__get_USCOREwsh_(struct soap *soap, const char *tag, struct __ns1__get_USCOREwsh_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREwsh = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREwsh_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREwsh_, sizeof(struct __ns1__get_USCOREwsh_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREwsh_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREwsh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREwsh(soap, "ns1:get_wsh", &a->ns1__get_USCOREwsh, ""))
				{	soap_flag_ns1__get_USCOREwsh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREwsh_(struct soap *soap, const struct __ns1__get_USCOREwsh_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREwsh_(soap, tag?tag:"-ns1:get_wsh", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREwsh_ * SOAP_FMAC4 soap_get___ns1__get_USCOREwsh_(struct soap *soap, struct __ns1__get_USCOREwsh_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREwsh_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hb_USCOREfp_USCOREdy_USCOREend = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, const char *tag, int id, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, "ns1:hb_fp_dy_end", -1, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ * SOAP_FMAC4 soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, const char *tag, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *a, const char *type)
{
	size_t soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend = 1;
	short soap_flag;
	a = (struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend_, sizeof(struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, "ns1:hb_fp_dy_end", &a->ns1__hb_USCOREfp_USCOREdy_USCOREend, ""))
				{	soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend_(soap, tag?tag:"-ns1:hb_fp_dy_end", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ * SOAP_FMAC4 soap_get___ns1__hb_USCOREfp_USCOREdy_USCOREend_(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREyue_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, const struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, &a->ns1__hbtsf_USCOREyue_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, "ns1:hbtsf_yue_update", -1, &a->ns1__hbtsf_USCOREyue_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREyue_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREyue_USCOREupdate_, sizeof(struct __ns1__hbtsf_USCOREyue_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREyue_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, "ns1:hbtsf_yue_update", &a->ns1__hbtsf_USCOREyue_USCOREupdate, ""))
				{	soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, const struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREyue_USCOREupdate_(soap, tag?tag:"-ns1:hbtsf_yue_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREyue_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREyue_USCOREupdate_(struct soap *soap, struct __ns1__hbtsf_USCOREyue_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREyue_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREyue_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, const struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, &a->ns1__hbwsh_USCOREyue_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, "ns1:hbwsh_yue_update", -1, &a->ns1__hbwsh_USCOREyue_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREyue_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREyue_USCOREupdate_, sizeof(struct __ns1__hbwsh_USCOREyue_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREyue_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, "ns1:hbwsh_yue_update", &a->ns1__hbwsh_USCOREyue_USCOREupdate, ""))
				{	soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, const struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREyue_USCOREupdate_(soap, tag?tag:"-ns1:hbwsh_yue_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREyue_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREyue_USCOREupdate_(struct soap *soap, struct __ns1__hbwsh_USCOREyue_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREyue_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyue_(struct soap *soap, struct __ns1__get_USCOREyue_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyue_(struct soap *soap, const struct __ns1__get_USCOREyue_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyue(soap, &a->ns1__get_USCOREyue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyue_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyue_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyue(soap, "ns1:get_yue", -1, &a->ns1__get_USCOREyue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue_ * SOAP_FMAC4 soap_in___ns1__get_USCOREyue_(struct soap *soap, const char *tag, struct __ns1__get_USCOREyue_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyue = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyue_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyue_, sizeof(struct __ns1__get_USCOREyue_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyue_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyue(soap, "ns1:get_yue", &a->ns1__get_USCOREyue, ""))
				{	soap_flag_ns1__get_USCOREyue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyue_(struct soap *soap, const struct __ns1__get_USCOREyue_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyue_(soap, tag?tag:"-ns1:get_yue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue_ * SOAP_FMAC4 soap_get___ns1__get_USCOREyue_(struct soap *soap, struct __ns1__get_USCOREyue_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyue_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, struct __ns1__get_USCOREhbwsh_USCOREyue_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh_USCOREyue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, const struct __ns1__get_USCOREhbwsh_USCOREyue_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, &a->ns1__get_USCOREhbwsh_USCOREyue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh_USCOREyue_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, "ns1:get_hbwsh_yue", -1, &a->ns1__get_USCOREhbwsh_USCOREyue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_USCOREyue_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh_USCOREyue_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh_USCOREyue = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh_USCOREyue_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh_USCOREyue_, sizeof(struct __ns1__get_USCOREhbwsh_USCOREyue_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh_USCOREyue_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh_USCOREyue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, "ns1:get_hbwsh_yue", &a->ns1__get_USCOREhbwsh_USCOREyue, ""))
				{	soap_flag_ns1__get_USCOREhbwsh_USCOREyue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, const struct __ns1__get_USCOREhbwsh_USCOREyue_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh_USCOREyue_(soap, tag?tag:"-ns1:get_hbwsh_yue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_USCOREyue_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh_USCOREyue_(struct soap *soap, struct __ns1__get_USCOREhbwsh_USCOREyue_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh_USCOREyue_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyyzd_(struct soap *soap, struct __ns1__get_USCOREyyzd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyyzd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyyzd_(struct soap *soap, const struct __ns1__get_USCOREyyzd_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzd(soap, &a->ns1__get_USCOREyyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyyzd_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyyzd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyyzd(soap, "ns1:get_yyzd", -1, &a->ns1__get_USCOREyyzd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd_ * SOAP_FMAC4 soap_in___ns1__get_USCOREyyzd_(struct soap *soap, const char *tag, struct __ns1__get_USCOREyyzd_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyyzd = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyyzd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyyzd_, sizeof(struct __ns1__get_USCOREyyzd_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyyzd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyyzd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzd(soap, "ns1:get_yyzd", &a->ns1__get_USCOREyyzd, ""))
				{	soap_flag_ns1__get_USCOREyyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyyzd_(struct soap *soap, const struct __ns1__get_USCOREyyzd_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyyzd_(soap, tag?tag:"-ns1:get_yyzd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd_ * SOAP_FMAC4 soap_get___ns1__get_USCOREyyzd_(struct soap *soap, struct __ns1__get_USCOREyyzd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyyzd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbfp_(struct soap *soap, struct __ns1__get_USCOREhbfp_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbfp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbfp_(struct soap *soap, const struct __ns1__get_USCOREhbfp_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfp(soap, &a->ns1__get_USCOREhbfp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbfp_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbfp_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbfp(soap, "ns1:get_hbfp", -1, &a->ns1__get_USCOREhbfp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbfp_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbfp_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbfp = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbfp_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbfp_, sizeof(struct __ns1__get_USCOREhbfp_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbfp_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbfp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfp(soap, "ns1:get_hbfp", &a->ns1__get_USCOREhbfp, ""))
				{	soap_flag_ns1__get_USCOREhbfp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbfp_(struct soap *soap, const struct __ns1__get_USCOREhbfp_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbfp_(soap, tag?tag:"-ns1:get_hbfp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbfp_(struct soap *soap, struct __ns1__get_USCOREhbfp_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbfp_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREzb_USCOREtz_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, "ns1:m_zb_tz_update", -1, &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREzb_USCOREtz_USCOREupdate_, sizeof(struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, "ns1:m_zb_tz_update", &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate, ""))
				{	soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(soap, tag?tag:"-ns1:m_zb_tz_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(struct soap *soap, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREzb_USCOREtz_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREtz_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, &a->ns1__m_USCOREtz_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREtz_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, "ns1:m_tz_update", -1, &a->ns1__m_USCOREtz_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__m_USCOREtz_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREtz_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREtz_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate_, sizeof(struct __ns1__m_USCOREtz_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREtz_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREtz_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, "ns1:m_tz_update", &a->ns1__m_USCOREtz_USCOREupdate, ""))
				{	soap_flag_ns1__m_USCOREtz_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREtz_USCOREupdate_(soap, tag?tag:"-ns1:m_tz_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__m_USCOREtz_USCOREupdate_(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREtz_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREMonth_(struct soap *soap, struct __ns1__TZ_USCOREMonth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREMonth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREMonth_(struct soap *soap, const struct __ns1__TZ_USCOREMonth_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREMonth(soap, &a->ns1__TZ_USCOREMonth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREMonth_(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREMonth_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREMonth(soap, "ns1:TZ_Month", -1, &a->ns1__TZ_USCOREMonth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREMonth_ * SOAP_FMAC4 soap_in___ns1__TZ_USCOREMonth_(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREMonth_ *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREMonth = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREMonth_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREMonth_, sizeof(struct __ns1__TZ_USCOREMonth_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREMonth_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREMonth(soap, "ns1:TZ_Month", &a->ns1__TZ_USCOREMonth, ""))
				{	soap_flag_ns1__TZ_USCOREMonth--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREMonth_(struct soap *soap, const struct __ns1__TZ_USCOREMonth_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREMonth_(soap, tag?tag:"-ns1:TZ_Month", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREMonth_ * SOAP_FMAC4 soap_get___ns1__TZ_USCOREMonth_(struct soap *soap, struct __ns1__TZ_USCOREMonth_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREMonth_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREDay_(struct soap *soap, struct __ns1__TZ_USCOREDay_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREDay = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREDay_(struct soap *soap, const struct __ns1__TZ_USCOREDay_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDay(soap, &a->ns1__TZ_USCOREDay);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREDay_(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREDay_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREDay(soap, "ns1:TZ_Day", -1, &a->ns1__TZ_USCOREDay, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay_ * SOAP_FMAC4 soap_in___ns1__TZ_USCOREDay_(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREDay_ *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREDay = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREDay_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREDay_, sizeof(struct __ns1__TZ_USCOREDay_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREDay_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDay(soap, "ns1:TZ_Day", &a->ns1__TZ_USCOREDay, ""))
				{	soap_flag_ns1__TZ_USCOREDay--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREDay_(struct soap *soap, const struct __ns1__TZ_USCOREDay_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREDay_(soap, tag?tag:"-ns1:TZ_Day", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay_ * SOAP_FMAC4 soap_get___ns1__TZ_USCOREDay_(struct soap *soap, struct __ns1__TZ_USCOREDay_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREDay_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREupdate_(struct soap *soap, struct __ns1__hbtsf_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREupdate_(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate(soap, &a->ns1__hbtsf_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate(soap, "ns1:hbtsf_update", -1, &a->ns1__hbtsf_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREupdate_, sizeof(struct __ns1__hbtsf_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdate(soap, "ns1:hbtsf_update", &a->ns1__hbtsf_USCOREupdate, ""))
				{	soap_flag_ns1__hbtsf_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREupdate_(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREupdate_(soap, tag?tag:"-ns1:hbtsf_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREupdate_(struct soap *soap, struct __ns1__hbtsf_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREupdate_(struct soap *soap, struct __ns1__hbwsh_USCOREupdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREupdate_(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate(soap, &a->ns1__hbwsh_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREupdate_(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREupdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate(soap, "ns1:hbwsh_update", -1, &a->ns1__hbwsh_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate_ * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREupdate_(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREupdate_ *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREupdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREupdate_, sizeof(struct __ns1__hbwsh_USCOREupdate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREupdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdate(soap, "ns1:hbwsh_update", &a->ns1__hbwsh_USCOREupdate, ""))
				{	soap_flag_ns1__hbwsh_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREupdate_(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREupdate_(soap, tag?tag:"-ns1:hbwsh_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate_ * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREupdate_(struct soap *soap, struct __ns1__hbwsh_USCOREupdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREupdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREmx_(struct soap *soap, struct __ns1__get_USCOREmx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREmx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREmx_(struct soap *soap, const struct __ns1__get_USCOREmx_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmx(soap, &a->ns1__get_USCOREmx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREmx_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREmx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREmx(soap, "ns1:get_mx", -1, &a->ns1__get_USCOREmx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx_ * SOAP_FMAC4 soap_in___ns1__get_USCOREmx_(struct soap *soap, const char *tag, struct __ns1__get_USCOREmx_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREmx = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREmx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREmx_, sizeof(struct __ns1__get_USCOREmx_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREmx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREmx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmx(soap, "ns1:get_mx", &a->ns1__get_USCOREmx, ""))
				{	soap_flag_ns1__get_USCOREmx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREmx_(struct soap *soap, const struct __ns1__get_USCOREmx_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREmx_(soap, tag?tag:"-ns1:get_mx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx_ * SOAP_FMAC4 soap_get___ns1__get_USCOREmx_(struct soap *soap, struct __ns1__get_USCOREmx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREmx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh_(struct soap *soap, struct __ns1__get_USCOREhbwsh_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh_(struct soap *soap, const struct __ns1__get_USCOREhbwsh_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh(soap, &a->ns1__get_USCOREhbwsh);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh(soap, "ns1:get_hbwsh", -1, &a->ns1__get_USCOREhbwsh, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh_, sizeof(struct __ns1__get_USCOREhbwsh_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh(soap, "ns1:get_hbwsh", &a->ns1__get_USCOREhbwsh, ""))
				{	soap_flag_ns1__get_USCOREhbwsh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh_(struct soap *soap, const struct __ns1__get_USCOREhbwsh_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh_(soap, tag?tag:"-ns1:get_hbwsh", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh_(struct soap *soap, struct __ns1__get_USCOREhbwsh_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbgs_(struct soap *soap, struct __ns1__get_USCOREhbgs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbgs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbgs_(struct soap *soap, const struct __ns1__get_USCOREhbgs_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgs(soap, &a->ns1__get_USCOREhbgs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbgs_(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbgs_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbgs(soap, "ns1:get_hbgs", -1, &a->ns1__get_USCOREhbgs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs_ * SOAP_FMAC4 soap_in___ns1__get_USCOREhbgs_(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbgs_ *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbgs = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbgs_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbgs_, sizeof(struct __ns1__get_USCOREhbgs_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbgs_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgs(soap, "ns1:get_hbgs", &a->ns1__get_USCOREhbgs, ""))
				{	soap_flag_ns1__get_USCOREhbgs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbgs_(struct soap *soap, const struct __ns1__get_USCOREhbgs_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbgs_(soap, tag?tag:"-ns1:get_hbgs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs_ * SOAP_FMAC4 soap_get___ns1__get_USCOREhbgs_(struct soap *soap, struct __ns1__get_USCOREhbgs_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbgs_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FromBASE64_(struct soap *soap, struct __ns1__FromBASE64_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FromBASE64 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FromBASE64_(struct soap *soap, const struct __ns1__FromBASE64_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__FromBASE64(soap, &a->ns1__FromBASE64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FromBASE64_(struct soap *soap, const char *tag, int id, const struct __ns1__FromBASE64_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__FromBASE64(soap, "ns1:FromBASE64", -1, &a->ns1__FromBASE64, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FromBASE64_ * SOAP_FMAC4 soap_in___ns1__FromBASE64_(struct soap *soap, const char *tag, struct __ns1__FromBASE64_ *a, const char *type)
{
	size_t soap_flag_ns1__FromBASE64 = 1;
	short soap_flag;
	a = (struct __ns1__FromBASE64_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FromBASE64_, sizeof(struct __ns1__FromBASE64_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FromBASE64_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FromBASE64 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FromBASE64(soap, "ns1:FromBASE64", &a->ns1__FromBASE64, ""))
				{	soap_flag_ns1__FromBASE64--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FromBASE64_(struct soap *soap, const struct __ns1__FromBASE64_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__FromBASE64_(soap, tag?tag:"-ns1:FromBASE64", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FromBASE64_ * SOAP_FMAC4 soap_get___ns1__FromBASE64_(struct soap *soap, struct __ns1__FromBASE64_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FromBASE64_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToBASE64_(struct soap *soap, struct __ns1__ToBASE64_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToBASE64 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToBASE64_(struct soap *soap, const struct __ns1__ToBASE64_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ToBASE64(soap, &a->ns1__ToBASE64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToBASE64_(struct soap *soap, const char *tag, int id, const struct __ns1__ToBASE64_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ToBASE64(soap, "ns1:ToBASE64", -1, &a->ns1__ToBASE64, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToBASE64_ * SOAP_FMAC4 soap_in___ns1__ToBASE64_(struct soap *soap, const char *tag, struct __ns1__ToBASE64_ *a, const char *type)
{
	size_t soap_flag_ns1__ToBASE64 = 1;
	short soap_flag;
	a = (struct __ns1__ToBASE64_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToBASE64_, sizeof(struct __ns1__ToBASE64_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToBASE64_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToBASE64 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ToBASE64(soap, "ns1:ToBASE64", &a->ns1__ToBASE64, ""))
				{	soap_flag_ns1__ToBASE64--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToBASE64_(struct soap *soap, const struct __ns1__ToBASE64_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ToBASE64_(soap, tag?tag:"-ns1:ToBASE64", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToBASE64_ * SOAP_FMAC4 soap_get___ns1__ToBASE64_(struct soap *soap, struct __ns1__ToBASE64_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToBASE64_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSHA1_(struct soap *soap, struct __ns1__CheckSHA1_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSHA1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSHA1_(struct soap *soap, const struct __ns1__CheckSHA1_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckSHA1(soap, &a->ns1__CheckSHA1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSHA1_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSHA1_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CheckSHA1(soap, "ns1:CheckSHA1", -1, &a->ns1__CheckSHA1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSHA1_ * SOAP_FMAC4 soap_in___ns1__CheckSHA1_(struct soap *soap, const char *tag, struct __ns1__CheckSHA1_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckSHA1 = 1;
	short soap_flag;
	a = (struct __ns1__CheckSHA1_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSHA1_, sizeof(struct __ns1__CheckSHA1_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSHA1_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSHA1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckSHA1(soap, "ns1:CheckSHA1", &a->ns1__CheckSHA1, ""))
				{	soap_flag_ns1__CheckSHA1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSHA1_(struct soap *soap, const struct __ns1__CheckSHA1_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckSHA1_(soap, tag?tag:"-ns1:CheckSHA1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSHA1_ * SOAP_FMAC4 soap_get___ns1__CheckSHA1_(struct soap *soap, struct __ns1__CheckSHA1_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSHA1_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHostInfo_(struct soap *soap, struct __ns1__GetHostInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHostInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHostInfo_(struct soap *soap, const struct __ns1__GetHostInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHostInfo(soap, &a->ns1__GetHostInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHostInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetHostInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHostInfo(soap, "ns1:GetHostInfo", -1, &a->ns1__GetHostInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHostInfo_ * SOAP_FMAC4 soap_in___ns1__GetHostInfo_(struct soap *soap, const char *tag, struct __ns1__GetHostInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetHostInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetHostInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHostInfo_, sizeof(struct __ns1__GetHostInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHostInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHostInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHostInfo(soap, "ns1:GetHostInfo", &a->ns1__GetHostInfo, ""))
				{	soap_flag_ns1__GetHostInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHostInfo_(struct soap *soap, const struct __ns1__GetHostInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHostInfo_(soap, tag?tag:"-ns1:GetHostInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHostInfo_ * SOAP_FMAC4 soap_get___ns1__GetHostInfo_(struct soap *soap, struct __ns1__GetHostInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHostInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDNS_(struct soap *soap, struct __ns1__GetDNS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDNS_(struct soap *soap, const struct __ns1__GetDNS_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDNS(soap, &a->ns1__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDNS_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDNS_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetDNS(soap, "ns1:GetDNS", -1, &a->ns1__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDNS_ * SOAP_FMAC4 soap_in___ns1__GetDNS_(struct soap *soap, const char *tag, struct __ns1__GetDNS_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDNS = 1;
	short soap_flag;
	a = (struct __ns1__GetDNS_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDNS_, sizeof(struct __ns1__GetDNS_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDNS_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDNS(soap, "ns1:GetDNS", &a->ns1__GetDNS, ""))
				{	soap_flag_ns1__GetDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDNS_(struct soap *soap, const struct __ns1__GetDNS_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDNS_(soap, tag?tag:"-ns1:GetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDNS_ * SOAP_FMAC4 soap_get___ns1__GetDNS_(struct soap *soap, struct __ns1__GetDNS_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDNS_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTime_(struct soap *soap, struct __ns1__GetTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTime_(struct soap *soap, const struct __ns1__GetTime_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTime(soap, &a->ns1__GetTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetTime(soap, "ns1:GetTime", -1, &a->ns1__GetTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTime_ * SOAP_FMAC4 soap_in___ns1__GetTime_(struct soap *soap, const char *tag, struct __ns1__GetTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTime = 1;
	short soap_flag;
	a = (struct __ns1__GetTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTime_, sizeof(struct __ns1__GetTime_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTime(soap, "ns1:GetTime", &a->ns1__GetTime, ""))
				{	soap_flag_ns1__GetTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTime_(struct soap *soap, const struct __ns1__GetTime_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTime_(soap, tag?tag:"-ns1:GetTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTime_ * SOAP_FMAC4 soap_get___ns1__GetTime_(struct soap *soap, struct __ns1__GetTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREtz_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, &a->ns1__m_USCOREtz_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREtz_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, "ns1:m_tz_update1", -1, &a->ns1__m_USCOREtz_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate1 * SOAP_FMAC4 soap_in___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, struct __ns1__m_USCOREtz_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREtz_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREtz_USCOREupdate1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate1, sizeof(struct __ns1__m_USCOREtz_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREtz_USCOREupdate1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREtz_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, "ns1:m_tz_update1", &a->ns1__m_USCOREtz_USCOREupdate1, ""))
				{	soap_flag_ns1__m_USCOREtz_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREtz_USCOREupdate1(soap, tag?tag:"-ns1:m_tz_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate1 * SOAP_FMAC4 soap_get___ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREtz_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREDay1(struct soap *soap, struct __ns1__TZ_USCOREDay1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREDay1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREDay1(struct soap *soap, const struct __ns1__TZ_USCOREDay1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDay1(soap, &a->ns1__TZ_USCOREDay1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREDay1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1(soap, "ns1:TZ_Day1", -1, &a->ns1__TZ_USCOREDay1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay1 * SOAP_FMAC4 soap_in___ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREDay1 *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREDay1 = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREDay1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREDay1, sizeof(struct __ns1__TZ_USCOREDay1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREDay1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDay1(soap, "ns1:TZ_Day1", &a->ns1__TZ_USCOREDay1, ""))
				{	soap_flag_ns1__TZ_USCOREDay1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREDay1(struct soap *soap, const struct __ns1__TZ_USCOREDay1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREDay1(soap, tag?tag:"-ns1:TZ_Day1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay1 * SOAP_FMAC4 soap_get___ns1__TZ_USCOREDay1(struct soap *soap, struct __ns1__TZ_USCOREDay1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREDay1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hb_USCOREfp_USCOREdy_USCOREend1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, int id, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, "ns1:hb_fp_dy_end1", -1, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 * SOAP_FMAC4 soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *type)
{
	size_t soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1 = 1;
	short soap_flag;
	a = (struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend1, sizeof(struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, "ns1:hb_fp_dy_end1", &a->ns1__hb_USCOREfp_USCOREdy_USCOREend1, ""))
				{	soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag?tag:"-ns1:hb_fp_dy_end1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 * SOAP_FMAC4 soap_get___ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyue1(struct soap *soap, struct __ns1__get_USCOREyue1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyue1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyue1(struct soap *soap, const struct __ns1__get_USCOREyue1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyue1(soap, &a->ns1__get_USCOREyue1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyue1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyue1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyue1(soap, "ns1:get_yue1", -1, &a->ns1__get_USCOREyue1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue1 * SOAP_FMAC4 soap_in___ns1__get_USCOREyue1(struct soap *soap, const char *tag, struct __ns1__get_USCOREyue1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyue1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyue1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyue1, sizeof(struct __ns1__get_USCOREyue1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyue1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyue1(soap, "ns1:get_yue1", &a->ns1__get_USCOREyue1, ""))
				{	soap_flag_ns1__get_USCOREyue1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyue1(struct soap *soap, const struct __ns1__get_USCOREyue1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyue1(soap, tag?tag:"-ns1:get_yue1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue1 * SOAP_FMAC4 soap_get___ns1__get_USCOREyue1(struct soap *soap, struct __ns1__get_USCOREyue1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyue1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyyzd1(struct soap *soap, struct __ns1__get_USCOREyyzd1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyyzd1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyyzd1(struct soap *soap, const struct __ns1__get_USCOREyyzd1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzd1(soap, &a->ns1__get_USCOREyyzd1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyyzd1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1(soap, "ns1:get_yyzd1", -1, &a->ns1__get_USCOREyyzd1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd1 * SOAP_FMAC4 soap_in___ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, struct __ns1__get_USCOREyyzd1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyyzd1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyyzd1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyyzd1, sizeof(struct __ns1__get_USCOREyyzd1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyyzd1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyyzd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzd1(soap, "ns1:get_yyzd1", &a->ns1__get_USCOREyyzd1, ""))
				{	soap_flag_ns1__get_USCOREyyzd1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyyzd1(struct soap *soap, const struct __ns1__get_USCOREyyzd1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyyzd1(soap, tag?tag:"-ns1:get_yyzd1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd1 * SOAP_FMAC4 soap_get___ns1__get_USCOREyyzd1(struct soap *soap, struct __ns1__get_USCOREyyzd1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyyzd1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbfp1(struct soap *soap, struct __ns1__get_USCOREhbfp1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbfp1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbfp1(struct soap *soap, const struct __ns1__get_USCOREhbfp1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfp1(soap, &a->ns1__get_USCOREhbfp1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbfp1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1(soap, "ns1:get_hbfp1", -1, &a->ns1__get_USCOREhbfp1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp1 * SOAP_FMAC4 soap_in___ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbfp1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbfp1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbfp1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbfp1, sizeof(struct __ns1__get_USCOREhbfp1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbfp1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbfp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfp1(soap, "ns1:get_hbfp1", &a->ns1__get_USCOREhbfp1, ""))
				{	soap_flag_ns1__get_USCOREhbfp1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbfp1(struct soap *soap, const struct __ns1__get_USCOREhbfp1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbfp1(soap, tag?tag:"-ns1:get_hbfp1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp1 * SOAP_FMAC4 soap_get___ns1__get_USCOREhbfp1(struct soap *soap, struct __ns1__get_USCOREhbfp1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbfp1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREupdate1(struct soap *soap, struct __ns1__hbtsf_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREupdate1(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1(soap, &a->ns1__hbtsf_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1(soap, "ns1:hbtsf_update1", -1, &a->ns1__hbtsf_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate1 * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREupdate1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREupdate1, sizeof(struct __ns1__hbtsf_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREupdate1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdate1(soap, "ns1:hbtsf_update1", &a->ns1__hbtsf_USCOREupdate1, ""))
				{	soap_flag_ns1__hbtsf_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREupdate1(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREupdate1(soap, tag?tag:"-ns1:hbtsf_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate1 * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREupdate1(struct soap *soap, struct __ns1__hbtsf_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREupdate1(struct soap *soap, struct __ns1__hbwsh_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREupdate1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREupdate1(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1(soap, &a->ns1__hbwsh_USCOREupdate1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1(soap, "ns1:hbwsh_update1", -1, &a->ns1__hbwsh_USCOREupdate1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate1 * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREupdate1 = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREupdate1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREupdate1, sizeof(struct __ns1__hbwsh_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREupdate1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREupdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdate1(soap, "ns1:hbwsh_update1", &a->ns1__hbwsh_USCOREupdate1, ""))
				{	soap_flag_ns1__hbwsh_USCOREupdate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREupdate1(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREupdate1(soap, tag?tag:"-ns1:hbwsh_update1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate1 * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREupdate1(struct soap *soap, struct __ns1__hbwsh_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREmx1(struct soap *soap, struct __ns1__get_USCOREmx1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREmx1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREmx1(struct soap *soap, const struct __ns1__get_USCOREmx1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmx1(soap, &a->ns1__get_USCOREmx1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREmx1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREmx1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREmx1(soap, "ns1:get_mx1", -1, &a->ns1__get_USCOREmx1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx1 * SOAP_FMAC4 soap_in___ns1__get_USCOREmx1(struct soap *soap, const char *tag, struct __ns1__get_USCOREmx1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREmx1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREmx1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREmx1, sizeof(struct __ns1__get_USCOREmx1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREmx1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREmx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmx1(soap, "ns1:get_mx1", &a->ns1__get_USCOREmx1, ""))
				{	soap_flag_ns1__get_USCOREmx1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREmx1(struct soap *soap, const struct __ns1__get_USCOREmx1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREmx1(soap, tag?tag:"-ns1:get_mx1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx1 * SOAP_FMAC4 soap_get___ns1__get_USCOREmx1(struct soap *soap, struct __ns1__get_USCOREmx1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREmx1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh1(struct soap *soap, struct __ns1__get_USCOREhbwsh1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh1(struct soap *soap, const struct __ns1__get_USCOREhbwsh1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh1(soap, &a->ns1__get_USCOREhbwsh1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1(soap, "ns1:get_hbwsh1", -1, &a->ns1__get_USCOREhbwsh1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh1 * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh1, sizeof(struct __ns1__get_USCOREhbwsh1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh1(soap, "ns1:get_hbwsh1", &a->ns1__get_USCOREhbwsh1, ""))
				{	soap_flag_ns1__get_USCOREhbwsh1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh1(struct soap *soap, const struct __ns1__get_USCOREhbwsh1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh1(soap, tag?tag:"-ns1:get_hbwsh1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh1 * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh1(struct soap *soap, struct __ns1__get_USCOREhbwsh1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbgs1(struct soap *soap, struct __ns1__get_USCOREhbgs1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbgs1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbgs1(struct soap *soap, const struct __ns1__get_USCOREhbgs1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgs1(soap, &a->ns1__get_USCOREhbgs1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbgs1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1(soap, "ns1:get_hbgs1", -1, &a->ns1__get_USCOREhbgs1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs1 * SOAP_FMAC4 soap_in___ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbgs1 *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbgs1 = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbgs1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbgs1, sizeof(struct __ns1__get_USCOREhbgs1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbgs1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbgs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgs1(soap, "ns1:get_hbgs1", &a->ns1__get_USCOREhbgs1, ""))
				{	soap_flag_ns1__get_USCOREhbgs1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbgs1(struct soap *soap, const struct __ns1__get_USCOREhbgs1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbgs1(soap, tag?tag:"-ns1:get_hbgs1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs1 * SOAP_FMAC4 soap_get___ns1__get_USCOREhbgs1(struct soap *soap, struct __ns1__get_USCOREhbgs1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbgs1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct __ns1__fp_USCOREdy_USCOREend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fp_USCOREdy_USCOREend = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fp_USCOREdy_USCOREend(struct soap *soap, const struct __ns1__fp_USCOREdy_USCOREend *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, &a->ns1__fp_USCOREdy_USCOREend);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, const struct __ns1__fp_USCOREdy_USCOREend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, "ns1:fp_dy_end", -1, &a->ns1__fp_USCOREdy_USCOREend, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fp_USCOREdy_USCOREend * SOAP_FMAC4 soap_in___ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct __ns1__fp_USCOREdy_USCOREend *a, const char *type)
{
	size_t soap_flag_ns1__fp_USCOREdy_USCOREend = 1;
	short soap_flag;
	a = (struct __ns1__fp_USCOREdy_USCOREend *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fp_USCOREdy_USCOREend, sizeof(struct __ns1__fp_USCOREdy_USCOREend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fp_USCOREdy_USCOREend(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fp_USCOREdy_USCOREend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, "ns1:fp_dy_end", &a->ns1__fp_USCOREdy_USCOREend, ""))
				{	soap_flag_ns1__fp_USCOREdy_USCOREend--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fp_USCOREdy_USCOREend(struct soap *soap, const struct __ns1__fp_USCOREdy_USCOREend *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fp_USCOREdy_USCOREend(soap, tag?tag:"-ns1:fp_dy_end", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fp_USCOREdy_USCOREend * SOAP_FMAC4 soap_get___ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct __ns1__fp_USCOREdy_USCOREend *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREzbfp(struct soap *soap, struct __ns1__get_USCOREzbfp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREzbfp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREzbfp(struct soap *soap, const struct __ns1__get_USCOREzbfp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzbfp(soap, &a->ns1__get_USCOREzbfp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREzbfp(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREzbfp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREzbfp(soap, "ns1:get_zbfp", -1, &a->ns1__get_USCOREzbfp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzbfp * SOAP_FMAC4 soap_in___ns1__get_USCOREzbfp(struct soap *soap, const char *tag, struct __ns1__get_USCOREzbfp *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREzbfp = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREzbfp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREzbfp, sizeof(struct __ns1__get_USCOREzbfp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREzbfp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREzbfp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzbfp(soap, "ns1:get_zbfp", &a->ns1__get_USCOREzbfp, ""))
				{	soap_flag_ns1__get_USCOREzbfp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREzbfp(struct soap *soap, const struct __ns1__get_USCOREzbfp *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREzbfp(soap, tag?tag:"-ns1:get_zbfp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzbfp * SOAP_FMAC4 soap_get___ns1__get_USCOREzbfp(struct soap *soap, struct __ns1__get_USCOREzbfp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREzbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ZB_USCORETZ_USCOREMonth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREMonth *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, &a->ns1__ZB_USCORETZ_USCOREMonth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, int id, const struct __ns1__ZB_USCORETZ_USCOREMonth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, "ns1:ZB_TZ_Month", -1, &a->ns1__ZB_USCORETZ_USCOREMonth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREMonth * SOAP_FMAC4 soap_in___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, struct __ns1__ZB_USCORETZ_USCOREMonth *a, const char *type)
{
	size_t soap_flag_ns1__ZB_USCORETZ_USCOREMonth = 1;
	short soap_flag;
	a = (struct __ns1__ZB_USCORETZ_USCOREMonth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ZB_USCORETZ_USCOREMonth, sizeof(struct __ns1__ZB_USCORETZ_USCOREMonth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ZB_USCORETZ_USCOREMonth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ZB_USCORETZ_USCOREMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, "ns1:ZB_TZ_Month", &a->ns1__ZB_USCORETZ_USCOREMonth, ""))
				{	soap_flag_ns1__ZB_USCORETZ_USCOREMonth--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREMonth *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ZB_USCORETZ_USCOREMonth(soap, tag?tag:"-ns1:ZB_TZ_Month", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREMonth * SOAP_FMAC4 soap_get___ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREMonth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ZB_USCORETZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREDay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ZB_USCORETZ_USCOREDay = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREDay *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, &a->ns1__ZB_USCORETZ_USCOREDay);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, int id, const struct __ns1__ZB_USCORETZ_USCOREDay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, "ns1:ZB_TZ_Day", -1, &a->ns1__ZB_USCORETZ_USCOREDay, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREDay * SOAP_FMAC4 soap_in___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, struct __ns1__ZB_USCORETZ_USCOREDay *a, const char *type)
{
	size_t soap_flag_ns1__ZB_USCORETZ_USCOREDay = 1;
	short soap_flag;
	a = (struct __ns1__ZB_USCORETZ_USCOREDay *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ZB_USCORETZ_USCOREDay, sizeof(struct __ns1__ZB_USCORETZ_USCOREDay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ZB_USCORETZ_USCOREDay(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ZB_USCORETZ_USCOREDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, "ns1:ZB_TZ_Day", &a->ns1__ZB_USCORETZ_USCOREDay, ""))
				{	soap_flag_ns1__ZB_USCORETZ_USCOREDay--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const struct __ns1__ZB_USCORETZ_USCOREDay *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ZB_USCORETZ_USCOREDay(soap, tag?tag:"-ns1:ZB_TZ_Day", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ZB_USCORETZ_USCOREDay * SOAP_FMAC4 soap_get___ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct __ns1__ZB_USCORETZ_USCOREDay *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ZB_USCORETZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__tsf_USCOREupdate(struct soap *soap, struct __ns1__tsf_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__tsf_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__tsf_USCOREupdate(struct soap *soap, const struct __ns1__tsf_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__tsf_USCOREupdate(soap, &a->ns1__tsf_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__tsf_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__tsf_USCOREupdate(soap, "ns1:tsf_update", -1, &a->ns1__tsf_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__tsf_USCOREupdate * SOAP_FMAC4 soap_in___ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__tsf_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__tsf_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__tsf_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__tsf_USCOREupdate, sizeof(struct __ns1__tsf_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__tsf_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__tsf_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__tsf_USCOREupdate(soap, "ns1:tsf_update", &a->ns1__tsf_USCOREupdate, ""))
				{	soap_flag_ns1__tsf_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__tsf_USCOREupdate(struct soap *soap, const struct __ns1__tsf_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__tsf_USCOREupdate(soap, tag?tag:"-ns1:tsf_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__tsf_USCOREupdate * SOAP_FMAC4 soap_get___ns1__tsf_USCOREupdate(struct soap *soap, struct __ns1__tsf_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__tsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wsh_USCOREupdate(struct soap *soap, struct __ns1__wsh_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wsh_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wsh_USCOREupdate(struct soap *soap, const struct __ns1__wsh_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__wsh_USCOREupdate(soap, &a->ns1__wsh_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__wsh_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__wsh_USCOREupdate(soap, "ns1:wsh_update", -1, &a->ns1__wsh_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wsh_USCOREupdate * SOAP_FMAC4 soap_in___ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__wsh_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__wsh_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__wsh_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wsh_USCOREupdate, sizeof(struct __ns1__wsh_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wsh_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wsh_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__wsh_USCOREupdate(soap, "ns1:wsh_update", &a->ns1__wsh_USCOREupdate, ""))
				{	soap_flag_ns1__wsh_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wsh_USCOREupdate(struct soap *soap, const struct __ns1__wsh_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wsh_USCOREupdate(soap, tag?tag:"-ns1:wsh_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wsh_USCOREupdate * SOAP_FMAC4 soap_get___ns1__wsh_USCOREupdate(struct soap *soap, struct __ns1__wsh_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct __ns1__get_USCOREzb_USCOREmx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREzb_USCOREmx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREzb_USCOREmx(struct soap *soap, const struct __ns1__get_USCOREzb_USCOREmx *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, &a->ns1__get_USCOREzb_USCOREmx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREzb_USCOREmx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, "ns1:get_zb_mx", -1, &a->ns1__get_USCOREzb_USCOREmx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzb_USCOREmx * SOAP_FMAC4 soap_in___ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, struct __ns1__get_USCOREzb_USCOREmx *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREzb_USCOREmx = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREzb_USCOREmx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREzb_USCOREmx, sizeof(struct __ns1__get_USCOREzb_USCOREmx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREzb_USCOREmx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREzb_USCOREmx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, "ns1:get_zb_mx", &a->ns1__get_USCOREzb_USCOREmx, ""))
				{	soap_flag_ns1__get_USCOREzb_USCOREmx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREzb_USCOREmx(struct soap *soap, const struct __ns1__get_USCOREzb_USCOREmx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREzb_USCOREmx(soap, tag?tag:"-ns1:get_zb_mx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREzb_USCOREmx * SOAP_FMAC4 soap_get___ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct __ns1__get_USCOREzb_USCOREmx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREzb_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREwsh(struct soap *soap, struct __ns1__get_USCOREwsh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREwsh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREwsh(struct soap *soap, const struct __ns1__get_USCOREwsh *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREwsh(soap, &a->ns1__get_USCOREwsh);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREwsh(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREwsh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREwsh(soap, "ns1:get_wsh", -1, &a->ns1__get_USCOREwsh, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREwsh * SOAP_FMAC4 soap_in___ns1__get_USCOREwsh(struct soap *soap, const char *tag, struct __ns1__get_USCOREwsh *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREwsh = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREwsh *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREwsh, sizeof(struct __ns1__get_USCOREwsh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREwsh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREwsh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREwsh(soap, "ns1:get_wsh", &a->ns1__get_USCOREwsh, ""))
				{	soap_flag_ns1__get_USCOREwsh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREwsh(struct soap *soap, const struct __ns1__get_USCOREwsh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREwsh(soap, tag?tag:"-ns1:get_wsh", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREwsh * SOAP_FMAC4 soap_get___ns1__get_USCOREwsh(struct soap *soap, struct __ns1__get_USCOREwsh *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hb_USCOREfp_USCOREdy_USCOREend = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, "ns1:hb_fp_dy_end", -1, &a->ns1__hb_USCOREfp_USCOREdy_USCOREend, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend * SOAP_FMAC4 soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *type)
{
	size_t soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend = 1;
	short soap_flag;
	a = (struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hb_USCOREfp_USCOREdy_USCOREend, sizeof(struct __ns1__hb_USCOREfp_USCOREdy_USCOREend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, "ns1:hb_fp_dy_end", &a->ns1__hb_USCOREfp_USCOREdy_USCOREend, ""))
				{	soap_flag_ns1__hb_USCOREfp_USCOREdy_USCOREend--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag?tag:"-ns1:hb_fp_dy_end", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hb_USCOREfp_USCOREdy_USCOREend * SOAP_FMAC4 soap_get___ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct __ns1__hb_USCOREfp_USCOREdy_USCOREend *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct __ns1__hbtsf_USCOREyue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREyue_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const struct __ns1__hbtsf_USCOREyue_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, &a->ns1__hbtsf_USCOREyue_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, "ns1:hbtsf_yue_update", -1, &a->ns1__hbtsf_USCOREyue_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREyue_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREyue_USCOREupdate, sizeof(struct __ns1__hbtsf_USCOREyue_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREyue_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, "ns1:hbtsf_yue_update", &a->ns1__hbtsf_USCOREyue_USCOREupdate, ""))
				{	soap_flag_ns1__hbtsf_USCOREyue_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const struct __ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag?tag:"-ns1:hbtsf_yue_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct __ns1__hbtsf_USCOREyue_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct __ns1__hbwsh_USCOREyue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREyue_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const struct __ns1__hbwsh_USCOREyue_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, &a->ns1__hbwsh_USCOREyue_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, "ns1:hbwsh_yue_update", -1, &a->ns1__hbwsh_USCOREyue_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREyue_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREyue_USCOREupdate, sizeof(struct __ns1__hbwsh_USCOREyue_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREyue_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, "ns1:hbwsh_yue_update", &a->ns1__hbwsh_USCOREyue_USCOREupdate, ""))
				{	soap_flag_ns1__hbwsh_USCOREyue_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const struct __ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag?tag:"-ns1:hbwsh_yue_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct __ns1__hbwsh_USCOREyue_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyue(struct soap *soap, struct __ns1__get_USCOREyue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyue(struct soap *soap, const struct __ns1__get_USCOREyue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyue(soap, &a->ns1__get_USCOREyue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyue(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyue(soap, "ns1:get_yue", -1, &a->ns1__get_USCOREyue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue * SOAP_FMAC4 soap_in___ns1__get_USCOREyue(struct soap *soap, const char *tag, struct __ns1__get_USCOREyue *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyue = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyue *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyue, sizeof(struct __ns1__get_USCOREyue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyue(soap, "ns1:get_yue", &a->ns1__get_USCOREyue, ""))
				{	soap_flag_ns1__get_USCOREyue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyue(struct soap *soap, const struct __ns1__get_USCOREyue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyue(soap, tag?tag:"-ns1:get_yue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyue * SOAP_FMAC4 soap_get___ns1__get_USCOREyue(struct soap *soap, struct __ns1__get_USCOREyue *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct __ns1__get_USCOREhbwsh_USCOREyue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh_USCOREyue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const struct __ns1__get_USCOREhbwsh_USCOREyue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, &a->ns1__get_USCOREhbwsh_USCOREyue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh_USCOREyue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, "ns1:get_hbwsh_yue", -1, &a->ns1__get_USCOREhbwsh_USCOREyue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_USCOREyue * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh_USCOREyue *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh_USCOREyue = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh_USCOREyue *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh_USCOREyue, sizeof(struct __ns1__get_USCOREhbwsh_USCOREyue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh_USCOREyue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh_USCOREyue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, "ns1:get_hbwsh_yue", &a->ns1__get_USCOREhbwsh_USCOREyue, ""))
				{	soap_flag_ns1__get_USCOREhbwsh_USCOREyue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const struct __ns1__get_USCOREhbwsh_USCOREyue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh_USCOREyue(soap, tag?tag:"-ns1:get_hbwsh_yue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh_USCOREyue * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct __ns1__get_USCOREhbwsh_USCOREyue *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREyyzd(struct soap *soap, struct __ns1__get_USCOREyyzd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREyyzd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREyyzd(struct soap *soap, const struct __ns1__get_USCOREyyzd *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzd(soap, &a->ns1__get_USCOREyyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREyyzd(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREyyzd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREyyzd(soap, "ns1:get_yyzd", -1, &a->ns1__get_USCOREyyzd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd * SOAP_FMAC4 soap_in___ns1__get_USCOREyyzd(struct soap *soap, const char *tag, struct __ns1__get_USCOREyyzd *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREyyzd = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREyyzd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREyyzd, sizeof(struct __ns1__get_USCOREyyzd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREyyzd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREyyzd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzd(soap, "ns1:get_yyzd", &a->ns1__get_USCOREyyzd, ""))
				{	soap_flag_ns1__get_USCOREyyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREyyzd(struct soap *soap, const struct __ns1__get_USCOREyyzd *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREyyzd(soap, tag?tag:"-ns1:get_yyzd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREyyzd * SOAP_FMAC4 soap_get___ns1__get_USCOREyyzd(struct soap *soap, struct __ns1__get_USCOREyyzd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREyyzd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbfp(struct soap *soap, struct __ns1__get_USCOREhbfp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbfp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbfp(struct soap *soap, const struct __ns1__get_USCOREhbfp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfp(soap, &a->ns1__get_USCOREhbfp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbfp(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbfp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbfp(soap, "ns1:get_hbfp", -1, &a->ns1__get_USCOREhbfp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp * SOAP_FMAC4 soap_in___ns1__get_USCOREhbfp(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbfp *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbfp = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbfp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbfp, sizeof(struct __ns1__get_USCOREhbfp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbfp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbfp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfp(soap, "ns1:get_hbfp", &a->ns1__get_USCOREhbfp, ""))
				{	soap_flag_ns1__get_USCOREhbfp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbfp(struct soap *soap, const struct __ns1__get_USCOREhbfp *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbfp(soap, tag?tag:"-ns1:get_hbfp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbfp * SOAP_FMAC4 soap_get___ns1__get_USCOREhbfp(struct soap *soap, struct __ns1__get_USCOREhbfp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREzb_USCOREtz_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, "ns1:m_zb_tz_update", -1, &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_in___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREzb_USCOREtz_USCOREupdate, sizeof(struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, "ns1:m_zb_tz_update", &a->ns1__m_USCOREzb_USCOREtz_USCOREupdate, ""))
				{	soap_flag_ns1__m_USCOREzb_USCOREtz_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag?tag:"-ns1:m_zb_tz_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_get___ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct __ns1__m_USCOREzb_USCOREtz_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__m_USCOREtz_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, &a->ns1__m_USCOREtz_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__m_USCOREtz_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, "ns1:m_tz_update", -1, &a->ns1__m_USCOREtz_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_in___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__m_USCOREtz_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__m_USCOREtz_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__m_USCOREtz_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__m_USCOREtz_USCOREupdate, sizeof(struct __ns1__m_USCOREtz_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__m_USCOREtz_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__m_USCOREtz_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, "ns1:m_tz_update", &a->ns1__m_USCOREtz_USCOREupdate, ""))
				{	soap_flag_ns1__m_USCOREtz_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const struct __ns1__m_USCOREtz_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__m_USCOREtz_USCOREupdate(soap, tag?tag:"-ns1:m_tz_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__m_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_get___ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct __ns1__m_USCOREtz_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__m_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREMonth(struct soap *soap, struct __ns1__TZ_USCOREMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREMonth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREMonth(struct soap *soap, const struct __ns1__TZ_USCOREMonth *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREMonth(soap, &a->ns1__TZ_USCOREMonth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREMonth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREMonth(soap, "ns1:TZ_Month", -1, &a->ns1__TZ_USCOREMonth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREMonth * SOAP_FMAC4 soap_in___ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREMonth *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREMonth = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREMonth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREMonth, sizeof(struct __ns1__TZ_USCOREMonth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREMonth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREMonth(soap, "ns1:TZ_Month", &a->ns1__TZ_USCOREMonth, ""))
				{	soap_flag_ns1__TZ_USCOREMonth--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREMonth(struct soap *soap, const struct __ns1__TZ_USCOREMonth *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREMonth(soap, tag?tag:"-ns1:TZ_Month", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREMonth * SOAP_FMAC4 soap_get___ns1__TZ_USCOREMonth(struct soap *soap, struct __ns1__TZ_USCOREMonth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TZ_USCOREDay(struct soap *soap, struct __ns1__TZ_USCOREDay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TZ_USCOREDay = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TZ_USCOREDay(struct soap *soap, const struct __ns1__TZ_USCOREDay *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDay(soap, &a->ns1__TZ_USCOREDay);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TZ_USCOREDay(struct soap *soap, const char *tag, int id, const struct __ns1__TZ_USCOREDay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__TZ_USCOREDay(soap, "ns1:TZ_Day", -1, &a->ns1__TZ_USCOREDay, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay * SOAP_FMAC4 soap_in___ns1__TZ_USCOREDay(struct soap *soap, const char *tag, struct __ns1__TZ_USCOREDay *a, const char *type)
{
	size_t soap_flag_ns1__TZ_USCOREDay = 1;
	short soap_flag;
	a = (struct __ns1__TZ_USCOREDay *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TZ_USCOREDay, sizeof(struct __ns1__TZ_USCOREDay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TZ_USCOREDay(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TZ_USCOREDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDay(soap, "ns1:TZ_Day", &a->ns1__TZ_USCOREDay, ""))
				{	soap_flag_ns1__TZ_USCOREDay--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TZ_USCOREDay(struct soap *soap, const struct __ns1__TZ_USCOREDay *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TZ_USCOREDay(soap, tag?tag:"-ns1:TZ_Day", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TZ_USCOREDay * SOAP_FMAC4 soap_get___ns1__TZ_USCOREDay(struct soap *soap, struct __ns1__TZ_USCOREDay *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbtsf_USCOREupdate(struct soap *soap, struct __ns1__hbtsf_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbtsf_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbtsf_USCOREupdate(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate(soap, &a->ns1__hbtsf_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__hbtsf_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate(soap, "ns1:hbtsf_update", -1, &a->ns1__hbtsf_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate * SOAP_FMAC4 soap_in___ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__hbtsf_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__hbtsf_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbtsf_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbtsf_USCOREupdate, sizeof(struct __ns1__hbtsf_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbtsf_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbtsf_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdate(soap, "ns1:hbtsf_update", &a->ns1__hbtsf_USCOREupdate, ""))
				{	soap_flag_ns1__hbtsf_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbtsf_USCOREupdate(struct soap *soap, const struct __ns1__hbtsf_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbtsf_USCOREupdate(soap, tag?tag:"-ns1:hbtsf_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbtsf_USCOREupdate * SOAP_FMAC4 soap_get___ns1__hbtsf_USCOREupdate(struct soap *soap, struct __ns1__hbtsf_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbtsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hbwsh_USCOREupdate(struct soap *soap, struct __ns1__hbwsh_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hbwsh_USCOREupdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hbwsh_USCOREupdate(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate(soap, &a->ns1__hbwsh_USCOREupdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, int id, const struct __ns1__hbwsh_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate(soap, "ns1:hbwsh_update", -1, &a->ns1__hbwsh_USCOREupdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate * SOAP_FMAC4 soap_in___ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, struct __ns1__hbwsh_USCOREupdate *a, const char *type)
{
	size_t soap_flag_ns1__hbwsh_USCOREupdate = 1;
	short soap_flag;
	a = (struct __ns1__hbwsh_USCOREupdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hbwsh_USCOREupdate, sizeof(struct __ns1__hbwsh_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hbwsh_USCOREupdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hbwsh_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdate(soap, "ns1:hbwsh_update", &a->ns1__hbwsh_USCOREupdate, ""))
				{	soap_flag_ns1__hbwsh_USCOREupdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hbwsh_USCOREupdate(struct soap *soap, const struct __ns1__hbwsh_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hbwsh_USCOREupdate(soap, tag?tag:"-ns1:hbwsh_update", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hbwsh_USCOREupdate * SOAP_FMAC4 soap_get___ns1__hbwsh_USCOREupdate(struct soap *soap, struct __ns1__hbwsh_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hbwsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREmx(struct soap *soap, struct __ns1__get_USCOREmx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREmx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREmx(struct soap *soap, const struct __ns1__get_USCOREmx *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmx(soap, &a->ns1__get_USCOREmx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREmx(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREmx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREmx(soap, "ns1:get_mx", -1, &a->ns1__get_USCOREmx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx * SOAP_FMAC4 soap_in___ns1__get_USCOREmx(struct soap *soap, const char *tag, struct __ns1__get_USCOREmx *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREmx = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREmx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREmx, sizeof(struct __ns1__get_USCOREmx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREmx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREmx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmx(soap, "ns1:get_mx", &a->ns1__get_USCOREmx, ""))
				{	soap_flag_ns1__get_USCOREmx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREmx(struct soap *soap, const struct __ns1__get_USCOREmx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREmx(soap, tag?tag:"-ns1:get_mx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREmx * SOAP_FMAC4 soap_get___ns1__get_USCOREmx(struct soap *soap, struct __ns1__get_USCOREmx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbwsh(struct soap *soap, struct __ns1__get_USCOREhbwsh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbwsh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbwsh(struct soap *soap, const struct __ns1__get_USCOREhbwsh *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh(soap, &a->ns1__get_USCOREhbwsh);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbwsh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh(soap, "ns1:get_hbwsh", -1, &a->ns1__get_USCOREhbwsh, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh * SOAP_FMAC4 soap_in___ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbwsh *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbwsh = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbwsh *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbwsh, sizeof(struct __ns1__get_USCOREhbwsh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbwsh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbwsh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh(soap, "ns1:get_hbwsh", &a->ns1__get_USCOREhbwsh, ""))
				{	soap_flag_ns1__get_USCOREhbwsh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbwsh(struct soap *soap, const struct __ns1__get_USCOREhbwsh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbwsh(soap, tag?tag:"-ns1:get_hbwsh", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbwsh * SOAP_FMAC4 soap_get___ns1__get_USCOREhbwsh(struct soap *soap, struct __ns1__get_USCOREhbwsh *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get_USCOREhbgs(struct soap *soap, struct __ns1__get_USCOREhbgs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__get_USCOREhbgs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get_USCOREhbgs(struct soap *soap, const struct __ns1__get_USCOREhbgs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgs(soap, &a->ns1__get_USCOREhbgs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get_USCOREhbgs(struct soap *soap, const char *tag, int id, const struct __ns1__get_USCOREhbgs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__get_USCOREhbgs(soap, "ns1:get_hbgs", -1, &a->ns1__get_USCOREhbgs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs * SOAP_FMAC4 soap_in___ns1__get_USCOREhbgs(struct soap *soap, const char *tag, struct __ns1__get_USCOREhbgs *a, const char *type)
{
	size_t soap_flag_ns1__get_USCOREhbgs = 1;
	short soap_flag;
	a = (struct __ns1__get_USCOREhbgs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__get_USCOREhbgs, sizeof(struct __ns1__get_USCOREhbgs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__get_USCOREhbgs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__get_USCOREhbgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgs(soap, "ns1:get_hbgs", &a->ns1__get_USCOREhbgs, ""))
				{	soap_flag_ns1__get_USCOREhbgs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get_USCOREhbgs(struct soap *soap, const struct __ns1__get_USCOREhbgs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__get_USCOREhbgs(soap, tag?tag:"-ns1:get_hbgs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get_USCOREhbgs * SOAP_FMAC4 soap_get___ns1__get_USCOREhbgs(struct soap *soap, struct __ns1__get_USCOREhbgs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__get_USCOREhbgs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FromBASE64(struct soap *soap, struct __ns1__FromBASE64 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FromBASE64 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FromBASE64(struct soap *soap, const struct __ns1__FromBASE64 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__FromBASE64(soap, &a->ns1__FromBASE64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FromBASE64(struct soap *soap, const char *tag, int id, const struct __ns1__FromBASE64 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__FromBASE64(soap, "ns1:FromBASE64", -1, &a->ns1__FromBASE64, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FromBASE64 * SOAP_FMAC4 soap_in___ns1__FromBASE64(struct soap *soap, const char *tag, struct __ns1__FromBASE64 *a, const char *type)
{
	size_t soap_flag_ns1__FromBASE64 = 1;
	short soap_flag;
	a = (struct __ns1__FromBASE64 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FromBASE64, sizeof(struct __ns1__FromBASE64), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FromBASE64(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FromBASE64 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FromBASE64(soap, "ns1:FromBASE64", &a->ns1__FromBASE64, ""))
				{	soap_flag_ns1__FromBASE64--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FromBASE64(struct soap *soap, const struct __ns1__FromBASE64 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__FromBASE64(soap, tag?tag:"-ns1:FromBASE64", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FromBASE64 * SOAP_FMAC4 soap_get___ns1__FromBASE64(struct soap *soap, struct __ns1__FromBASE64 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FromBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToBASE64(struct soap *soap, struct __ns1__ToBASE64 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToBASE64 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToBASE64(struct soap *soap, const struct __ns1__ToBASE64 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ToBASE64(soap, &a->ns1__ToBASE64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToBASE64(struct soap *soap, const char *tag, int id, const struct __ns1__ToBASE64 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ToBASE64(soap, "ns1:ToBASE64", -1, &a->ns1__ToBASE64, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToBASE64 * SOAP_FMAC4 soap_in___ns1__ToBASE64(struct soap *soap, const char *tag, struct __ns1__ToBASE64 *a, const char *type)
{
	size_t soap_flag_ns1__ToBASE64 = 1;
	short soap_flag;
	a = (struct __ns1__ToBASE64 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToBASE64, sizeof(struct __ns1__ToBASE64), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToBASE64(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToBASE64 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ToBASE64(soap, "ns1:ToBASE64", &a->ns1__ToBASE64, ""))
				{	soap_flag_ns1__ToBASE64--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToBASE64(struct soap *soap, const struct __ns1__ToBASE64 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ToBASE64(soap, tag?tag:"-ns1:ToBASE64", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToBASE64 * SOAP_FMAC4 soap_get___ns1__ToBASE64(struct soap *soap, struct __ns1__ToBASE64 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSHA1(struct soap *soap, struct __ns1__CheckSHA1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSHA1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSHA1(struct soap *soap, const struct __ns1__CheckSHA1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckSHA1(soap, &a->ns1__CheckSHA1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSHA1(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSHA1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CheckSHA1(soap, "ns1:CheckSHA1", -1, &a->ns1__CheckSHA1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSHA1 * SOAP_FMAC4 soap_in___ns1__CheckSHA1(struct soap *soap, const char *tag, struct __ns1__CheckSHA1 *a, const char *type)
{
	size_t soap_flag_ns1__CheckSHA1 = 1;
	short soap_flag;
	a = (struct __ns1__CheckSHA1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSHA1, sizeof(struct __ns1__CheckSHA1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSHA1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSHA1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckSHA1(soap, "ns1:CheckSHA1", &a->ns1__CheckSHA1, ""))
				{	soap_flag_ns1__CheckSHA1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSHA1(struct soap *soap, const struct __ns1__CheckSHA1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckSHA1(soap, tag?tag:"-ns1:CheckSHA1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSHA1 * SOAP_FMAC4 soap_get___ns1__CheckSHA1(struct soap *soap, struct __ns1__CheckSHA1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSHA1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHostInfo(struct soap *soap, struct __ns1__GetHostInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHostInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHostInfo(struct soap *soap, const struct __ns1__GetHostInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHostInfo(soap, &a->ns1__GetHostInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHostInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetHostInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHostInfo(soap, "ns1:GetHostInfo", -1, &a->ns1__GetHostInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHostInfo * SOAP_FMAC4 soap_in___ns1__GetHostInfo(struct soap *soap, const char *tag, struct __ns1__GetHostInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetHostInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetHostInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHostInfo, sizeof(struct __ns1__GetHostInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHostInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHostInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHostInfo(soap, "ns1:GetHostInfo", &a->ns1__GetHostInfo, ""))
				{	soap_flag_ns1__GetHostInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHostInfo(struct soap *soap, const struct __ns1__GetHostInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHostInfo(soap, tag?tag:"-ns1:GetHostInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHostInfo * SOAP_FMAC4 soap_get___ns1__GetHostInfo(struct soap *soap, struct __ns1__GetHostInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHostInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDNS(struct soap *soap, struct __ns1__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDNS(struct soap *soap, const struct __ns1__GetDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDNS(soap, &a->ns1__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDNS(struct soap *soap, const char *tag, int id, const struct __ns1__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetDNS(soap, "ns1:GetDNS", -1, &a->ns1__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDNS * SOAP_FMAC4 soap_in___ns1__GetDNS(struct soap *soap, const char *tag, struct __ns1__GetDNS *a, const char *type)
{
	size_t soap_flag_ns1__GetDNS = 1;
	short soap_flag;
	a = (struct __ns1__GetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDNS, sizeof(struct __ns1__GetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDNS(soap, "ns1:GetDNS", &a->ns1__GetDNS, ""))
				{	soap_flag_ns1__GetDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDNS(struct soap *soap, const struct __ns1__GetDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDNS(soap, tag?tag:"-ns1:GetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDNS * SOAP_FMAC4 soap_get___ns1__GetDNS(struct soap *soap, struct __ns1__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTime(struct soap *soap, struct __ns1__GetTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTime(struct soap *soap, const struct __ns1__GetTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTime(soap, &a->ns1__GetTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetTime(soap, "ns1:GetTime", -1, &a->ns1__GetTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTime * SOAP_FMAC4 soap_in___ns1__GetTime(struct soap *soap, const char *tag, struct __ns1__GetTime *a, const char *type)
{
	size_t soap_flag_ns1__GetTime = 1;
	short soap_flag;
	a = (struct __ns1__GetTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTime, sizeof(struct __ns1__GetTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTime(soap, "ns1:GetTime", &a->ns1__GetTime, ""))
				{	soap_flag_ns1__GetTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTime(struct soap *soap, const struct __ns1__GetTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTime(soap, tag?tag:"-ns1:GetTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTime * SOAP_FMAC4 soap_get___ns1__GetTime(struct soap *soap, struct __ns1__GetTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result);
	if (soap_out__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag?tag:"ns1:m_tz_update1Response-m_tz_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->m_USCOREtz_USCOREupdate1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, &a->m_USCOREtz_USCOREupdate1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdate1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response), type))
		return soap->error;
	if (a->m_USCOREtz_USCOREupdate1Result)
		soap_element_result(soap, "ns1:m_tz_update1Result");
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, "ns1:m_tz_update1Result", -1, &a->m_USCOREtz_USCOREupdate1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1Response *a, const char *type)
{
	size_t soap_flag_m_USCOREtz_USCOREupdate1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdate1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_USCOREtz_USCOREupdate1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, "ns1:m_tz_update1Result", &a->m_USCOREtz_USCOREupdate1Result, ""))
				{	soap_flag_m_USCOREtz_USCOREupdate1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:m_tz_update1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response);
	if (soap_out__ns1__m_USCOREtz_USCOREupdate1Response(soap, tag?tag:"ns1:m_tz_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1 * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdate1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdate1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1);
	if (soap_out__ns1__m_USCOREtz_USCOREupdate1(soap, tag?tag:"ns1:m_tz_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1 * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result, sizeof(struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result, 0, sizeof(struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result);
	if (soap_out__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag?tag:"ns1:TZ_Day1Response-TZ_Day1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDay1Response(struct soap *soap, struct _ns1__TZ_USCOREDay1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TZ_USCOREDay1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDay1Response(struct soap *soap, const struct _ns1__TZ_USCOREDay1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, &a->TZ_USCOREDay1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDay1Response(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDay1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDay1Response), type))
		return soap->error;
	if (a->TZ_USCOREDay1Result)
		soap_element_result(soap, "ns1:TZ_Day1Result");
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, "ns1:TZ_Day1Result", -1, &a->TZ_USCOREDay1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDay1Response(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1Response *a, const char *type)
{
	size_t soap_flag_TZ_USCOREDay1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDay1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDay1Response, sizeof(struct _ns1__TZ_USCOREDay1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDay1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ_USCOREDay1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, "ns1:TZ_Day1Result", &a->TZ_USCOREDay1Result, ""))
				{	soap_flag_TZ_USCOREDay1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:TZ_Day1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDay1Response, 0, sizeof(struct _ns1__TZ_USCOREDay1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDay1Response(struct soap *soap, const struct _ns1__TZ_USCOREDay1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDay1Response);
	if (soap_out__ns1__TZ_USCOREDay1Response(soap, tag?tag:"ns1:TZ_Day1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDay1Response(struct soap *soap, struct _ns1__TZ_USCOREDay1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDay1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDay1(struct soap *soap, struct _ns1__TZ_USCOREDay1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->Base64);
	soap_default_string(soap, &a->Base64_USCORESHA1);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDay1(struct soap *soap, const struct _ns1__TZ_USCOREDay1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->Base64);
	soap_serialize_string(soap, &a->Base64_USCORESHA1);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDay1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDay1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64", -1, &a->Base64, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64_SHA1", -1, &a->Base64_USCORESHA1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1 * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1 *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_Base64 = 1;
	size_t soap_flag_Base64_USCORESHA1 = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDay1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDay1, sizeof(struct _ns1__TZ_USCOREDay1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDay1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_Base64 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64", &a->Base64, "xsd:string"))
				{	soap_flag_Base64--;
					continue;
				}
			if (soap_flag_Base64_USCORESHA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64_SHA1", &a->Base64_USCORESHA1, "xsd:string"))
				{	soap_flag_Base64_USCORESHA1--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDay1, 0, sizeof(struct _ns1__TZ_USCOREDay1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDay1(struct soap *soap, const struct _ns1__TZ_USCOREDay1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDay1);
	if (soap_out__ns1__TZ_USCOREDay1(soap, tag?tag:"ns1:TZ_Day1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1 * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDay1(struct soap *soap, struct _ns1__TZ_USCOREDay1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDay1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag?tag:"ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hb_USCOREfp_USCOREdy_USCOREend1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, &a->hb_USCOREfp_USCOREdy_USCOREend1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response), type))
		return soap->error;
	if (a->hb_USCOREfp_USCOREdy_USCOREend1Result)
		soap_element_result(soap, "ns1:hb_fp_dy_end1Result");
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, "ns1:hb_fp_dy_end1Result", -1, &a->hb_USCOREfp_USCOREdy_USCOREend1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *a, const char *type)
{
	size_t soap_flag_hb_USCOREfp_USCOREdy_USCOREend1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hb_USCOREfp_USCOREdy_USCOREend1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, "ns1:hb_fp_dy_end1Result", &a->hb_USCOREfp_USCOREdy_USCOREend1Result, ""))
				{	soap_flag_hb_USCOREfp_USCOREdy_USCOREend1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:hb_fp_dy_end1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag?tag:"ns1:hb_fp_dy_end1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag?tag:"ns1:hb_fp_dy_end1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result, sizeof(struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result, 0, sizeof(struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result);
	if (soap_out__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag?tag:"ns1:get_yue1Response-get_yue1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyue1Response(struct soap *soap, struct _ns1__get_USCOREyue1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREyue1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyue1Response(struct soap *soap, const struct _ns1__get_USCOREyue1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, &a->get_USCOREyue1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyue1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyue1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyue1Response), type))
		return soap->error;
	if (a->get_USCOREyue1Result)
		soap_element_result(soap, "ns1:get_yue1Result");
	if (soap_out_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, "ns1:get_yue1Result", -1, &a->get_USCOREyue1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREyue1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREyue1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyue1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyue1Response, sizeof(struct _ns1__get_USCOREyue1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyue1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREyue1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, "ns1:get_yue1Result", &a->get_USCOREyue1Result, ""))
				{	soap_flag_get_USCOREyue1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_yue1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyue1Response, 0, sizeof(struct _ns1__get_USCOREyue1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyue1Response(struct soap *soap, const struct _ns1__get_USCOREyue1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyue1Response);
	if (soap_out__ns1__get_USCOREyue1Response(soap, tag?tag:"ns1:get_yue1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREyue1Response(struct soap *soap, struct _ns1__get_USCOREyue1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyue1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyue1(struct soap *soap, struct _ns1__get_USCOREyue1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyue1(struct soap *soap, const struct _ns1__get_USCOREyue1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyue1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyue1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyue1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1 * SOAP_FMAC4 soap_in__ns1__get_USCOREyue1(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1 *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyue1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyue1, sizeof(struct _ns1__get_USCOREyue1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyue1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyue1, 0, sizeof(struct _ns1__get_USCOREyue1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyue1(struct soap *soap, const struct _ns1__get_USCOREyue1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyue1);
	if (soap_out__ns1__get_USCOREyue1(soap, tag?tag:"ns1:get_yue1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1 * SOAP_FMAC4 soap_get__ns1__get_USCOREyue1(struct soap *soap, struct _ns1__get_USCOREyue1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyue1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result, sizeof(struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result, 0, sizeof(struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result);
	if (soap_out__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag?tag:"ns1:get_yyzd1Response-get_yyzd1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzd1Response(struct soap *soap, struct _ns1__get_USCOREyyzd1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREyyzd1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzd1Response(struct soap *soap, const struct _ns1__get_USCOREyyzd1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, &a->get_USCOREyyzd1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzd1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzd1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzd1Response), type))
		return soap->error;
	if (a->get_USCOREyyzd1Result)
		soap_element_result(soap, "ns1:get_yyzd1Result");
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, "ns1:get_yyzd1Result", -1, &a->get_USCOREyyzd1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzd1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREyyzd1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzd1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzd1Response, sizeof(struct _ns1__get_USCOREyyzd1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzd1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREyyzd1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, "ns1:get_yyzd1Result", &a->get_USCOREyyzd1Result, ""))
				{	soap_flag_get_USCOREyyzd1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_yyzd1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzd1Response, 0, sizeof(struct _ns1__get_USCOREyyzd1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzd1Response(struct soap *soap, const struct _ns1__get_USCOREyyzd1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzd1Response);
	if (soap_out__ns1__get_USCOREyyzd1Response(soap, tag?tag:"ns1:get_yyzd1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzd1Response(struct soap *soap, struct _ns1__get_USCOREyyzd1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzd1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzd1(struct soap *soap, struct _ns1__get_USCOREyyzd1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzd1(struct soap *soap, const struct _ns1__get_USCOREyyzd1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzd1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzd1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1 * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1 *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzd1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzd1, sizeof(struct _ns1__get_USCOREyyzd1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzd1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzd1, 0, sizeof(struct _ns1__get_USCOREyyzd1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzd1(struct soap *soap, const struct _ns1__get_USCOREyyzd1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzd1);
	if (soap_out__ns1__get_USCOREyyzd1(soap, tag?tag:"ns1:get_yyzd1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1 * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzd1(struct soap *soap, struct _ns1__get_USCOREyyzd1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzd1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result, sizeof(struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result, 0, sizeof(struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result);
	if (soap_out__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag?tag:"ns1:get_hbfp1Response-get_hbfp1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfp1Response(struct soap *soap, struct _ns1__get_USCOREhbfp1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbfp1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfp1Response(struct soap *soap, const struct _ns1__get_USCOREhbfp1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, &a->get_USCOREhbfp1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfp1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfp1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfp1Response), type))
		return soap->error;
	if (a->get_USCOREhbfp1Result)
		soap_element_result(soap, "ns1:get_hbfp1Result");
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, "ns1:get_hbfp1Result", -1, &a->get_USCOREhbfp1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfp1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREhbfp1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfp1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfp1Response, sizeof(struct _ns1__get_USCOREhbfp1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfp1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbfp1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, "ns1:get_hbfp1Result", &a->get_USCOREhbfp1Result, ""))
				{	soap_flag_get_USCOREhbfp1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbfp1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfp1Response, 0, sizeof(struct _ns1__get_USCOREhbfp1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfp1Response(struct soap *soap, const struct _ns1__get_USCOREhbfp1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfp1Response);
	if (soap_out__ns1__get_USCOREhbfp1Response(soap, tag?tag:"ns1:get_hbfp1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfp1Response(struct soap *soap, struct _ns1__get_USCOREhbfp1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfp1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfp1(struct soap *soap, struct _ns1__get_USCOREhbfp1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfp1(struct soap *soap, const struct _ns1__get_USCOREhbfp1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfp1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfp1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1 * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1 *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfp1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfp1, sizeof(struct _ns1__get_USCOREhbfp1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfp1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfp1, 0, sizeof(struct _ns1__get_USCOREhbfp1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfp1(struct soap *soap, const struct _ns1__get_USCOREhbfp1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfp1);
	if (soap_out__ns1__get_USCOREhbfp1(soap, tag?tag:"ns1:get_hbfp1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1 * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfp1(struct soap *soap, struct _ns1__get_USCOREhbfp1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfp1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result, sizeof(struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result, 0, sizeof(struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result);
	if (soap_out__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag?tag:"ns1:hbtsf_update1Response-hbtsf_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbtsf_USCOREupdate1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, &a->hbtsf_USCOREupdate1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdate1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response), type))
		return soap->error;
	if (a->hbtsf_USCOREupdate1Result)
		soap_element_result(soap, "ns1:hbtsf_update1Result");
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, "ns1:hbtsf_update1Result", -1, &a->hbtsf_USCOREupdate1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1Response *a, const char *type)
{
	size_t soap_flag_hbtsf_USCOREupdate1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdate1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response, sizeof(struct _ns1__hbtsf_USCOREupdate1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdate1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbtsf_USCOREupdate1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, "ns1:hbtsf_update1Result", &a->hbtsf_USCOREupdate1Result, ""))
				{	soap_flag_hbtsf_USCOREupdate1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:hbtsf_update1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response, 0, sizeof(struct _ns1__hbtsf_USCOREupdate1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response);
	if (soap_out__ns1__hbtsf_USCOREupdate1Response(soap, tag?tag:"ns1:hbtsf_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdate1Response(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdate1(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdate1(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1 * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdate1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1, sizeof(struct _ns1__hbtsf_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdate1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdate1, 0, sizeof(struct _ns1__hbtsf_USCOREupdate1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdate1(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdate1);
	if (soap_out__ns1__hbtsf_USCOREupdate1(soap, tag?tag:"ns1:hbtsf_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1 * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdate1(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result, sizeof(struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result, 0, sizeof(struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result);
	if (soap_out__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag?tag:"ns1:hbwsh_update1Response-hbwsh_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbwsh_USCOREupdate1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, &a->hbwsh_USCOREupdate1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdate1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response), type))
		return soap->error;
	if (a->hbwsh_USCOREupdate1Result)
		soap_element_result(soap, "ns1:hbwsh_update1Result");
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, "ns1:hbwsh_update1Result", -1, &a->hbwsh_USCOREupdate1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1Response *a, const char *type)
{
	size_t soap_flag_hbwsh_USCOREupdate1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdate1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response, sizeof(struct _ns1__hbwsh_USCOREupdate1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdate1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbwsh_USCOREupdate1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, "ns1:hbwsh_update1Result", &a->hbwsh_USCOREupdate1Result, ""))
				{	soap_flag_hbwsh_USCOREupdate1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:hbwsh_update1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response, 0, sizeof(struct _ns1__hbwsh_USCOREupdate1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response);
	if (soap_out__ns1__hbwsh_USCOREupdate1Response(soap, tag?tag:"ns1:hbwsh_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdate1Response(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdate1(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->optid);
	soap_default_string(soap, &a->fs);
	soap_default_time(soap, &a->xzrq);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdate1(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->optid);
	soap_serialize_string(soap, &a->fs);
	soap_serialize_string(soap, &a->UserName);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdate1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:optid", -1, &a->optid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fs", -1, &a->fs, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:xzrq", -1, &a->xzrq, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UserName", -1, &a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1 * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1 *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_optid = 1;
	size_t soap_flag_fs = 1;
	size_t soap_flag_xzrq = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdate1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1, sizeof(struct _ns1__hbwsh_USCOREupdate1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdate1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_optid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:optid", &a->optid, "xsd:string"))
				{	soap_flag_optid--;
					continue;
				}
			if (soap_flag_fs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:fs", &a->fs, "xsd:string"))
				{	soap_flag_fs--;
					continue;
				}
			if (soap_flag_xzrq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:xzrq", &a->xzrq, "xsd:dateTime"))
				{	soap_flag_xzrq--;
					continue;
				}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UserName", &a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdate1, 0, sizeof(struct _ns1__hbwsh_USCOREupdate1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0 || soap_flag_xzrq > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdate1(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdate1);
	if (soap_out__ns1__hbwsh_USCOREupdate1(soap, tag?tag:"ns1:hbwsh_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1 * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdate1(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result, sizeof(struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result, 0, sizeof(struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result);
	if (soap_out__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag?tag:"ns1:get_mx1Response-get_mx1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmx1Response(struct soap *soap, struct _ns1__get_USCOREmx1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREmx1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmx1Response(struct soap *soap, const struct _ns1__get_USCOREmx1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, &a->get_USCOREmx1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmx1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmx1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmx1Response), type))
		return soap->error;
	if (a->get_USCOREmx1Result)
		soap_element_result(soap, "ns1:get_mx1Result");
	if (soap_out_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, "ns1:get_mx1Result", -1, &a->get_USCOREmx1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREmx1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREmx1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmx1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmx1Response, sizeof(struct _ns1__get_USCOREmx1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmx1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREmx1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, "ns1:get_mx1Result", &a->get_USCOREmx1Result, ""))
				{	soap_flag_get_USCOREmx1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_mx1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmx1Response, 0, sizeof(struct _ns1__get_USCOREmx1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmx1Response(struct soap *soap, const struct _ns1__get_USCOREmx1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmx1Response);
	if (soap_out__ns1__get_USCOREmx1Response(soap, tag?tag:"ns1:get_mx1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREmx1Response(struct soap *soap, struct _ns1__get_USCOREmx1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmx1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmx1(struct soap *soap, struct _ns1__get_USCOREmx1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
	soap_default_string(soap, &a->smdate1);
	soap_default_string(soap, &a->smdate2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmx1(struct soap *soap, const struct _ns1__get_USCOREmx1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
	soap_serialize_string(soap, &a->smdate1);
	soap_serialize_string(soap, &a->smdate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmx1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmx1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmx1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate1", -1, &a->smdate1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate2", -1, &a->smdate2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1 * SOAP_FMAC4 soap_in__ns1__get_USCOREmx1(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1 *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	size_t soap_flag_smdate1 = 1;
	size_t soap_flag_smdate2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmx1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmx1, sizeof(struct _ns1__get_USCOREmx1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmx1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap_flag_smdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate1", &a->smdate1, "xsd:string"))
				{	soap_flag_smdate1--;
					continue;
				}
			if (soap_flag_smdate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate2", &a->smdate2, "xsd:string"))
				{	soap_flag_smdate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmx1, 0, sizeof(struct _ns1__get_USCOREmx1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmx1(struct soap *soap, const struct _ns1__get_USCOREmx1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmx1);
	if (soap_out__ns1__get_USCOREmx1(soap, tag?tag:"ns1:get_mx1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1 * SOAP_FMAC4 soap_get__ns1__get_USCOREmx1(struct soap *soap, struct _ns1__get_USCOREmx1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmx1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result, sizeof(struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result, 0, sizeof(struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result);
	if (soap_out__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag?tag:"ns1:get_hbwsh1Response-get_hbwsh1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh1Response(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbwsh1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh1Response(struct soap *soap, const struct _ns1__get_USCOREhbwsh1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, &a->get_USCOREhbwsh1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response), type))
		return soap->error;
	if (a->get_USCOREhbwsh1Result)
		soap_element_result(soap, "ns1:get_hbwsh1Result");
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, "ns1:get_hbwsh1Result", -1, &a->get_USCOREhbwsh1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREhbwsh1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response, sizeof(struct _ns1__get_USCOREhbwsh1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbwsh1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, "ns1:get_hbwsh1Result", &a->get_USCOREhbwsh1Result, ""))
				{	soap_flag_get_USCOREhbwsh1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbwsh1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh1Response, 0, sizeof(struct _ns1__get_USCOREhbwsh1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh1Response(struct soap *soap, const struct _ns1__get_USCOREhbwsh1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh1Response);
	if (soap_out__ns1__get_USCOREhbwsh1Response(soap, tag?tag:"ns1:get_hbwsh1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh1Response(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh1(struct soap *soap, struct _ns1__get_USCOREhbwsh1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh1(struct soap *soap, const struct _ns1__get_USCOREhbwsh1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1 * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1 *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh1, sizeof(struct _ns1__get_USCOREhbwsh1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh1, 0, sizeof(struct _ns1__get_USCOREhbwsh1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh1(struct soap *soap, const struct _ns1__get_USCOREhbwsh1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh1);
	if (soap_out__ns1__get_USCOREhbwsh1(soap, tag?tag:"ns1:get_hbwsh1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1 * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh1(struct soap *soap, struct _ns1__get_USCOREhbwsh1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result, sizeof(struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result, 0, sizeof(struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result);
	if (soap_out__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag?tag:"ns1:get_hbgs1Response-get_hbgs1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgs1Response(struct soap *soap, struct _ns1__get_USCOREhbgs1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbgs1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgs1Response(struct soap *soap, const struct _ns1__get_USCOREhbgs1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, &a->get_USCOREhbgs1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgs1Response(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgs1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgs1Response), type))
		return soap->error;
	if (a->get_USCOREhbgs1Result)
		soap_element_result(soap, "ns1:get_hbgs1Result");
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, "ns1:get_hbgs1Result", -1, &a->get_USCOREhbgs1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgs1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1Response *a, const char *type)
{
	size_t soap_flag_get_USCOREhbgs1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgs1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgs1Response, sizeof(struct _ns1__get_USCOREhbgs1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgs1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbgs1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, "ns1:get_hbgs1Result", &a->get_USCOREhbgs1Result, ""))
				{	soap_flag_get_USCOREhbgs1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbgs1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgs1Response, 0, sizeof(struct _ns1__get_USCOREhbgs1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgs1Response(struct soap *soap, const struct _ns1__get_USCOREhbgs1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgs1Response);
	if (soap_out__ns1__get_USCOREhbgs1Response(soap, tag?tag:"ns1:get_hbgs1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgs1Response(struct soap *soap, struct _ns1__get_USCOREhbgs1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgs1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgs1(struct soap *soap, struct _ns1__get_USCOREhbgs1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->str);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgs1(struct soap *soap, const struct _ns1__get_USCOREhbgs1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->str);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgs1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgs1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:str", -1, &a->str, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1 * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1 *a, const char *type)
{
	size_t soap_flag_str = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgs1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgs1, sizeof(struct _ns1__get_USCOREhbgs1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgs1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_str && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:str", &a->str, "xsd:string"))
				{	soap_flag_str--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgs1, 0, sizeof(struct _ns1__get_USCOREhbgs1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgs1(struct soap *soap, const struct _ns1__get_USCOREhbgs1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgs1);
	if (soap_out__ns1__get_USCOREhbgs1(soap, tag?tag:"ns1:get_hbgs1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1 * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgs1(struct soap *soap, struct _ns1__get_USCOREhbgs1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgs1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, int id, const struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult * SOAP_FMAC4 soap_in__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult, 0, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult);
	if (soap_out__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag?tag:"ns1:fp_dy_endResponse-fp_dy_endResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult * SOAP_FMAC4 soap_get__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->fp_USCOREdy_USCOREendResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREendResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, &a->fp_USCOREdy_USCOREendResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, int id, const struct _ns1__fp_USCOREdy_USCOREendResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse), type))
		return soap->error;
	if (a->fp_USCOREdy_USCOREendResult)
		soap_element_result(soap, "ns1:fp_dy_endResult");
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, "ns1:fp_dy_endResult", -1, &a->fp_USCOREdy_USCOREendResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse * SOAP_FMAC4 soap_in__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREendResponse *a, const char *type)
{
	size_t soap_flag_fp_USCOREdy_USCOREendResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__fp_USCOREdy_USCOREendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__fp_USCOREdy_USCOREendResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fp_USCOREdy_USCOREendResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, "ns1:fp_dy_endResult", &a->fp_USCOREdy_USCOREendResult, ""))
				{	soap_flag_fp_USCOREdy_USCOREendResult--;
					continue;
				}
			soap_check_result(soap, "ns1:fp_dy_endResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse, 0, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREendResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse);
	if (soap_out__ns1__fp_USCOREdy_USCOREendResponse(soap, tag?tag:"ns1:fp_dy_endResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse * SOAP_FMAC4 soap_get__ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__fp_USCOREdy_USCOREendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__fp_USCOREdy_USCOREend(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREend *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, const struct _ns1__fp_USCOREdy_USCOREend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREend * SOAP_FMAC4 soap_in__ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREend *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__fp_USCOREdy_USCOREend *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend, sizeof(struct _ns1__fp_USCOREdy_USCOREend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__fp_USCOREdy_USCOREend(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREend *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend, 0, sizeof(struct _ns1__fp_USCOREdy_USCOREend), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__fp_USCOREdy_USCOREend(struct soap *soap, const struct _ns1__fp_USCOREdy_USCOREend *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend);
	if (soap_out__ns1__fp_USCOREdy_USCOREend(soap, tag?tag:"ns1:fp_dy_end", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREend * SOAP_FMAC4 soap_get__ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREend *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__fp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult * SOAP_FMAC4 soap_in__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult, sizeof(struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult, 0, sizeof(struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult);
	if (soap_out__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag?tag:"ns1:get_zbfpResponse-get_zbfpResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult * SOAP_FMAC4 soap_get__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzbfpResponse(struct soap *soap, struct _ns1__get_USCOREzbfpResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREzbfpResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzbfpResponse(struct soap *soap, const struct _ns1__get_USCOREzbfpResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, &a->get_USCOREzbfpResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzbfpResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzbfpResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzbfpResponse), type))
		return soap->error;
	if (a->get_USCOREzbfpResult)
		soap_element_result(soap, "ns1:get_zbfpResult");
	if (soap_out_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, "ns1:get_zbfpResult", -1, &a->get_USCOREzbfpResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREzbfpResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfpResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREzbfpResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzbfpResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzbfpResponse, sizeof(struct _ns1__get_USCOREzbfpResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzbfpResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREzbfpResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, "ns1:get_zbfpResult", &a->get_USCOREzbfpResult, ""))
				{	soap_flag_get_USCOREzbfpResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_zbfpResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzbfpResponse, 0, sizeof(struct _ns1__get_USCOREzbfpResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzbfpResponse(struct soap *soap, const struct _ns1__get_USCOREzbfpResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzbfpResponse);
	if (soap_out__ns1__get_USCOREzbfpResponse(soap, tag?tag:"ns1:get_zbfpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREzbfpResponse(struct soap *soap, struct _ns1__get_USCOREzbfpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzbfpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzbfp(struct soap *soap, struct _ns1__get_USCOREzbfp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzbfp(struct soap *soap, const struct _ns1__get_USCOREzbfp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzbfp(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzbfp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzbfp), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfp * SOAP_FMAC4 soap_in__ns1__get_USCOREzbfp(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfp *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzbfp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzbfp, sizeof(struct _ns1__get_USCOREzbfp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzbfp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzbfp, 0, sizeof(struct _ns1__get_USCOREzbfp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzbfp(struct soap *soap, const struct _ns1__get_USCOREzbfp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzbfp);
	if (soap_out__ns1__get_USCOREzbfp(soap, tag?tag:"ns1:get_zbfp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfp * SOAP_FMAC4 soap_get__ns1__get_USCOREzbfp(struct soap *soap, struct _ns1__get_USCOREzbfp *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult);
	if (soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag?tag:"ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ZB_USCORETZ_USCOREMonthResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, &a->ZB_USCORETZ_USCOREMonthResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse), type))
		return soap->error;
	if (a->ZB_USCORETZ_USCOREMonthResult)
		soap_element_result(soap, "ns1:ZB_TZ_MonthResult");
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, "ns1:ZB_TZ_MonthResult", -1, &a->ZB_USCORETZ_USCOREMonthResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *a, const char *type)
{
	size_t soap_flag_ZB_USCORETZ_USCOREMonthResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZB_USCORETZ_USCOREMonthResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, "ns1:ZB_TZ_MonthResult", &a->ZB_USCORETZ_USCOREMonthResult, ""))
				{	soap_flag_ZB_USCORETZ_USCOREMonthResult--;
					continue;
				}
			soap_check_result(soap, "ns1:ZB_TZ_MonthResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonthResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse);
	if (soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag?tag:"ns1:ZB_TZ_MonthResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->Base64);
	soap_default_string(soap, &a->Base64_USCORESHA1);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonth *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->Base64);
	soap_serialize_string(soap, &a->Base64_USCORESHA1);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREMonth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64", -1, &a->Base64, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64_SHA1", -1, &a->Base64_USCORESHA1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonth * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonth *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_Base64 = 1;
	size_t soap_flag_Base64_USCORESHA1 = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREMonth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREMonth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_Base64 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64", &a->Base64, "xsd:string"))
				{	soap_flag_Base64--;
					continue;
				}
			if (soap_flag_Base64_USCORESHA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64_SHA1", &a->Base64_USCORESHA1, "xsd:string"))
				{	soap_flag_Base64_USCORESHA1--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREMonth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth);
	if (soap_out__ns1__ZB_USCORETZ_USCOREMonth(soap, tag?tag:"ns1:ZB_TZ_Month", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonth * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonth *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult);
	if (soap_out__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag?tag:"ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ZB_USCORETZ_USCOREDayResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDayResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, &a->ZB_USCORETZ_USCOREDayResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREDayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse), type))
		return soap->error;
	if (a->ZB_USCORETZ_USCOREDayResult)
		soap_element_result(soap, "ns1:ZB_TZ_DayResult");
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, "ns1:ZB_TZ_DayResult", -1, &a->ZB_USCORETZ_USCOREDayResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDayResponse *a, const char *type)
{
	size_t soap_flag_ZB_USCORETZ_USCOREDayResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREDayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZB_USCORETZ_USCOREDayResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, "ns1:ZB_TZ_DayResult", &a->ZB_USCORETZ_USCOREDayResult, ""))
				{	soap_flag_ZB_USCORETZ_USCOREDayResult--;
					continue;
				}
			soap_check_result(soap, "ns1:ZB_TZ_DayResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse);
	if (soap_out__ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag?tag:"ns1:ZB_TZ_DayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->Base64);
	soap_default_string(soap, &a->Base64_USCORESHA1);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDay *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->Base64);
	soap_serialize_string(soap, &a->Base64_USCORESHA1);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, int id, const struct _ns1__ZB_USCORETZ_USCOREDay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64", -1, &a->Base64, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64_SHA1", -1, &a->Base64_USCORESHA1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDay * SOAP_FMAC4 soap_in__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDay *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_Base64 = 1;
	size_t soap_flag_Base64_USCORESHA1 = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ZB_USCORETZ_USCOREDay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay, sizeof(struct _ns1__ZB_USCORETZ_USCOREDay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ZB_USCORETZ_USCOREDay(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_Base64 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64", &a->Base64, "xsd:string"))
				{	soap_flag_Base64--;
					continue;
				}
			if (soap_flag_Base64_USCORESHA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64_SHA1", &a->Base64_USCORESHA1, "xsd:string"))
				{	soap_flag_Base64_USCORESHA1--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay, 0, sizeof(struct _ns1__ZB_USCORETZ_USCOREDay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const struct _ns1__ZB_USCORETZ_USCOREDay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay);
	if (soap_out__ns1__ZB_USCORETZ_USCOREDay(soap, tag?tag:"ns1:ZB_TZ_Day", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDay * SOAP_FMAC4 soap_get__ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDay *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ZB_USCORETZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult, sizeof(struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult, 0, sizeof(struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult);
	if (soap_out__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag?tag:"ns1:tsf_updateResponse-tsf_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__tsf_USCOREupdateResponse(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tsf_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__tsf_USCOREupdateResponse(struct soap *soap, const struct _ns1__tsf_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, &a->tsf_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__tsf_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__tsf_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse), type))
		return soap->error;
	if (a->tsf_USCOREupdateResult)
		soap_element_result(soap, "ns1:tsf_updateResult");
	if (soap_out_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, "ns1:tsf_updateResult", -1, &a->tsf_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__tsf_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_tsf_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__tsf_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse, sizeof(struct _ns1__tsf_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__tsf_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tsf_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, "ns1:tsf_updateResult", &a->tsf_USCOREupdateResult, ""))
				{	soap_flag_tsf_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:tsf_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__tsf_USCOREupdateResponse, 0, sizeof(struct _ns1__tsf_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__tsf_USCOREupdateResponse(struct soap *soap, const struct _ns1__tsf_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__tsf_USCOREupdateResponse);
	if (soap_out__ns1__tsf_USCOREupdateResponse(soap, tag?tag:"ns1:tsf_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__tsf_USCOREupdateResponse(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__tsf_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__tsf_USCOREupdate(struct soap *soap, struct _ns1__tsf_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__tsf_USCOREupdate(struct soap *soap, const struct _ns1__tsf_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__tsf_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__tsf_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdate * SOAP_FMAC4 soap_in__ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__tsf_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__tsf_USCOREupdate, sizeof(struct _ns1__tsf_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__tsf_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__tsf_USCOREupdate, 0, sizeof(struct _ns1__tsf_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__tsf_USCOREupdate(struct soap *soap, const struct _ns1__tsf_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__tsf_USCOREupdate);
	if (soap_out__ns1__tsf_USCOREupdate(soap, tag?tag:"ns1:tsf_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdate * SOAP_FMAC4 soap_get__ns1__tsf_USCOREupdate(struct soap *soap, struct _ns1__tsf_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__tsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult, sizeof(struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult, 0, sizeof(struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult);
	if (soap_out__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag?tag:"ns1:wsh_updateResponse-wsh_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__wsh_USCOREupdateResponse(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsh_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__wsh_USCOREupdateResponse(struct soap *soap, const struct _ns1__wsh_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, &a->wsh_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__wsh_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__wsh_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse), type))
		return soap->error;
	if (a->wsh_USCOREupdateResult)
		soap_element_result(soap, "ns1:wsh_updateResult");
	if (soap_out_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, "ns1:wsh_updateResult", -1, &a->wsh_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__wsh_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_wsh_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__wsh_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse, sizeof(struct _ns1__wsh_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__wsh_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsh_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, "ns1:wsh_updateResult", &a->wsh_USCOREupdateResult, ""))
				{	soap_flag_wsh_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:wsh_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__wsh_USCOREupdateResponse, 0, sizeof(struct _ns1__wsh_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__wsh_USCOREupdateResponse(struct soap *soap, const struct _ns1__wsh_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__wsh_USCOREupdateResponse);
	if (soap_out__ns1__wsh_USCOREupdateResponse(soap, tag?tag:"ns1:wsh_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__wsh_USCOREupdateResponse(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__wsh_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__wsh_USCOREupdate(struct soap *soap, struct _ns1__wsh_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->optid);
	soap_default_string(soap, &a->fs);
	soap_default_time(soap, &a->xzrq);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__wsh_USCOREupdate(struct soap *soap, const struct _ns1__wsh_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->optid);
	soap_serialize_string(soap, &a->fs);
	soap_serialize_string(soap, &a->UserName);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__wsh_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__wsh_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:optid", -1, &a->optid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fs", -1, &a->fs, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:xzrq", -1, &a->xzrq, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UserName", -1, &a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdate * SOAP_FMAC4 soap_in__ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_optid = 1;
	size_t soap_flag_fs = 1;
	size_t soap_flag_xzrq = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__wsh_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__wsh_USCOREupdate, sizeof(struct _ns1__wsh_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__wsh_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_optid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:optid", &a->optid, "xsd:string"))
				{	soap_flag_optid--;
					continue;
				}
			if (soap_flag_fs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:fs", &a->fs, "xsd:string"))
				{	soap_flag_fs--;
					continue;
				}
			if (soap_flag_xzrq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:xzrq", &a->xzrq, "xsd:dateTime"))
				{	soap_flag_xzrq--;
					continue;
				}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UserName", &a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__wsh_USCOREupdate, 0, sizeof(struct _ns1__wsh_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0 || soap_flag_xzrq > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__wsh_USCOREupdate(struct soap *soap, const struct _ns1__wsh_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__wsh_USCOREupdate);
	if (soap_out__ns1__wsh_USCOREupdate(soap, tag?tag:"ns1:wsh_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdate * SOAP_FMAC4 soap_get__ns1__wsh_USCOREupdate(struct soap *soap, struct _ns1__wsh_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__wsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult * SOAP_FMAC4 soap_in__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult, 0, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult);
	if (soap_out__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag?tag:"ns1:get_zb_mxResponse-get_zb_mxResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult * SOAP_FMAC4 soap_get__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREzb_USCOREmxResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmxResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, &a->get_USCOREzb_USCOREmxResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzb_USCOREmxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse), type))
		return soap->error;
	if (a->get_USCOREzb_USCOREmxResult)
		soap_element_result(soap, "ns1:get_zb_mxResult");
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, "ns1:get_zb_mxResult", -1, &a->get_USCOREzb_USCOREmxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmxResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREzb_USCOREmxResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzb_USCOREmxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzb_USCOREmxResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREzb_USCOREmxResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, "ns1:get_zb_mxResult", &a->get_USCOREzb_USCOREmxResult, ""))
				{	soap_flag_get_USCOREzb_USCOREmxResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_zb_mxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse, 0, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmxResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse);
	if (soap_out__ns1__get_USCOREzb_USCOREmxResponse(soap, tag?tag:"ns1:get_zb_mxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzb_USCOREmxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
	soap_default_string(soap, &a->smdate1);
	soap_default_string(soap, &a->smdate2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREzb_USCOREmx(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmx *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
	soap_serialize_string(soap, &a->smdate1);
	soap_serialize_string(soap, &a->smdate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREzb_USCOREmx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate1", -1, &a->smdate1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate2", -1, &a->smdate2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmx * SOAP_FMAC4 soap_in__ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmx *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	size_t soap_flag_smdate1 = 1;
	size_t soap_flag_smdate2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREzb_USCOREmx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx, sizeof(struct _ns1__get_USCOREzb_USCOREmx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREzb_USCOREmx(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap_flag_smdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate1", &a->smdate1, "xsd:string"))
				{	soap_flag_smdate1--;
					continue;
				}
			if (soap_flag_smdate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate2", &a->smdate2, "xsd:string"))
				{	soap_flag_smdate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx, 0, sizeof(struct _ns1__get_USCOREzb_USCOREmx), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREzb_USCOREmx(struct soap *soap, const struct _ns1__get_USCOREzb_USCOREmx *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx);
	if (soap_out__ns1__get_USCOREzb_USCOREmx(soap, tag?tag:"ns1:get_zb_mx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmx * SOAP_FMAC4 soap_get__ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREzb_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse_get_USCOREwshResult * SOAP_FMAC4 soap_in__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult, sizeof(struct _ns1__get_USCOREwshResponse_get_USCOREwshResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult, 0, sizeof(struct _ns1__get_USCOREwshResponse_get_USCOREwshResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult);
	if (soap_out__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag?tag:"ns1:get_wshResponse-get_wshResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse_get_USCOREwshResult * SOAP_FMAC4 soap_get__ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREwshResponse(struct soap *soap, struct _ns1__get_USCOREwshResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREwshResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREwshResponse(struct soap *soap, const struct _ns1__get_USCOREwshResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, &a->get_USCOREwshResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREwshResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREwshResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREwshResponse), type))
		return soap->error;
	if (a->get_USCOREwshResult)
		soap_element_result(soap, "ns1:get_wshResult");
	if (soap_out_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, "ns1:get_wshResult", -1, &a->get_USCOREwshResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREwshResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREwshResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREwshResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREwshResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREwshResponse, sizeof(struct _ns1__get_USCOREwshResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREwshResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREwshResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, "ns1:get_wshResult", &a->get_USCOREwshResult, ""))
				{	soap_flag_get_USCOREwshResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_wshResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREwshResponse, 0, sizeof(struct _ns1__get_USCOREwshResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREwshResponse(struct soap *soap, const struct _ns1__get_USCOREwshResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREwshResponse);
	if (soap_out__ns1__get_USCOREwshResponse(soap, tag?tag:"ns1:get_wshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREwshResponse(struct soap *soap, struct _ns1__get_USCOREwshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREwshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREwsh(struct soap *soap, struct _ns1__get_USCOREwsh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREwsh(struct soap *soap, const struct _ns1__get_USCOREwsh *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREwsh(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREwsh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREwsh), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREwsh * SOAP_FMAC4 soap_in__ns1__get_USCOREwsh(struct soap *soap, const char *tag, struct _ns1__get_USCOREwsh *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREwsh *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREwsh, sizeof(struct _ns1__get_USCOREwsh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREwsh(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwsh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREwsh, 0, sizeof(struct _ns1__get_USCOREwsh), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREwsh(struct soap *soap, const struct _ns1__get_USCOREwsh *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREwsh);
	if (soap_out__ns1__get_USCOREwsh(soap, tag?tag:"ns1:get_wsh", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwsh * SOAP_FMAC4 soap_get__ns1__get_USCOREwsh(struct soap *soap, struct _ns1__get_USCOREwsh *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag?tag:"ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hb_USCOREfp_USCOREdy_USCOREendResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, &a->hb_USCOREfp_USCOREdy_USCOREendResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse), type))
		return soap->error;
	if (a->hb_USCOREfp_USCOREdy_USCOREendResult)
		soap_element_result(soap, "ns1:hb_fp_dy_endResult");
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, "ns1:hb_fp_dy_endResult", -1, &a->hb_USCOREfp_USCOREdy_USCOREendResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *a, const char *type)
{
	size_t soap_flag_hb_USCOREfp_USCOREdy_USCOREendResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hb_USCOREfp_USCOREdy_USCOREendResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, "ns1:hb_fp_dy_endResult", &a->hb_USCOREfp_USCOREdy_USCOREendResult, ""))
				{	soap_flag_hb_USCOREfp_USCOREdy_USCOREendResult--;
					continue;
				}
			soap_check_result(soap, "ns1:hb_fp_dy_endResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag?tag:"ns1:hb_fp_dy_endResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend * SOAP_FMAC4 soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend, 0, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend);
	if (soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag?tag:"ns1:hb_fp_dy_end", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend * SOAP_FMAC4 soap_get__ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult, 0, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult);
	if (soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag?tag:"ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbtsf_USCOREyue_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, &a->hbtsf_USCOREyue_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse), type))
		return soap->error;
	if (a->hbtsf_USCOREyue_USCOREupdateResult)
		soap_element_result(soap, "ns1:hbtsf_yue_updateResult");
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, "ns1:hbtsf_yue_updateResult", -1, &a->hbtsf_USCOREyue_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_hbtsf_USCOREyue_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbtsf_USCOREyue_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, "ns1:hbtsf_yue_updateResult", &a->hbtsf_USCOREyue_USCOREupdateResult, ""))
				{	soap_flag_hbtsf_USCOREyue_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:hbtsf_yue_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse, 0, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse);
	if (soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag?tag:"ns1:hbtsf_yue_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREyue_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate, 0, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const struct _ns1__hbtsf_USCOREyue_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate);
	if (soap_out__ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag?tag:"ns1:hbtsf_yue_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult, 0, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult);
	if (soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag?tag:"ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbwsh_USCOREyue_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, &a->hbwsh_USCOREyue_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse), type))
		return soap->error;
	if (a->hbwsh_USCOREyue_USCOREupdateResult)
		soap_element_result(soap, "ns1:hbwsh_yue_updateResult");
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, "ns1:hbwsh_yue_updateResult", -1, &a->hbwsh_USCOREyue_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_hbwsh_USCOREyue_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbwsh_USCOREyue_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, "ns1:hbwsh_yue_updateResult", &a->hbwsh_USCOREyue_USCOREupdateResult, ""))
				{	soap_flag_hbwsh_USCOREyue_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:hbwsh_yue_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse, 0, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse);
	if (soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag?tag:"ns1:hbwsh_yue_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->optid);
	soap_default_string(soap, &a->fs);
	soap_default_time(soap, &a->xzrq);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->yyzd);
	soap_default_string(soap, &a->dzid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->optid);
	soap_serialize_string(soap, &a->fs);
	soap_serialize_string(soap, &a->UserName);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->yyzd);
	soap_serialize_string(soap, &a->dzid);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:optid", -1, &a->optid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fs", -1, &a->fs, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:xzrq", -1, &a->xzrq, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UserName", -1, &a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dzid", -1, &a->dzid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_optid = 1;
	size_t soap_flag_fs = 1;
	size_t soap_flag_xzrq = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_yyzd = 1;
	size_t soap_flag_dzid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREyue_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_optid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:optid", &a->optid, "xsd:string"))
				{	soap_flag_optid--;
					continue;
				}
			if (soap_flag_fs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:fs", &a->fs, "xsd:string"))
				{	soap_flag_fs--;
					continue;
				}
			if (soap_flag_xzrq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:xzrq", &a->xzrq, "xsd:dateTime"))
				{	soap_flag_xzrq--;
					continue;
				}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UserName", &a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap_flag_dzid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:dzid", &a->dzid, "xsd:string"))
				{	soap_flag_dzid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate, 0, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0 || soap_flag_xzrq > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const struct _ns1__hbwsh_USCOREyue_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate);
	if (soap_out__ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag?tag:"ns1:hbwsh_yue_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdate * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse_get_USCOREyueResult * SOAP_FMAC4 soap_in__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult, sizeof(struct _ns1__get_USCOREyueResponse_get_USCOREyueResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult, 0, sizeof(struct _ns1__get_USCOREyueResponse_get_USCOREyueResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult);
	if (soap_out__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag?tag:"ns1:get_yueResponse-get_yueResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse_get_USCOREyueResult * SOAP_FMAC4 soap_get__ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREyueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREyueResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyueResponse(struct soap *soap, const struct _ns1__get_USCOREyueResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, &a->get_USCOREyueResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyueResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyueResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyueResponse), type))
		return soap->error;
	if (a->get_USCOREyueResult)
		soap_element_result(soap, "ns1:get_yueResult");
	if (soap_out_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, "ns1:get_yueResult", -1, &a->get_USCOREyueResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREyueResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREyueResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREyueResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyueResponse, sizeof(struct _ns1__get_USCOREyueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREyueResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, "ns1:get_yueResult", &a->get_USCOREyueResult, ""))
				{	soap_flag_get_USCOREyueResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_yueResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyueResponse, 0, sizeof(struct _ns1__get_USCOREyueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyueResponse(struct soap *soap, const struct _ns1__get_USCOREyueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyueResponse);
	if (soap_out__ns1__get_USCOREyueResponse(soap, tag?tag:"ns1:get_yueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREyueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyue(struct soap *soap, struct _ns1__get_USCOREyue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyue(struct soap *soap, const struct _ns1__get_USCOREyue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyue(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyue), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue * SOAP_FMAC4 soap_in__ns1__get_USCOREyue(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyue, sizeof(struct _ns1__get_USCOREyue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyue, 0, sizeof(struct _ns1__get_USCOREyue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyue(struct soap *soap, const struct _ns1__get_USCOREyue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyue);
	if (soap_out__ns1__get_USCOREyue(soap, tag?tag:"ns1:get_yue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue * SOAP_FMAC4 soap_get__ns1__get_USCOREyue(struct soap *soap, struct _ns1__get_USCOREyue *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult, 0, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult);
	if (soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag?tag:"ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbwsh_USCOREyueResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, &a->get_USCOREhbwsh_USCOREyueResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse), type))
		return soap->error;
	if (a->get_USCOREhbwsh_USCOREyueResult)
		soap_element_result(soap, "ns1:get_hbwsh_yueResult");
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, "ns1:get_hbwsh_yueResult", -1, &a->get_USCOREhbwsh_USCOREyueResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREhbwsh_USCOREyueResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbwsh_USCOREyueResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, "ns1:get_hbwsh_yueResult", &a->get_USCOREhbwsh_USCOREyueResult, ""))
				{	soap_flag_get_USCOREhbwsh_USCOREyueResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbwsh_yueResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse, 0, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse);
	if (soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag?tag:"ns1:get_hbwsh_yueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh_USCOREyue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyue * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyue *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh_USCOREyue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh_USCOREyue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue, 0, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const struct _ns1__get_USCOREhbwsh_USCOREyue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue);
	if (soap_out__ns1__get_USCOREhbwsh_USCOREyue(soap, tag?tag:"ns1:get_hbwsh_yue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyue * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyue *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult, sizeof(struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult, 0, sizeof(struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult);
	if (soap_out__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag?tag:"ns1:get_yyzdResponse-get_yyzdResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzdResponse(struct soap *soap, struct _ns1__get_USCOREyyzdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREyyzdResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzdResponse(struct soap *soap, const struct _ns1__get_USCOREyyzdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, &a->get_USCOREyyzdResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzdResponse), type))
		return soap->error;
	if (a->get_USCOREyyzdResult)
		soap_element_result(soap, "ns1:get_yyzdResult");
	if (soap_out_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, "ns1:get_yyzdResult", -1, &a->get_USCOREyyzdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzdResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzdResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREyyzdResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzdResponse, sizeof(struct _ns1__get_USCOREyyzdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREyyzdResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, "ns1:get_yyzdResult", &a->get_USCOREyyzdResult, ""))
				{	soap_flag_get_USCOREyyzdResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_yyzdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzdResponse, 0, sizeof(struct _ns1__get_USCOREyyzdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzdResponse(struct soap *soap, const struct _ns1__get_USCOREyyzdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzdResponse);
	if (soap_out__ns1__get_USCOREyyzdResponse(soap, tag?tag:"ns1:get_yyzdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzdResponse(struct soap *soap, struct _ns1__get_USCOREyyzdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREyyzd(struct soap *soap, struct _ns1__get_USCOREyyzd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREyyzd(struct soap *soap, const struct _ns1__get_USCOREyyzd *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREyyzd(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREyyzd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREyyzd), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd * SOAP_FMAC4 soap_in__ns1__get_USCOREyyzd(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREyyzd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREyyzd, sizeof(struct _ns1__get_USCOREyyzd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREyyzd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREyyzd, 0, sizeof(struct _ns1__get_USCOREyyzd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREyyzd(struct soap *soap, const struct _ns1__get_USCOREyyzd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREyyzd);
	if (soap_out__ns1__get_USCOREyyzd(soap, tag?tag:"ns1:get_yyzd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd * SOAP_FMAC4 soap_get__ns1__get_USCOREyyzd(struct soap *soap, struct _ns1__get_USCOREyyzd *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREyyzd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult, sizeof(struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult, 0, sizeof(struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult);
	if (soap_out__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag?tag:"ns1:get_hbfpResponse-get_hbfpResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfpResponse(struct soap *soap, struct _ns1__get_USCOREhbfpResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbfpResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfpResponse(struct soap *soap, const struct _ns1__get_USCOREhbfpResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, &a->get_USCOREhbfpResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfpResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfpResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfpResponse), type))
		return soap->error;
	if (a->get_USCOREhbfpResult)
		soap_element_result(soap, "ns1:get_hbfpResult");
	if (soap_out_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, "ns1:get_hbfpResult", -1, &a->get_USCOREhbfpResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfpResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfpResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREhbfpResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfpResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfpResponse, sizeof(struct _ns1__get_USCOREhbfpResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfpResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbfpResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, "ns1:get_hbfpResult", &a->get_USCOREhbfpResult, ""))
				{	soap_flag_get_USCOREhbfpResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbfpResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfpResponse, 0, sizeof(struct _ns1__get_USCOREhbfpResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfpResponse(struct soap *soap, const struct _ns1__get_USCOREhbfpResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfpResponse);
	if (soap_out__ns1__get_USCOREhbfpResponse(soap, tag?tag:"ns1:get_hbfpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfpResponse(struct soap *soap, struct _ns1__get_USCOREhbfpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbfp(struct soap *soap, struct _ns1__get_USCOREhbfp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbfp(struct soap *soap, const struct _ns1__get_USCOREhbfp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbfp(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbfp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbfp), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp * SOAP_FMAC4 soap_in__ns1__get_USCOREhbfp(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbfp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbfp, sizeof(struct _ns1__get_USCOREhbfp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbfp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbfp, 0, sizeof(struct _ns1__get_USCOREhbfp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbfp(struct soap *soap, const struct _ns1__get_USCOREhbfp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbfp);
	if (soap_out__ns1__get_USCOREhbfp(soap, tag?tag:"ns1:get_hbfp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp * SOAP_FMAC4 soap_get__ns1__get_USCOREhbfp(struct soap *soap, struct _ns1__get_USCOREhbfp *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult, 0, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult);
	if (soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag?tag:"ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->m_USCOREzb_USCOREtz_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, &a->m_USCOREzb_USCOREtz_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse), type))
		return soap->error;
	if (a->m_USCOREzb_USCOREtz_USCOREupdateResult)
		soap_element_result(soap, "ns1:m_zb_tz_updateResult");
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, "ns1:m_zb_tz_updateResult", -1, &a->m_USCOREzb_USCOREtz_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_m_USCOREzb_USCOREtz_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_USCOREzb_USCOREtz_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, "ns1:m_zb_tz_updateResult", &a->m_USCOREzb_USCOREtz_USCOREupdateResult, ""))
				{	soap_flag_m_USCOREzb_USCOREtz_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:m_zb_tz_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse, 0, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse);
	if (soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag?tag:"ns1:m_zb_tz_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate, 0, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate);
	if (soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag?tag:"ns1:m_zb_tz_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_get__ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult);
	if (soap_out__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag?tag:"ns1:m_tz_updateResponse-m_tz_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->m_USCOREtz_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, &a->m_USCOREtz_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse), type))
		return soap->error;
	if (a->m_USCOREtz_USCOREupdateResult)
		soap_element_result(soap, "ns1:m_tz_updateResult");
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, "ns1:m_tz_updateResult", -1, &a->m_USCOREtz_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_m_USCOREtz_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_USCOREtz_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, "ns1:m_tz_updateResult", &a->m_USCOREtz_USCOREupdateResult, ""))
				{	soap_flag_m_USCOREtz_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:m_tz_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse);
	if (soap_out__ns1__m_USCOREtz_USCOREupdateResponse(soap, tag?tag:"ns1:m_tz_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__m_USCOREtz_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_in__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__m_USCOREtz_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate, sizeof(struct _ns1__m_USCOREtz_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__m_USCOREtz_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate, 0, sizeof(struct _ns1__m_USCOREtz_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const struct _ns1__m_USCOREtz_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate);
	if (soap_out__ns1__m_USCOREtz_USCOREupdate(soap, tag?tag:"ns1:m_tz_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate * SOAP_FMAC4 soap_get__ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__m_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult * SOAP_FMAC4 soap_in__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult, sizeof(struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult, 0, sizeof(struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult);
	if (soap_out__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag?tag:"ns1:TZ_MonthResponse-TZ_MonthResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult * SOAP_FMAC4 soap_get__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREMonthResponse(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TZ_USCOREMonthResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREMonthResponse(struct soap *soap, const struct _ns1__TZ_USCOREMonthResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, &a->TZ_USCOREMonthResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREMonthResponse(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREMonthResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse), type))
		return soap->error;
	if (a->TZ_USCOREMonthResult)
		soap_element_result(soap, "ns1:TZ_MonthResult");
	if (soap_out_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, "ns1:TZ_MonthResult", -1, &a->TZ_USCOREMonthResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse * SOAP_FMAC4 soap_in__ns1__TZ_USCOREMonthResponse(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonthResponse *a, const char *type)
{
	size_t soap_flag_TZ_USCOREMonthResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREMonthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse, sizeof(struct _ns1__TZ_USCOREMonthResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREMonthResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ_USCOREMonthResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, "ns1:TZ_MonthResult", &a->TZ_USCOREMonthResult, ""))
				{	soap_flag_TZ_USCOREMonthResult--;
					continue;
				}
			soap_check_result(soap, "ns1:TZ_MonthResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREMonthResponse, 0, sizeof(struct _ns1__TZ_USCOREMonthResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREMonthResponse(struct soap *soap, const struct _ns1__TZ_USCOREMonthResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREMonthResponse);
	if (soap_out__ns1__TZ_USCOREMonthResponse(soap, tag?tag:"ns1:TZ_MonthResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse * SOAP_FMAC4 soap_get__ns1__TZ_USCOREMonthResponse(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREMonth(struct soap *soap, struct _ns1__TZ_USCOREMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->Base64);
	soap_default_string(soap, &a->Base64_USCORESHA1);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREMonth(struct soap *soap, const struct _ns1__TZ_USCOREMonth *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->Base64);
	soap_serialize_string(soap, &a->Base64_USCORESHA1);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREMonth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREMonth), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64", -1, &a->Base64, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64_SHA1", -1, &a->Base64_USCORESHA1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonth * SOAP_FMAC4 soap_in__ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonth *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_Base64 = 1;
	size_t soap_flag_Base64_USCORESHA1 = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREMonth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREMonth, sizeof(struct _ns1__TZ_USCOREMonth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREMonth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_Base64 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64", &a->Base64, "xsd:string"))
				{	soap_flag_Base64--;
					continue;
				}
			if (soap_flag_Base64_USCORESHA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64_SHA1", &a->Base64_USCORESHA1, "xsd:string"))
				{	soap_flag_Base64_USCORESHA1--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREMonth, 0, sizeof(struct _ns1__TZ_USCOREMonth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREMonth(struct soap *soap, const struct _ns1__TZ_USCOREMonth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREMonth);
	if (soap_out__ns1__TZ_USCOREMonth(soap, tag?tag:"ns1:TZ_Month", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonth * SOAP_FMAC4 soap_get__ns1__TZ_USCOREMonth(struct soap *soap, struct _ns1__TZ_USCOREMonth *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult, sizeof(struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult, 0, sizeof(struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult);
	if (soap_out__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag?tag:"ns1:TZ_DayResponse-TZ_DayResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDayResponse(struct soap *soap, struct _ns1__TZ_USCOREDayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TZ_USCOREDayResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDayResponse(struct soap *soap, const struct _ns1__TZ_USCOREDayResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, &a->TZ_USCOREDayResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDayResponse(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDayResponse), type))
		return soap->error;
	if (a->TZ_USCOREDayResult)
		soap_element_result(soap, "ns1:TZ_DayResult");
	if (soap_out_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, "ns1:TZ_DayResult", -1, &a->TZ_USCOREDayResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDayResponse(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDayResponse *a, const char *type)
{
	size_t soap_flag_TZ_USCOREDayResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDayResponse, sizeof(struct _ns1__TZ_USCOREDayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ_USCOREDayResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, "ns1:TZ_DayResult", &a->TZ_USCOREDayResult, ""))
				{	soap_flag_TZ_USCOREDayResult--;
					continue;
				}
			soap_check_result(soap, "ns1:TZ_DayResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDayResponse, 0, sizeof(struct _ns1__TZ_USCOREDayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDayResponse(struct soap *soap, const struct _ns1__TZ_USCOREDayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDayResponse);
	if (soap_out__ns1__TZ_USCOREDayResponse(soap, tag?tag:"ns1:TZ_DayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDayResponse(struct soap *soap, struct _ns1__TZ_USCOREDayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TZ_USCOREDay(struct soap *soap, struct _ns1__TZ_USCOREDay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smdate);
	soap_default_string(soap, &a->Base64);
	soap_default_string(soap, &a->Base64_USCORESHA1);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TZ_USCOREDay(struct soap *soap, const struct _ns1__TZ_USCOREDay *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smdate);
	soap_serialize_string(soap, &a->Base64);
	soap_serialize_string(soap, &a->Base64_USCORESHA1);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TZ_USCOREDay(struct soap *soap, const char *tag, int id, const struct _ns1__TZ_USCOREDay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TZ_USCOREDay), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate", -1, &a->smdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64", -1, &a->Base64, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Base64_SHA1", -1, &a->Base64_USCORESHA1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay * SOAP_FMAC4 soap_in__ns1__TZ_USCOREDay(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay *a, const char *type)
{
	size_t soap_flag_smdate = 1;
	size_t soap_flag_Base64 = 1;
	size_t soap_flag_Base64_USCORESHA1 = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TZ_USCOREDay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TZ_USCOREDay, sizeof(struct _ns1__TZ_USCOREDay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TZ_USCOREDay(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate", &a->smdate, "xsd:string"))
				{	soap_flag_smdate--;
					continue;
				}
			if (soap_flag_Base64 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64", &a->Base64, "xsd:string"))
				{	soap_flag_Base64--;
					continue;
				}
			if (soap_flag_Base64_USCORESHA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Base64_SHA1", &a->Base64_USCORESHA1, "xsd:string"))
				{	soap_flag_Base64_USCORESHA1--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TZ_USCOREDay, 0, sizeof(struct _ns1__TZ_USCOREDay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TZ_USCOREDay(struct soap *soap, const struct _ns1__TZ_USCOREDay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TZ_USCOREDay);
	if (soap_out__ns1__TZ_USCOREDay(soap, tag?tag:"ns1:TZ_Day", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay * SOAP_FMAC4 soap_get__ns1__TZ_USCOREDay(struct soap *soap, struct _ns1__TZ_USCOREDay *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult, sizeof(struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult, 0, sizeof(struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult);
	if (soap_out__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag?tag:"ns1:hbtsf_updateResponse-hbtsf_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbtsf_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbtsf_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, &a->hbtsf_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse), type))
		return soap->error;
	if (a->hbtsf_USCOREupdateResult)
		soap_element_result(soap, "ns1:hbtsf_updateResult");
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, "ns1:hbtsf_updateResult", -1, &a->hbtsf_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_hbtsf_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse, sizeof(struct _ns1__hbtsf_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbtsf_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, "ns1:hbtsf_updateResult", &a->hbtsf_USCOREupdateResult, ""))
				{	soap_flag_hbtsf_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:hbtsf_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse, 0, sizeof(struct _ns1__hbtsf_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbtsf_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse);
	if (soap_out__ns1__hbtsf_USCOREupdateResponse(soap, tag?tag:"ns1:hbtsf_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbtsf_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbtsf_USCOREupdate(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__hbtsf_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate * SOAP_FMAC4 soap_in__ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbtsf_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbtsf_USCOREupdate, sizeof(struct _ns1__hbtsf_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbtsf_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbtsf_USCOREupdate, 0, sizeof(struct _ns1__hbtsf_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbtsf_USCOREupdate(struct soap *soap, const struct _ns1__hbtsf_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbtsf_USCOREupdate);
	if (soap_out__ns1__hbtsf_USCOREupdate(soap, tag?tag:"ns1:hbtsf_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate * SOAP_FMAC4 soap_get__ns1__hbtsf_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbtsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult, sizeof(struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult, 0, sizeof(struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult);
	if (soap_out__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag?tag:"ns1:hbwsh_updateResponse-hbwsh_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hbwsh_USCOREupdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbwsh_USCOREupdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, &a->hbwsh_USCOREupdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse), type))
		return soap->error;
	if (a->hbwsh_USCOREupdateResult)
		soap_element_result(soap, "ns1:hbwsh_updateResult");
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, "ns1:hbwsh_updateResult", -1, &a->hbwsh_USCOREupdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_hbwsh_USCOREupdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse, sizeof(struct _ns1__hbwsh_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hbwsh_USCOREupdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, "ns1:hbwsh_updateResult", &a->hbwsh_USCOREupdateResult, ""))
				{	soap_flag_hbwsh_USCOREupdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:hbwsh_updateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse, 0, sizeof(struct _ns1__hbwsh_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const struct _ns1__hbwsh_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse);
	if (soap_out__ns1__hbwsh_USCOREupdateResponse(soap, tag?tag:"ns1:hbwsh_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__hbwsh_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->gs);
	soap_default_xsd__decimal(soap, &a->zje);
	soap_default_string(soap, &a->optid);
	soap_default_string(soap, &a->fs);
	soap_default_time(soap, &a->xzrq);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__hbwsh_USCOREupdate(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->gs);
	soap_serialize_xsd__decimal(soap, &a->zje);
	soap_serialize_string(soap, &a->optid);
	soap_serialize_string(soap, &a->fs);
	soap_serialize_string(soap, &a->UserName);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, int id, const struct _ns1__hbwsh_USCOREupdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (a->zje)
	{	if (soap_out_xsd__decimal(soap, "ns1:zje", -1, &a->zje, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:zje"))
		return soap->error;
	if (soap_out_string(soap, "ns1:optid", -1, &a->optid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fs", -1, &a->fs, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:xzrq", -1, &a->xzrq, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UserName", -1, &a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate * SOAP_FMAC4 soap_in__ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_gs = 1;
	size_t soap_flag_zje = 1;
	size_t soap_flag_optid = 1;
	size_t soap_flag_fs = 1;
	size_t soap_flag_xzrq = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__hbwsh_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__hbwsh_USCOREupdate, sizeof(struct _ns1__hbwsh_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__hbwsh_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_zje && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:zje", &a->zje, "xsd:decimal"))
				{	soap_flag_zje--;
					continue;
				}
			if (soap_flag_optid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:optid", &a->optid, "xsd:string"))
				{	soap_flag_optid--;
					continue;
				}
			if (soap_flag_fs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:fs", &a->fs, "xsd:string"))
				{	soap_flag_fs--;
					continue;
				}
			if (soap_flag_xzrq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:xzrq", &a->xzrq, "xsd:dateTime"))
				{	soap_flag_xzrq--;
					continue;
				}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UserName", &a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__hbwsh_USCOREupdate, 0, sizeof(struct _ns1__hbwsh_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zje > 0 || soap_flag_xzrq > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__hbwsh_USCOREupdate(struct soap *soap, const struct _ns1__hbwsh_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__hbwsh_USCOREupdate);
	if (soap_out__ns1__hbwsh_USCOREupdate(soap, tag?tag:"ns1:hbwsh_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate * SOAP_FMAC4 soap_get__ns1__hbwsh_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__hbwsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse_get_USCOREmxResult * SOAP_FMAC4 soap_in__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult, sizeof(struct _ns1__get_USCOREmxResponse_get_USCOREmxResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult, 0, sizeof(struct _ns1__get_USCOREmxResponse_get_USCOREmxResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult);
	if (soap_out__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag?tag:"ns1:get_mxResponse-get_mxResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse_get_USCOREmxResult * SOAP_FMAC4 soap_get__ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREmxResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREmxResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmxResponse(struct soap *soap, const struct _ns1__get_USCOREmxResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, &a->get_USCOREmxResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmxResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmxResponse), type))
		return soap->error;
	if (a->get_USCOREmxResult)
		soap_element_result(soap, "ns1:get_mxResult");
	if (soap_out_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, "ns1:get_mxResult", -1, &a->get_USCOREmxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREmxResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREmxResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREmxResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmxResponse, sizeof(struct _ns1__get_USCOREmxResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmxResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREmxResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, "ns1:get_mxResult", &a->get_USCOREmxResult, ""))
				{	soap_flag_get_USCOREmxResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_mxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmxResponse, 0, sizeof(struct _ns1__get_USCOREmxResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmxResponse(struct soap *soap, const struct _ns1__get_USCOREmxResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmxResponse);
	if (soap_out__ns1__get_USCOREmxResponse(soap, tag?tag:"ns1:get_mxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREmxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREmx(struct soap *soap, struct _ns1__get_USCOREmx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
	soap_default_string(soap, &a->smdate1);
	soap_default_string(soap, &a->smdate2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREmx(struct soap *soap, const struct _ns1__get_USCOREmx *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
	soap_serialize_string(soap, &a->smdate1);
	soap_serialize_string(soap, &a->smdate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREmx(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREmx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREmx), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate1", -1, &a->smdate1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:smdate2", -1, &a->smdate2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx * SOAP_FMAC4 soap_in__ns1__get_USCOREmx(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	size_t soap_flag_smdate1 = 1;
	size_t soap_flag_smdate2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREmx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREmx, sizeof(struct _ns1__get_USCOREmx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREmx(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap_flag_smdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate1", &a->smdate1, "xsd:string"))
				{	soap_flag_smdate1--;
					continue;
				}
			if (soap_flag_smdate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:smdate2", &a->smdate2, "xsd:string"))
				{	soap_flag_smdate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREmx, 0, sizeof(struct _ns1__get_USCOREmx), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREmx(struct soap *soap, const struct _ns1__get_USCOREmx *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREmx);
	if (soap_out__ns1__get_USCOREmx(soap, tag?tag:"ns1:get_mx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx * SOAP_FMAC4 soap_get__ns1__get_USCOREmx(struct soap *soap, struct _ns1__get_USCOREmx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult, sizeof(struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult, 0, sizeof(struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult);
	if (soap_out__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag?tag:"ns1:get_hbwshResponse-get_hbwshResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwshResponse(struct soap *soap, struct _ns1__get_USCOREhbwshResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbwshResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwshResponse(struct soap *soap, const struct _ns1__get_USCOREhbwshResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, &a->get_USCOREhbwshResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwshResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwshResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwshResponse), type))
		return soap->error;
	if (a->get_USCOREhbwshResult)
		soap_element_result(soap, "ns1:get_hbwshResult");
	if (soap_out_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, "ns1:get_hbwshResult", -1, &a->get_USCOREhbwshResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwshResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwshResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREhbwshResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwshResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwshResponse, sizeof(struct _ns1__get_USCOREhbwshResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwshResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbwshResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, "ns1:get_hbwshResult", &a->get_USCOREhbwshResult, ""))
				{	soap_flag_get_USCOREhbwshResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbwshResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwshResponse, 0, sizeof(struct _ns1__get_USCOREhbwshResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwshResponse(struct soap *soap, const struct _ns1__get_USCOREhbwshResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwshResponse);
	if (soap_out__ns1__get_USCOREhbwshResponse(soap, tag?tag:"ns1:get_hbwshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwshResponse(struct soap *soap, struct _ns1__get_USCOREhbwshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbwsh(struct soap *soap, struct _ns1__get_USCOREhbwsh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gs);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->yyzd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbwsh(struct soap *soap, const struct _ns1__get_USCOREhbwsh *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gs);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->yyzd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbwsh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbwsh), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gs", -1, &a->gs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:yyzd", -1, &a->yyzd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh * SOAP_FMAC4 soap_in__ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh *a, const char *type)
{
	size_t soap_flag_gs = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_yyzd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbwsh *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbwsh, sizeof(struct _ns1__get_USCOREhbwsh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbwsh(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gs", &a->gs, "xsd:string"))
				{	soap_flag_gs--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_yyzd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:yyzd", &a->yyzd, "xsd:string"))
				{	soap_flag_yyzd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbwsh, 0, sizeof(struct _ns1__get_USCOREhbwsh), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbwsh(struct soap *soap, const struct _ns1__get_USCOREhbwsh *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbwsh);
	if (soap_out__ns1__get_USCOREhbwsh(soap, tag?tag:"ns1:get_hbwsh", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh * SOAP_FMAC4 soap_get__ns1__get_USCOREhbwsh(struct soap *soap, struct _ns1__get_USCOREhbwsh *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult, sizeof(struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult, 0, sizeof(struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult);
	if (soap_out__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag?tag:"ns1:get_hbgsResponse-get_hbgsResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgsResponse(struct soap *soap, struct _ns1__get_USCOREhbgsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->get_USCOREhbgsResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgsResponse(struct soap *soap, const struct _ns1__get_USCOREhbgsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, &a->get_USCOREhbgsResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgsResponse), type))
		return soap->error;
	if (a->get_USCOREhbgsResult)
		soap_element_result(soap, "ns1:get_hbgsResult");
	if (soap_out_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, "ns1:get_hbgsResult", -1, &a->get_USCOREhbgsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgsResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgsResponse *a, const char *type)
{
	size_t soap_flag_get_USCOREhbgsResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgsResponse, sizeof(struct _ns1__get_USCOREhbgsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_get_USCOREhbgsResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, "ns1:get_hbgsResult", &a->get_USCOREhbgsResult, ""))
				{	soap_flag_get_USCOREhbgsResult--;
					continue;
				}
			soap_check_result(soap, "ns1:get_hbgsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgsResponse, 0, sizeof(struct _ns1__get_USCOREhbgsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgsResponse(struct soap *soap, const struct _ns1__get_USCOREhbgsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgsResponse);
	if (soap_out__ns1__get_USCOREhbgsResponse(soap, tag?tag:"ns1:get_hbgsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgsResponse(struct soap *soap, struct _ns1__get_USCOREhbgsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__get_USCOREhbgs(struct soap *soap, struct _ns1__get_USCOREhbgs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->str);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__get_USCOREhbgs(struct soap *soap, const struct _ns1__get_USCOREhbgs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->str);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__get_USCOREhbgs(struct soap *soap, const char *tag, int id, const struct _ns1__get_USCOREhbgs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__get_USCOREhbgs), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:str", -1, &a->str, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs * SOAP_FMAC4 soap_in__ns1__get_USCOREhbgs(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs *a, const char *type)
{
	size_t soap_flag_str = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__get_USCOREhbgs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__get_USCOREhbgs, sizeof(struct _ns1__get_USCOREhbgs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__get_USCOREhbgs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_str && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:str", &a->str, "xsd:string"))
				{	soap_flag_str--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__get_USCOREhbgs, 0, sizeof(struct _ns1__get_USCOREhbgs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__get_USCOREhbgs(struct soap *soap, const struct _ns1__get_USCOREhbgs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__get_USCOREhbgs);
	if (soap_out__ns1__get_USCOREhbgs(soap, tag?tag:"ns1:get_hbgs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs * SOAP_FMAC4 soap_get__ns1__get_USCOREhbgs(struct soap *soap, struct _ns1__get_USCOREhbgs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__get_USCOREhbgs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, struct _ns1__FromBASE64Response_FromBASE64Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const struct _ns1__FromBASE64Response_FromBASE64Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const char *tag, int id, const struct _ns1__FromBASE64Response_FromBASE64Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response_FromBASE64Result * SOAP_FMAC4 soap_in__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const char *tag, struct _ns1__FromBASE64Response_FromBASE64Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__FromBASE64Response_FromBASE64Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result, sizeof(struct _ns1__FromBASE64Response_FromBASE64Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__FromBASE64Response_FromBASE64Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64Response_FromBASE64Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result, 0, sizeof(struct _ns1__FromBASE64Response_FromBASE64Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const struct _ns1__FromBASE64Response_FromBASE64Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result);
	if (soap_out__ns1__FromBASE64Response_FromBASE64Result(soap, tag?tag:"ns1:FromBASE64Response-FromBASE64Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response_FromBASE64Result * SOAP_FMAC4 soap_get__ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, struct _ns1__FromBASE64Response_FromBASE64Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FromBASE64Response_FromBASE64Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__FromBASE64Response(struct soap *soap, struct _ns1__FromBASE64Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FromBASE64Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__FromBASE64Response(struct soap *soap, const struct _ns1__FromBASE64Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, &a->FromBASE64Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FromBASE64Response(struct soap *soap, const char *tag, int id, const struct _ns1__FromBASE64Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FromBASE64Response), type))
		return soap->error;
	if (a->FromBASE64Result)
		soap_element_result(soap, "ns1:FromBASE64Result");
	if (soap_out_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, "ns1:FromBASE64Result", -1, &a->FromBASE64Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response * SOAP_FMAC4 soap_in__ns1__FromBASE64Response(struct soap *soap, const char *tag, struct _ns1__FromBASE64Response *a, const char *type)
{
	size_t soap_flag_FromBASE64Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__FromBASE64Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FromBASE64Response, sizeof(struct _ns1__FromBASE64Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__FromBASE64Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromBASE64Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, "ns1:FromBASE64Result", &a->FromBASE64Result, ""))
				{	soap_flag_FromBASE64Result--;
					continue;
				}
			soap_check_result(soap, "ns1:FromBASE64Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FromBASE64Response, 0, sizeof(struct _ns1__FromBASE64Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__FromBASE64Response(struct soap *soap, const struct _ns1__FromBASE64Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__FromBASE64Response);
	if (soap_out__ns1__FromBASE64Response(soap, tag?tag:"ns1:FromBASE64Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response * SOAP_FMAC4 soap_get__ns1__FromBASE64Response(struct soap *soap, struct _ns1__FromBASE64Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FromBASE64Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__FromBASE64(struct soap *soap, struct _ns1__FromBASE64 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__FromBASE64(struct soap *soap, const struct _ns1__FromBASE64 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FromBASE64(struct soap *soap, const char *tag, int id, const struct _ns1__FromBASE64 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FromBASE64), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Text", -1, &a->Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__FromBASE64 * SOAP_FMAC4 soap_in__ns1__FromBASE64(struct soap *soap, const char *tag, struct _ns1__FromBASE64 *a, const char *type)
{
	size_t soap_flag_Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__FromBASE64 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FromBASE64, sizeof(struct _ns1__FromBASE64), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__FromBASE64(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Text", &a->Text, "xsd:string"))
				{	soap_flag_Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FromBASE64, 0, sizeof(struct _ns1__FromBASE64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__FromBASE64(struct soap *soap, const struct _ns1__FromBASE64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__FromBASE64);
	if (soap_out__ns1__FromBASE64(soap, tag?tag:"ns1:FromBASE64", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64 * SOAP_FMAC4 soap_get__ns1__FromBASE64(struct soap *soap, struct _ns1__FromBASE64 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FromBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, struct _ns1__ToBASE64Response_ToBASE64Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const struct _ns1__ToBASE64Response_ToBASE64Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const char *tag, int id, const struct _ns1__ToBASE64Response_ToBASE64Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response_ToBASE64Result * SOAP_FMAC4 soap_in__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const char *tag, struct _ns1__ToBASE64Response_ToBASE64Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ToBASE64Response_ToBASE64Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result, sizeof(struct _ns1__ToBASE64Response_ToBASE64Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ToBASE64Response_ToBASE64Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64Response_ToBASE64Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result, 0, sizeof(struct _ns1__ToBASE64Response_ToBASE64Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const struct _ns1__ToBASE64Response_ToBASE64Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result);
	if (soap_out__ns1__ToBASE64Response_ToBASE64Result(soap, tag?tag:"ns1:ToBASE64Response-ToBASE64Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response_ToBASE64Result * SOAP_FMAC4 soap_get__ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, struct _ns1__ToBASE64Response_ToBASE64Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToBASE64Response_ToBASE64Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ToBASE64Response(struct soap *soap, struct _ns1__ToBASE64Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ToBASE64Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ToBASE64Response(struct soap *soap, const struct _ns1__ToBASE64Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, &a->ToBASE64Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToBASE64Response(struct soap *soap, const char *tag, int id, const struct _ns1__ToBASE64Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToBASE64Response), type))
		return soap->error;
	if (a->ToBASE64Result)
		soap_element_result(soap, "ns1:ToBASE64Result");
	if (soap_out_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, "ns1:ToBASE64Result", -1, &a->ToBASE64Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response * SOAP_FMAC4 soap_in__ns1__ToBASE64Response(struct soap *soap, const char *tag, struct _ns1__ToBASE64Response *a, const char *type)
{
	size_t soap_flag_ToBASE64Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ToBASE64Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToBASE64Response, sizeof(struct _ns1__ToBASE64Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ToBASE64Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToBASE64Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, "ns1:ToBASE64Result", &a->ToBASE64Result, ""))
				{	soap_flag_ToBASE64Result--;
					continue;
				}
			soap_check_result(soap, "ns1:ToBASE64Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToBASE64Response, 0, sizeof(struct _ns1__ToBASE64Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ToBASE64Response(struct soap *soap, const struct _ns1__ToBASE64Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ToBASE64Response);
	if (soap_out__ns1__ToBASE64Response(soap, tag?tag:"ns1:ToBASE64Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response * SOAP_FMAC4 soap_get__ns1__ToBASE64Response(struct soap *soap, struct _ns1__ToBASE64Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToBASE64Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ToBASE64(struct soap *soap, struct _ns1__ToBASE64 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ToBASE64(struct soap *soap, const struct _ns1__ToBASE64 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToBASE64(struct soap *soap, const char *tag, int id, const struct _ns1__ToBASE64 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToBASE64), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Text", -1, &a->Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ToBASE64 * SOAP_FMAC4 soap_in__ns1__ToBASE64(struct soap *soap, const char *tag, struct _ns1__ToBASE64 *a, const char *type)
{
	size_t soap_flag_Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ToBASE64 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToBASE64, sizeof(struct _ns1__ToBASE64), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ToBASE64(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Text", &a->Text, "xsd:string"))
				{	soap_flag_Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToBASE64, 0, sizeof(struct _ns1__ToBASE64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ToBASE64(struct soap *soap, const struct _ns1__ToBASE64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ToBASE64);
	if (soap_out__ns1__ToBASE64(soap, tag?tag:"ns1:ToBASE64", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64 * SOAP_FMAC4 soap_get__ns1__ToBASE64(struct soap *soap, struct _ns1__ToBASE64 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, struct _ns1__CheckSHA1Response_CheckSHA1Result *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const struct _ns1__CheckSHA1Response_CheckSHA1Result *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const char *tag, int id, const struct _ns1__CheckSHA1Response_CheckSHA1Result *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response_CheckSHA1Result * SOAP_FMAC4 soap_in__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const char *tag, struct _ns1__CheckSHA1Response_CheckSHA1Result *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CheckSHA1Response_CheckSHA1Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result, sizeof(struct _ns1__CheckSHA1Response_CheckSHA1Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CheckSHA1Response_CheckSHA1Result(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1Response_CheckSHA1Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result, 0, sizeof(struct _ns1__CheckSHA1Response_CheckSHA1Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const struct _ns1__CheckSHA1Response_CheckSHA1Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result);
	if (soap_out__ns1__CheckSHA1Response_CheckSHA1Result(soap, tag?tag:"ns1:CheckSHA1Response-CheckSHA1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response_CheckSHA1Result * SOAP_FMAC4 soap_get__ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, struct _ns1__CheckSHA1Response_CheckSHA1Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSHA1Response_CheckSHA1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CheckSHA1Response(struct soap *soap, struct _ns1__CheckSHA1Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CheckSHA1Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CheckSHA1Response(struct soap *soap, const struct _ns1__CheckSHA1Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, &a->CheckSHA1Result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSHA1Response(struct soap *soap, const char *tag, int id, const struct _ns1__CheckSHA1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSHA1Response), type))
		return soap->error;
	if (a->CheckSHA1Result)
		soap_element_result(soap, "ns1:CheckSHA1Result");
	if (soap_out_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, "ns1:CheckSHA1Result", -1, &a->CheckSHA1Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response * SOAP_FMAC4 soap_in__ns1__CheckSHA1Response(struct soap *soap, const char *tag, struct _ns1__CheckSHA1Response *a, const char *type)
{
	size_t soap_flag_CheckSHA1Result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CheckSHA1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSHA1Response, sizeof(struct _ns1__CheckSHA1Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CheckSHA1Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckSHA1Result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, "ns1:CheckSHA1Result", &a->CheckSHA1Result, ""))
				{	soap_flag_CheckSHA1Result--;
					continue;
				}
			soap_check_result(soap, "ns1:CheckSHA1Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSHA1Response, 0, sizeof(struct _ns1__CheckSHA1Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CheckSHA1Response(struct soap *soap, const struct _ns1__CheckSHA1Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CheckSHA1Response);
	if (soap_out__ns1__CheckSHA1Response(soap, tag?tag:"ns1:CheckSHA1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response * SOAP_FMAC4 soap_get__ns1__CheckSHA1Response(struct soap *soap, struct _ns1__CheckSHA1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSHA1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CheckSHA1(struct soap *soap, struct _ns1__CheckSHA1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CheckSHA1(struct soap *soap, const struct _ns1__CheckSHA1 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSHA1(struct soap *soap, const char *tag, int id, const struct _ns1__CheckSHA1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSHA1), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Text", -1, &a->Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CheckSHA1 * SOAP_FMAC4 soap_in__ns1__CheckSHA1(struct soap *soap, const char *tag, struct _ns1__CheckSHA1 *a, const char *type)
{
	size_t soap_flag_Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CheckSHA1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSHA1, sizeof(struct _ns1__CheckSHA1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CheckSHA1(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Text", &a->Text, "xsd:string"))
				{	soap_flag_Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSHA1, 0, sizeof(struct _ns1__CheckSHA1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CheckSHA1(struct soap *soap, const struct _ns1__CheckSHA1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CheckSHA1);
	if (soap_out__ns1__CheckSHA1(soap, tag?tag:"ns1:CheckSHA1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1 * SOAP_FMAC4 soap_get__ns1__CheckSHA1(struct soap *soap, struct _ns1__CheckSHA1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSHA1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, struct _ns1__GetHostInfoResponse_GetHostInfoResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const struct _ns1__GetHostInfoResponse_GetHostInfoResult *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const char *tag, int id, const struct _ns1__GetHostInfoResponse_GetHostInfoResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse_GetHostInfoResult * SOAP_FMAC4 soap_in__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const char *tag, struct _ns1__GetHostInfoResponse_GetHostInfoResult *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetHostInfoResponse_GetHostInfoResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult, sizeof(struct _ns1__GetHostInfoResponse_GetHostInfoResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetHostInfoResponse_GetHostInfoResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfoResponse_GetHostInfoResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult, 0, sizeof(struct _ns1__GetHostInfoResponse_GetHostInfoResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const struct _ns1__GetHostInfoResponse_GetHostInfoResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult);
	if (soap_out__ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag?tag:"ns1:GetHostInfoResponse-GetHostInfoResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse_GetHostInfoResult * SOAP_FMAC4 soap_get__ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, struct _ns1__GetHostInfoResponse_GetHostInfoResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetHostInfoResponse(struct soap *soap, struct _ns1__GetHostInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetHostInfoResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetHostInfoResponse(struct soap *soap, const struct _ns1__GetHostInfoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, &a->GetHostInfoResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHostInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetHostInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHostInfoResponse), type))
		return soap->error;
	if (a->GetHostInfoResult)
		soap_element_result(soap, "ns1:GetHostInfoResult");
	if (soap_out_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, "ns1:GetHostInfoResult", -1, &a->GetHostInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse * SOAP_FMAC4 soap_in__ns1__GetHostInfoResponse(struct soap *soap, const char *tag, struct _ns1__GetHostInfoResponse *a, const char *type)
{
	size_t soap_flag_GetHostInfoResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetHostInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHostInfoResponse, sizeof(struct _ns1__GetHostInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetHostInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetHostInfoResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, "ns1:GetHostInfoResult", &a->GetHostInfoResult, ""))
				{	soap_flag_GetHostInfoResult--;
					continue;
				}
			soap_check_result(soap, "ns1:GetHostInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHostInfoResponse, 0, sizeof(struct _ns1__GetHostInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetHostInfoResponse(struct soap *soap, const struct _ns1__GetHostInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetHostInfoResponse);
	if (soap_out__ns1__GetHostInfoResponse(soap, tag?tag:"ns1:GetHostInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse * SOAP_FMAC4 soap_get__ns1__GetHostInfoResponse(struct soap *soap, struct _ns1__GetHostInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHostInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetHostInfo(struct soap *soap, struct _ns1__GetHostInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetHostInfo(struct soap *soap, const struct _ns1__GetHostInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHostInfo(struct soap *soap, const char *tag, int id, const struct _ns1__GetHostInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHostInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetHostInfo * SOAP_FMAC4 soap_in__ns1__GetHostInfo(struct soap *soap, const char *tag, struct _ns1__GetHostInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetHostInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHostInfo, sizeof(struct _ns1__GetHostInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetHostInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHostInfo, 0, sizeof(struct _ns1__GetHostInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetHostInfo(struct soap *soap, const struct _ns1__GetHostInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetHostInfo);
	if (soap_out__ns1__GetHostInfo(soap, tag?tag:"ns1:GetHostInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfo * SOAP_FMAC4 soap_get__ns1__GetHostInfo(struct soap *soap, struct _ns1__GetHostInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHostInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetDNSResponse(struct soap *soap, struct _ns1__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GetDNSResult);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetDNSResponse(struct soap *soap, const struct _ns1__GetDNSResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->GetDNSResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDNSResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDNSResponse), type))
		return soap->error;
	if (a->GetDNSResult)
		soap_element_result(soap, "ns1:GetDNSResult");
	if (soap_out_string(soap, "ns1:GetDNSResult", -1, &a->GetDNSResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetDNSResponse * SOAP_FMAC4 soap_in__ns1__GetDNSResponse(struct soap *soap, const char *tag, struct _ns1__GetDNSResponse *a, const char *type)
{
	size_t soap_flag_GetDNSResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDNSResponse, sizeof(struct _ns1__GetDNSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDNSResult && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetDNSResult", &a->GetDNSResult, "xsd:string"))
				{	soap_flag_GetDNSResult--;
					continue;
				}
			soap_check_result(soap, "ns1:GetDNSResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDNSResponse, 0, sizeof(struct _ns1__GetDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetDNSResponse(struct soap *soap, const struct _ns1__GetDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetDNSResponse);
	if (soap_out__ns1__GetDNSResponse(soap, tag?tag:"ns1:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetDNSResponse * SOAP_FMAC4 soap_get__ns1__GetDNSResponse(struct soap *soap, struct _ns1__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetDNS(struct soap *soap, struct _ns1__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetDNS(struct soap *soap, const struct _ns1__GetDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDNS(struct soap *soap, const char *tag, int id, const struct _ns1__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetDNS * SOAP_FMAC4 soap_in__ns1__GetDNS(struct soap *soap, const char *tag, struct _ns1__GetDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDNS, sizeof(struct _ns1__GetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDNS, 0, sizeof(struct _ns1__GetDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetDNS(struct soap *soap, const struct _ns1__GetDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetDNS);
	if (soap_out__ns1__GetDNS(soap, tag?tag:"ns1:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetDNS * SOAP_FMAC4 soap_get__ns1__GetDNS(struct soap *soap, struct _ns1__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetTimeResponse(struct soap *soap, struct _ns1__GetTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->GetTimeResult);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetTimeResponse(struct soap *soap, const struct _ns1__GetTimeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTimeResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTimeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetTimeResult");
	if (soap_out_LONG64(soap, "ns1:GetTimeResult", -1, &a->GetTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetTimeResponse * SOAP_FMAC4 soap_in__ns1__GetTimeResponse(struct soap *soap, const char *tag, struct _ns1__GetTimeResponse *a, const char *type)
{
	size_t soap_flag_GetTimeResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTimeResponse, sizeof(struct _ns1__GetTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTimeResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:GetTimeResult", &a->GetTimeResult, "xsd:long"))
				{	soap_flag_GetTimeResult--;
					continue;
				}
			soap_check_result(soap, "ns1:GetTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTimeResponse, 0, sizeof(struct _ns1__GetTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTimeResult > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetTimeResponse(struct soap *soap, const struct _ns1__GetTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetTimeResponse);
	if (soap_out__ns1__GetTimeResponse(soap, tag?tag:"ns1:GetTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetTimeResponse * SOAP_FMAC4 soap_get__ns1__GetTimeResponse(struct soap *soap, struct _ns1__GetTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetTime(struct soap *soap, struct _ns1__GetTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetTime(struct soap *soap, const struct _ns1__GetTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTime(struct soap *soap, const char *tag, int id, const struct _ns1__GetTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetTime * SOAP_FMAC4 soap_in__ns1__GetTime(struct soap *soap, const char *tag, struct _ns1__GetTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTime, sizeof(struct _ns1__GetTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTime, 0, sizeof(struct _ns1__GetTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetTime(struct soap *soap, const struct _ns1__GetTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetTime);
	if (soap_out__ns1__GetTime(soap, tag?tag:"ns1:GetTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetTime * SOAP_FMAC4 soap_get__ns1__GetTime(struct soap *soap, struct _ns1__GetTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag?tag:"xsd:anyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response))
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdate1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdate1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdate1Response **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdate1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(soap, tag?tag:"ns1:m_tz_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1))
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdate1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdate1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdate1 **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdate1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, tag?tag:"ns1:m_tz_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdate1(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDay1Response(struct soap *soap, struct _ns1__TZ_USCOREDay1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDay1Response))
		soap_serialize__ns1__TZ_USCOREDay1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDay1Response(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDay1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDay1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDay1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDay1Response(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDay1Response **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDay1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDay1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDay1Response, sizeof(struct _ns1__TZ_USCOREDay1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDay1Response(struct soap *soap, struct _ns1__TZ_USCOREDay1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response);
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1Response(soap, tag?tag:"ns1:TZ_Day1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDay1Response(struct soap *soap, struct _ns1__TZ_USCOREDay1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDay1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDay1(struct soap *soap, struct _ns1__TZ_USCOREDay1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDay1))
		soap_serialize__ns1__TZ_USCOREDay1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDay1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDay1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDay1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDay1(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDay1 **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDay1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDay1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDay1, sizeof(struct _ns1__TZ_USCOREDay1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDay1(struct soap *soap, struct _ns1__TZ_USCOREDay1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1);
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1(soap, tag?tag:"ns1:TZ_Day1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDay1(struct soap *soap, struct _ns1__TZ_USCOREDay1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDay1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag?tag:"ns1:hb_fp_dy_end1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag?tag:"ns1:hb_fp_dy_end1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyue1Response(struct soap *soap, struct _ns1__get_USCOREyue1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyue1Response))
		soap_serialize__ns1__get_USCOREyue1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyue1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyue1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyue1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyue1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyue1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyue1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyue1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyue1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyue1Response, sizeof(struct _ns1__get_USCOREyue1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyue1Response(struct soap *soap, struct _ns1__get_USCOREyue1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response);
	if (soap_out_PointerTo_ns1__get_USCOREyue1Response(soap, tag?tag:"ns1:get_yue1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyue1Response(struct soap *soap, struct _ns1__get_USCOREyue1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyue1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyue1(struct soap *soap, struct _ns1__get_USCOREyue1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyue1))
		soap_serialize__ns1__get_USCOREyue1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyue1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyue1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyue1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyue1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyue1(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyue1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyue1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyue1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyue1, sizeof(struct _ns1__get_USCOREyue1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyue1(struct soap *soap, struct _ns1__get_USCOREyue1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyue1);
	if (soap_out_PointerTo_ns1__get_USCOREyue1(soap, tag?tag:"ns1:get_yue1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyue1(struct soap *soap, struct _ns1__get_USCOREyue1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyue1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzd1Response(struct soap *soap, struct _ns1__get_USCOREyyzd1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzd1Response))
		soap_serialize__ns1__get_USCOREyyzd1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzd1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzd1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzd1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzd1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzd1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzd1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzd1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzd1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzd1Response, sizeof(struct _ns1__get_USCOREyyzd1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzd1Response(struct soap *soap, struct _ns1__get_USCOREyyzd1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response);
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1Response(soap, tag?tag:"ns1:get_yyzd1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzd1Response(struct soap *soap, struct _ns1__get_USCOREyyzd1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzd1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzd1(struct soap *soap, struct _ns1__get_USCOREyyzd1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzd1))
		soap_serialize__ns1__get_USCOREyyzd1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzd1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzd1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzd1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzd1(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzd1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzd1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzd1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzd1, sizeof(struct _ns1__get_USCOREyyzd1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzd1(struct soap *soap, struct _ns1__get_USCOREyyzd1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1);
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1(soap, tag?tag:"ns1:get_yyzd1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzd1(struct soap *soap, struct _ns1__get_USCOREyyzd1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzd1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfp1Response(struct soap *soap, struct _ns1__get_USCOREhbfp1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfp1Response))
		soap_serialize__ns1__get_USCOREhbfp1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfp1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfp1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfp1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfp1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfp1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfp1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfp1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfp1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfp1Response, sizeof(struct _ns1__get_USCOREhbfp1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfp1Response(struct soap *soap, struct _ns1__get_USCOREhbfp1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response);
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1Response(soap, tag?tag:"ns1:get_hbfp1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfp1Response(struct soap *soap, struct _ns1__get_USCOREhbfp1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfp1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfp1(struct soap *soap, struct _ns1__get_USCOREhbfp1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfp1))
		soap_serialize__ns1__get_USCOREhbfp1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfp1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfp1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfp1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfp1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfp1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfp1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfp1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfp1, sizeof(struct _ns1__get_USCOREhbfp1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfp1(struct soap *soap, struct _ns1__get_USCOREhbfp1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1);
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1(soap, tag?tag:"ns1:get_hbfp1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfp1(struct soap *soap, struct _ns1__get_USCOREhbfp1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfp1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1Response(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response))
		soap_serialize__ns1__hbtsf_USCOREupdate1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdate1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdate1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdate1Response **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdate1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdate1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response, sizeof(struct _ns1__hbtsf_USCOREupdate1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdate1Response(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response(soap, tag?tag:"ns1:hbtsf_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdate1Response(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1))
		soap_serialize__ns1__hbtsf_USCOREupdate1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdate1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdate1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdate1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdate1 **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdate1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdate1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1, sizeof(struct _ns1__hbtsf_USCOREupdate1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdate1(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1(soap, tag?tag:"ns1:hbtsf_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdate1(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1Response(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response))
		soap_serialize__ns1__hbwsh_USCOREupdate1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdate1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdate1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdate1Response **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdate1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdate1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response, sizeof(struct _ns1__hbwsh_USCOREupdate1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdate1Response(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response(soap, tag?tag:"ns1:hbwsh_update1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdate1Response(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1))
		soap_serialize__ns1__hbwsh_USCOREupdate1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdate1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdate1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdate1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdate1(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdate1 **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdate1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdate1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1, sizeof(struct _ns1__hbwsh_USCOREupdate1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdate1(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1(soap, tag?tag:"ns1:hbwsh_update1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdate1(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdate1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmx1Response(struct soap *soap, struct _ns1__get_USCOREmx1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmx1Response))
		soap_serialize__ns1__get_USCOREmx1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmx1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmx1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmx1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmx1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmx1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmx1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmx1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmx1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmx1Response, sizeof(struct _ns1__get_USCOREmx1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmx1Response(struct soap *soap, struct _ns1__get_USCOREmx1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response);
	if (soap_out_PointerTo_ns1__get_USCOREmx1Response(soap, tag?tag:"ns1:get_mx1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmx1Response(struct soap *soap, struct _ns1__get_USCOREmx1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmx1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmx1(struct soap *soap, struct _ns1__get_USCOREmx1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmx1))
		soap_serialize__ns1__get_USCOREmx1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmx1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmx1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmx1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmx1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmx1(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmx1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmx1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmx1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmx1, sizeof(struct _ns1__get_USCOREmx1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmx1(struct soap *soap, struct _ns1__get_USCOREmx1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmx1);
	if (soap_out_PointerTo_ns1__get_USCOREmx1(soap, tag?tag:"ns1:get_mx1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmx1(struct soap *soap, struct _ns1__get_USCOREmx1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmx1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh1Response(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response))
		soap_serialize__ns1__get_USCOREhbwsh1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response, sizeof(struct _ns1__get_USCOREhbwsh1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh1Response(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1Response(soap, tag?tag:"ns1:get_hbwsh1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh1Response(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh1(struct soap *soap, struct _ns1__get_USCOREhbwsh1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh1))
		soap_serialize__ns1__get_USCOREhbwsh1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh1, sizeof(struct _ns1__get_USCOREhbwsh1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh1(struct soap *soap, struct _ns1__get_USCOREhbwsh1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1(soap, tag?tag:"ns1:get_hbwsh1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh1(struct soap *soap, struct _ns1__get_USCOREhbwsh1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgs1Response(struct soap *soap, struct _ns1__get_USCOREhbgs1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgs1Response))
		soap_serialize__ns1__get_USCOREhbgs1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgs1Response(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgs1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgs1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgs1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgs1Response(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgs1Response **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgs1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgs1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgs1Response, sizeof(struct _ns1__get_USCOREhbgs1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgs1Response(struct soap *soap, struct _ns1__get_USCOREhbgs1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response);
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1Response(soap, tag?tag:"ns1:get_hbgs1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgs1Response(struct soap *soap, struct _ns1__get_USCOREhbgs1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgs1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgs1(struct soap *soap, struct _ns1__get_USCOREhbgs1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgs1))
		soap_serialize__ns1__get_USCOREhbgs1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgs1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgs1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgs1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgs1(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgs1 **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgs1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgs1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgs1, sizeof(struct _ns1__get_USCOREhbgs1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgs1(struct soap *soap, struct _ns1__get_USCOREhbgs1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1);
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1(soap, tag?tag:"ns1:get_hbgs1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgs1(struct soap *soap, struct _ns1__get_USCOREhbgs1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgs1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse))
		soap_serialize__ns1__fp_USCOREdy_USCOREendResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, int id, struct _ns1__fp_USCOREdy_USCOREendResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__fp_USCOREdy_USCOREendResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREendResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__fp_USCOREdy_USCOREendResponse **)soap_malloc(soap, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__fp_USCOREdy_USCOREendResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREendResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse);
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(soap, tag?tag:"ns1:fp_dy_endResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREend *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend))
		soap_serialize__ns1__fp_USCOREdy_USCOREend(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, struct _ns1__fp_USCOREdy_USCOREend *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__fp_USCOREdy_USCOREend(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREend ** SOAP_FMAC4 soap_in_PointerTo_ns1__fp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREend **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__fp_USCOREdy_USCOREend **)soap_malloc(soap, sizeof(struct _ns1__fp_USCOREdy_USCOREend *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__fp_USCOREdy_USCOREend(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREend **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREend, sizeof(struct _ns1__fp_USCOREdy_USCOREend), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREend *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREend);
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, tag?tag:"ns1:fp_dy_end", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREend ** SOAP_FMAC4 soap_get_PointerTo_ns1__fp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREend **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__fp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzbfpResponse(struct soap *soap, struct _ns1__get_USCOREzbfpResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzbfpResponse))
		soap_serialize__ns1__get_USCOREzbfpResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzbfpResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzbfpResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzbfpResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzbfpResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzbfpResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfpResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzbfpResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzbfpResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzbfpResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfpResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzbfpResponse, sizeof(struct _ns1__get_USCOREzbfpResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzbfpResponse(struct soap *soap, struct _ns1__get_USCOREzbfpResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse);
	if (soap_out_PointerTo_ns1__get_USCOREzbfpResponse(soap, tag?tag:"ns1:get_zbfpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzbfpResponse(struct soap *soap, struct _ns1__get_USCOREzbfpResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzbfpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzbfp(struct soap *soap, struct _ns1__get_USCOREzbfp *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzbfp))
		soap_serialize__ns1__get_USCOREzbfp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzbfp(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzbfp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzbfp);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzbfp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfp ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzbfp(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzbfp **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzbfp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzbfp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzbfp, sizeof(struct _ns1__get_USCOREzbfp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzbfp(struct soap *soap, struct _ns1__get_USCOREzbfp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzbfp);
	if (soap_out_PointerTo_ns1__get_USCOREzbfp(soap, tag?tag:"ns1:get_zbfp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfp ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzbfp(struct soap *soap, struct _ns1__get_USCOREzbfp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse))
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonthResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag?tag:"ns1:ZB_TZ_MonthResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonth *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth))
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonth(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREMonth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREMonth(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonth ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonth **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREMonth **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREMonth(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonth, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonth), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonth *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonth);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, tag?tag:"ns1:ZB_TZ_Month", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonth ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse))
		soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREDayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag?tag:"ns1:ZB_TZ_DayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDay *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay))
		soap_serialize__ns1__ZB_USCORETZ_USCOREDay(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREDay *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREDay(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDay ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDay **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREDay **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREDay *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREDay(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDay **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDay, sizeof(struct _ns1__ZB_USCORETZ_USCOREDay), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDay *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDay);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, tag?tag:"ns1:ZB_TZ_Day", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDay ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREDay(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDay **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__tsf_USCOREupdateResponse(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse))
		soap_serialize__ns1__tsf_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__tsf_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__tsf_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__tsf_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__tsf_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__tsf_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__tsf_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__tsf_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__tsf_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse, sizeof(struct _ns1__tsf_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__tsf_USCOREupdateResponse(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__tsf_USCOREupdateResponse(soap, tag?tag:"ns1:tsf_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__tsf_USCOREupdateResponse(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__tsf_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__tsf_USCOREupdate(struct soap *soap, struct _ns1__tsf_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__tsf_USCOREupdate))
		soap_serialize__ns1__tsf_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__tsf_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__tsf_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__tsf_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__tsf_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__tsf_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__tsf_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__tsf_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__tsf_USCOREupdate, sizeof(struct _ns1__tsf_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__tsf_USCOREupdate(struct soap *soap, struct _ns1__tsf_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdate);
	if (soap_out_PointerTo_ns1__tsf_USCOREupdate(soap, tag?tag:"ns1:tsf_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__tsf_USCOREupdate(struct soap *soap, struct _ns1__tsf_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__tsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__wsh_USCOREupdateResponse(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse))
		soap_serialize__ns1__wsh_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__wsh_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__wsh_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__wsh_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__wsh_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__wsh_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__wsh_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__wsh_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__wsh_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse, sizeof(struct _ns1__wsh_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__wsh_USCOREupdateResponse(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__wsh_USCOREupdateResponse(soap, tag?tag:"ns1:wsh_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__wsh_USCOREupdateResponse(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__wsh_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__wsh_USCOREupdate(struct soap *soap, struct _ns1__wsh_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__wsh_USCOREupdate))
		soap_serialize__ns1__wsh_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__wsh_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__wsh_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__wsh_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__wsh_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__wsh_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__wsh_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__wsh_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__wsh_USCOREupdate, sizeof(struct _ns1__wsh_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__wsh_USCOREupdate(struct soap *soap, struct _ns1__wsh_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdate);
	if (soap_out_PointerTo_ns1__wsh_USCOREupdate(soap, tag?tag:"ns1:wsh_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__wsh_USCOREupdate(struct soap *soap, struct _ns1__wsh_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__wsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse))
		soap_serialize__ns1__get_USCOREzb_USCOREmxResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzb_USCOREmxResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzb_USCOREmxResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmxResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzb_USCOREmxResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzb_USCOREmxResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmxResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse);
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(soap, tag?tag:"ns1:get_zb_mxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmx *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx))
		soap_serialize__ns1__get_USCOREzb_USCOREmx(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzb_USCOREmx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzb_USCOREmx(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmx ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzb_USCOREmx(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzb_USCOREmx **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzb_USCOREmx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzb_USCOREmx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmx, sizeof(struct _ns1__get_USCOREzb_USCOREmx), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmx);
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, tag?tag:"ns1:get_zb_mx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmx ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzb_USCOREmx(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzb_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREwshResponse(struct soap *soap, struct _ns1__get_USCOREwshResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREwshResponse))
		soap_serialize__ns1__get_USCOREwshResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREwshResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREwshResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREwshResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREwshResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREwshResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREwshResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREwshResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREwshResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREwshResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwshResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREwshResponse, sizeof(struct _ns1__get_USCOREwshResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREwshResponse(struct soap *soap, struct _ns1__get_USCOREwshResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse);
	if (soap_out_PointerTo_ns1__get_USCOREwshResponse(soap, tag?tag:"ns1:get_wshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREwshResponse(struct soap *soap, struct _ns1__get_USCOREwshResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREwshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREwsh(struct soap *soap, struct _ns1__get_USCOREwsh *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREwsh))
		soap_serialize__ns1__get_USCOREwsh(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREwsh(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREwsh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREwsh);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREwsh(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREwsh ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREwsh(struct soap *soap, const char *tag, struct _ns1__get_USCOREwsh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREwsh **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREwsh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREwsh(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwsh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREwsh, sizeof(struct _ns1__get_USCOREwsh), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREwsh(struct soap *soap, struct _ns1__get_USCOREwsh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREwsh);
	if (soap_out_PointerTo_ns1__get_USCOREwsh(soap, tag?tag:"ns1:get_wsh", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwsh ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREwsh(struct soap *soap, struct _ns1__get_USCOREwsh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag?tag:"ns1:hb_fp_dy_endResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag?tag:"ns1:hb_fp_dy_end", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse))
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag?tag:"ns1:hbtsf_yue_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate))
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREyue_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREyue_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdate, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag?tag:"ns1:hbtsf_yue_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse))
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag?tag:"ns1:hbwsh_yue_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate))
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREyue_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREyue_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdate, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag?tag:"ns1:hbwsh_yue_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREyueResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyueResponse))
		soap_serialize__ns1__get_USCOREyueResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyueResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyueResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyueResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyueResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREyueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyueResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyueResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyueResponse, sizeof(struct _ns1__get_USCOREyueResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREyueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse);
	if (soap_out_PointerTo_ns1__get_USCOREyueResponse(soap, tag?tag:"ns1:get_yueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREyueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyue(struct soap *soap, struct _ns1__get_USCOREyue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyue))
		soap_serialize__ns1__get_USCOREyue(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyue(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyue);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyue(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyue **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyue, sizeof(struct _ns1__get_USCOREyue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyue(struct soap *soap, struct _ns1__get_USCOREyue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyue);
	if (soap_out_PointerTo_ns1__get_USCOREyue(soap, tag?tag:"ns1:get_yue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyue(struct soap *soap, struct _ns1__get_USCOREyue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse))
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag?tag:"ns1:get_hbwsh_yueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue))
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyue(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh_USCOREyue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh_USCOREyue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyue ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh_USCOREyue **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh_USCOREyue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyue, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyue);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, tag?tag:"ns1:get_hbwsh_yue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyue ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzdResponse(struct soap *soap, struct _ns1__get_USCOREyyzdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzdResponse))
		soap_serialize__ns1__get_USCOREyyzdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzdResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzdResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzdResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzdResponse, sizeof(struct _ns1__get_USCOREyyzdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzdResponse(struct soap *soap, struct _ns1__get_USCOREyyzdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse);
	if (soap_out_PointerTo_ns1__get_USCOREyyzdResponse(soap, tag?tag:"ns1:get_yyzdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzdResponse(struct soap *soap, struct _ns1__get_USCOREyyzdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzd(struct soap *soap, struct _ns1__get_USCOREyyzd *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzd))
		soap_serialize__ns1__get_USCOREyyzd(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzd(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzd);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzd(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzd(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzd **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzd(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzd, sizeof(struct _ns1__get_USCOREyyzd), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzd(struct soap *soap, struct _ns1__get_USCOREyyzd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd);
	if (soap_out_PointerTo_ns1__get_USCOREyyzd(soap, tag?tag:"ns1:get_yyzd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzd(struct soap *soap, struct _ns1__get_USCOREyyzd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfpResponse(struct soap *soap, struct _ns1__get_USCOREhbfpResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfpResponse))
		soap_serialize__ns1__get_USCOREhbfpResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfpResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfpResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfpResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfpResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfpResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfpResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfpResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfpResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfpResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfpResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfpResponse, sizeof(struct _ns1__get_USCOREhbfpResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfpResponse(struct soap *soap, struct _ns1__get_USCOREhbfpResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse);
	if (soap_out_PointerTo_ns1__get_USCOREhbfpResponse(soap, tag?tag:"ns1:get_hbfpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfpResponse(struct soap *soap, struct _ns1__get_USCOREhbfpResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfp(struct soap *soap, struct _ns1__get_USCOREhbfp *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfp))
		soap_serialize__ns1__get_USCOREhbfp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfp(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfp);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfp(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfp **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfp, sizeof(struct _ns1__get_USCOREhbfp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfp(struct soap *soap, struct _ns1__get_USCOREhbfp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp);
	if (soap_out_PointerTo_ns1__get_USCOREhbfp(soap, tag?tag:"ns1:get_hbfp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfp(struct soap *soap, struct _ns1__get_USCOREhbfp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse))
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag?tag:"ns1:m_zb_tz_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate))
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdate, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate);
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag?tag:"ns1:m_zb_tz_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse))
		soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(soap, tag?tag:"ns1:m_tz_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate))
		soap_serialize__ns1__m_USCOREtz_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate, sizeof(struct _ns1__m_USCOREtz_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, tag?tag:"ns1:m_tz_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdate(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREMonthResponse(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse))
		soap_serialize__ns1__TZ_USCOREMonthResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREMonthResponse(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREMonthResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREMonthResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREMonthResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREMonthResponse(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonthResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREMonthResponse **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREMonthResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREMonthResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonthResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse, sizeof(struct _ns1__TZ_USCOREMonthResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREMonthResponse(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse);
	if (soap_out_PointerTo_ns1__TZ_USCOREMonthResponse(soap, tag?tag:"ns1:TZ_MonthResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREMonthResponse(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREMonth(struct soap *soap, struct _ns1__TZ_USCOREMonth *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREMonth))
		soap_serialize__ns1__TZ_USCOREMonth(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREMonth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREMonth);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREMonth(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonth ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREMonth(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonth **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREMonth **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREMonth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREMonth(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREMonth, sizeof(struct _ns1__TZ_USCOREMonth), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREMonth(struct soap *soap, struct _ns1__TZ_USCOREMonth *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonth);
	if (soap_out_PointerTo_ns1__TZ_USCOREMonth(soap, tag?tag:"ns1:TZ_Month", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonth ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREMonth(struct soap *soap, struct _ns1__TZ_USCOREMonth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDayResponse(struct soap *soap, struct _ns1__TZ_USCOREDayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDayResponse))
		soap_serialize__ns1__TZ_USCOREDayResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDayResponse(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDayResponse(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDayResponse **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDayResponse, sizeof(struct _ns1__TZ_USCOREDayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDayResponse(struct soap *soap, struct _ns1__TZ_USCOREDayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse);
	if (soap_out_PointerTo_ns1__TZ_USCOREDayResponse(soap, tag?tag:"ns1:TZ_DayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDayResponse(struct soap *soap, struct _ns1__TZ_USCOREDayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDay(struct soap *soap, struct _ns1__TZ_USCOREDay *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDay))
		soap_serialize__ns1__TZ_USCOREDay(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDay(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDay *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDay);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDay(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDay(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDay **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDay *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDay(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDay, sizeof(struct _ns1__TZ_USCOREDay), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDay(struct soap *soap, struct _ns1__TZ_USCOREDay *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay);
	if (soap_out_PointerTo_ns1__TZ_USCOREDay(soap, tag?tag:"ns1:TZ_Day", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDay(struct soap *soap, struct _ns1__TZ_USCOREDay **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse))
		soap_serialize__ns1__hbtsf_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse, sizeof(struct _ns1__hbtsf_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse(soap, tag?tag:"ns1:hbtsf_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdateResponse(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdate))
		soap_serialize__ns1__hbtsf_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdate, sizeof(struct _ns1__hbtsf_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate(soap, tag?tag:"ns1:hbtsf_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdate(struct soap *soap, struct _ns1__hbtsf_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse))
		soap_serialize__ns1__hbwsh_USCOREupdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdateResponse **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse, sizeof(struct _ns1__hbwsh_USCOREupdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse(soap, tag?tag:"ns1:hbwsh_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdateResponse(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREupdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdate))
		soap_serialize__ns1__hbwsh_USCOREupdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdate(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdate **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdate, sizeof(struct _ns1__hbwsh_USCOREupdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREupdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate(soap, tag?tag:"ns1:hbwsh_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdate(struct soap *soap, struct _ns1__hbwsh_USCOREupdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREmxResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmxResponse))
		soap_serialize__ns1__get_USCOREmxResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmxResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmxResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmxResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmxResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmxResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREmxResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmxResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmxResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmxResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmxResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmxResponse, sizeof(struct _ns1__get_USCOREmxResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREmxResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse);
	if (soap_out_PointerTo_ns1__get_USCOREmxResponse(soap, tag?tag:"ns1:get_mxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmxResponse(struct soap *soap, struct _ns1__get_USCOREmxResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmx(struct soap *soap, struct _ns1__get_USCOREmx *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmx))
		soap_serialize__ns1__get_USCOREmx(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmx(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmx);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmx(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmx(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmx **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmx, sizeof(struct _ns1__get_USCOREmx), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmx(struct soap *soap, struct _ns1__get_USCOREmx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmx);
	if (soap_out_PointerTo_ns1__get_USCOREmx(soap, tag?tag:"ns1:get_mx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmx(struct soap *soap, struct _ns1__get_USCOREmx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwshResponse(struct soap *soap, struct _ns1__get_USCOREhbwshResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwshResponse))
		soap_serialize__ns1__get_USCOREhbwshResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwshResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwshResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwshResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwshResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwshResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwshResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwshResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwshResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwshResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwshResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwshResponse, sizeof(struct _ns1__get_USCOREhbwshResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwshResponse(struct soap *soap, struct _ns1__get_USCOREhbwshResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse);
	if (soap_out_PointerTo_ns1__get_USCOREhbwshResponse(soap, tag?tag:"ns1:get_hbwshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwshResponse(struct soap *soap, struct _ns1__get_USCOREhbwshResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh(struct soap *soap, struct _ns1__get_USCOREhbwsh *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh))
		soap_serialize__ns1__get_USCOREhbwsh(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh, sizeof(struct _ns1__get_USCOREhbwsh), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh(struct soap *soap, struct _ns1__get_USCOREhbwsh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh(soap, tag?tag:"ns1:get_hbwsh", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh(struct soap *soap, struct _ns1__get_USCOREhbwsh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgsResponse(struct soap *soap, struct _ns1__get_USCOREhbgsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgsResponse))
		soap_serialize__ns1__get_USCOREhbgsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgsResponse(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgsResponse(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgsResponse **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgsResponse, sizeof(struct _ns1__get_USCOREhbgsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgsResponse(struct soap *soap, struct _ns1__get_USCOREhbgsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse);
	if (soap_out_PointerTo_ns1__get_USCOREhbgsResponse(soap, tag?tag:"ns1:get_hbgsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgsResponse(struct soap *soap, struct _ns1__get_USCOREhbgsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgs(struct soap *soap, struct _ns1__get_USCOREhbgs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgs))
		soap_serialize__ns1__get_USCOREhbgs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgs(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgs);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgs(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgs **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgs, sizeof(struct _ns1__get_USCOREhbgs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgs(struct soap *soap, struct _ns1__get_USCOREhbgs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs);
	if (soap_out_PointerTo_ns1__get_USCOREhbgs(soap, tag?tag:"ns1:get_hbgs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgs(struct soap *soap, struct _ns1__get_USCOREhbgs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FromBASE64Response(struct soap *soap, struct _ns1__FromBASE64Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FromBASE64Response))
		soap_serialize__ns1__FromBASE64Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FromBASE64Response(struct soap *soap, const char *tag, int id, struct _ns1__FromBASE64Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FromBASE64Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__FromBASE64Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__FromBASE64Response(struct soap *soap, const char *tag, struct _ns1__FromBASE64Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__FromBASE64Response **)soap_malloc(soap, sizeof(struct _ns1__FromBASE64Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__FromBASE64Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FromBASE64Response, sizeof(struct _ns1__FromBASE64Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FromBASE64Response(struct soap *soap, struct _ns1__FromBASE64Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__FromBASE64Response);
	if (soap_out_PointerTo_ns1__FromBASE64Response(soap, tag?tag:"ns1:FromBASE64Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__FromBASE64Response(struct soap *soap, struct _ns1__FromBASE64Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FromBASE64Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FromBASE64(struct soap *soap, struct _ns1__FromBASE64 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FromBASE64))
		soap_serialize__ns1__FromBASE64(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FromBASE64(struct soap *soap, const char *tag, int id, struct _ns1__FromBASE64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FromBASE64);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__FromBASE64(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__FromBASE64 ** SOAP_FMAC4 soap_in_PointerTo_ns1__FromBASE64(struct soap *soap, const char *tag, struct _ns1__FromBASE64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__FromBASE64 **)soap_malloc(soap, sizeof(struct _ns1__FromBASE64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__FromBASE64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FromBASE64, sizeof(struct _ns1__FromBASE64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FromBASE64(struct soap *soap, struct _ns1__FromBASE64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__FromBASE64);
	if (soap_out_PointerTo_ns1__FromBASE64(soap, tag?tag:"ns1:FromBASE64", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64 ** SOAP_FMAC4 soap_get_PointerTo_ns1__FromBASE64(struct soap *soap, struct _ns1__FromBASE64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FromBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ToBASE64Response(struct soap *soap, struct _ns1__ToBASE64Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ToBASE64Response))
		soap_serialize__ns1__ToBASE64Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ToBASE64Response(struct soap *soap, const char *tag, int id, struct _ns1__ToBASE64Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ToBASE64Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ToBASE64Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__ToBASE64Response(struct soap *soap, const char *tag, struct _ns1__ToBASE64Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ToBASE64Response **)soap_malloc(soap, sizeof(struct _ns1__ToBASE64Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ToBASE64Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ToBASE64Response, sizeof(struct _ns1__ToBASE64Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ToBASE64Response(struct soap *soap, struct _ns1__ToBASE64Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ToBASE64Response);
	if (soap_out_PointerTo_ns1__ToBASE64Response(soap, tag?tag:"ns1:ToBASE64Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__ToBASE64Response(struct soap *soap, struct _ns1__ToBASE64Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ToBASE64Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ToBASE64(struct soap *soap, struct _ns1__ToBASE64 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ToBASE64))
		soap_serialize__ns1__ToBASE64(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ToBASE64(struct soap *soap, const char *tag, int id, struct _ns1__ToBASE64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ToBASE64);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ToBASE64(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ToBASE64 ** SOAP_FMAC4 soap_in_PointerTo_ns1__ToBASE64(struct soap *soap, const char *tag, struct _ns1__ToBASE64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ToBASE64 **)soap_malloc(soap, sizeof(struct _ns1__ToBASE64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ToBASE64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ToBASE64, sizeof(struct _ns1__ToBASE64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ToBASE64(struct soap *soap, struct _ns1__ToBASE64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ToBASE64);
	if (soap_out_PointerTo_ns1__ToBASE64(soap, tag?tag:"ns1:ToBASE64", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64 ** SOAP_FMAC4 soap_get_PointerTo_ns1__ToBASE64(struct soap *soap, struct _ns1__ToBASE64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ToBASE64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckSHA1Response(struct soap *soap, struct _ns1__CheckSHA1Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckSHA1Response))
		soap_serialize__ns1__CheckSHA1Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckSHA1Response(struct soap *soap, const char *tag, int id, struct _ns1__CheckSHA1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckSHA1Response);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CheckSHA1Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckSHA1Response(struct soap *soap, const char *tag, struct _ns1__CheckSHA1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CheckSHA1Response **)soap_malloc(soap, sizeof(struct _ns1__CheckSHA1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CheckSHA1Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckSHA1Response, sizeof(struct _ns1__CheckSHA1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckSHA1Response(struct soap *soap, struct _ns1__CheckSHA1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckSHA1Response);
	if (soap_out_PointerTo_ns1__CheckSHA1Response(soap, tag?tag:"ns1:CheckSHA1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckSHA1Response(struct soap *soap, struct _ns1__CheckSHA1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckSHA1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckSHA1(struct soap *soap, struct _ns1__CheckSHA1 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckSHA1))
		soap_serialize__ns1__CheckSHA1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckSHA1(struct soap *soap, const char *tag, int id, struct _ns1__CheckSHA1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckSHA1);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CheckSHA1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CheckSHA1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckSHA1(struct soap *soap, const char *tag, struct _ns1__CheckSHA1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CheckSHA1 **)soap_malloc(soap, sizeof(struct _ns1__CheckSHA1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CheckSHA1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckSHA1, sizeof(struct _ns1__CheckSHA1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckSHA1(struct soap *soap, struct _ns1__CheckSHA1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckSHA1);
	if (soap_out_PointerTo_ns1__CheckSHA1(soap, tag?tag:"ns1:CheckSHA1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckSHA1(struct soap *soap, struct _ns1__CheckSHA1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckSHA1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHostInfoResponse(struct soap *soap, struct _ns1__GetHostInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHostInfoResponse))
		soap_serialize__ns1__GetHostInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHostInfoResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetHostInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHostInfoResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetHostInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHostInfoResponse(struct soap *soap, const char *tag, struct _ns1__GetHostInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetHostInfoResponse **)soap_malloc(soap, sizeof(struct _ns1__GetHostInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetHostInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHostInfoResponse, sizeof(struct _ns1__GetHostInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHostInfoResponse(struct soap *soap, struct _ns1__GetHostInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse);
	if (soap_out_PointerTo_ns1__GetHostInfoResponse(soap, tag?tag:"ns1:GetHostInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHostInfoResponse(struct soap *soap, struct _ns1__GetHostInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHostInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHostInfo(struct soap *soap, struct _ns1__GetHostInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHostInfo))
		soap_serialize__ns1__GetHostInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHostInfo(struct soap *soap, const char *tag, int id, struct _ns1__GetHostInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHostInfo);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetHostInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetHostInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHostInfo(struct soap *soap, const char *tag, struct _ns1__GetHostInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetHostInfo **)soap_malloc(soap, sizeof(struct _ns1__GetHostInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetHostInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHostInfo, sizeof(struct _ns1__GetHostInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHostInfo(struct soap *soap, struct _ns1__GetHostInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHostInfo);
	if (soap_out_PointerTo_ns1__GetHostInfo(soap, tag?tag:"ns1:GetHostInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHostInfo(struct soap *soap, struct _ns1__GetHostInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHostInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDNSResponse(struct soap *soap, struct _ns1__GetDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDNSResponse))
		soap_serialize__ns1__GetDNSResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDNSResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDNSResponse(struct soap *soap, const char *tag, struct _ns1__GetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetDNSResponse **)soap_malloc(soap, sizeof(struct _ns1__GetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDNSResponse, sizeof(struct _ns1__GetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDNSResponse(struct soap *soap, struct _ns1__GetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDNSResponse);
	if (soap_out_PointerTo_ns1__GetDNSResponse(soap, tag?tag:"ns1:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDNSResponse(struct soap *soap, struct _ns1__GetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDNS(struct soap *soap, struct _ns1__GetDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDNS))
		soap_serialize__ns1__GetDNS(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDNS(struct soap *soap, const char *tag, int id, struct _ns1__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDNS(struct soap *soap, const char *tag, struct _ns1__GetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetDNS **)soap_malloc(soap, sizeof(struct _ns1__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDNS, sizeof(struct _ns1__GetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDNS(struct soap *soap, struct _ns1__GetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDNS);
	if (soap_out_PointerTo_ns1__GetDNS(soap, tag?tag:"ns1:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDNS(struct soap *soap, struct _ns1__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTimeResponse(struct soap *soap, struct _ns1__GetTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTimeResponse))
		soap_serialize__ns1__GetTimeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTimeResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTimeResponse(struct soap *soap, const char *tag, struct _ns1__GetTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetTimeResponse **)soap_malloc(soap, sizeof(struct _ns1__GetTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTimeResponse, sizeof(struct _ns1__GetTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTimeResponse(struct soap *soap, struct _ns1__GetTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTimeResponse);
	if (soap_out_PointerTo_ns1__GetTimeResponse(soap, tag?tag:"ns1:GetTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTimeResponse(struct soap *soap, struct _ns1__GetTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTime(struct soap *soap, struct _ns1__GetTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTime))
		soap_serialize__ns1__GetTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTime(struct soap *soap, const char *tag, int id, struct _ns1__GetTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTime);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTime(struct soap *soap, const char *tag, struct _ns1__GetTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetTime **)soap_malloc(soap, sizeof(struct _ns1__GetTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTime, sizeof(struct _ns1__GetTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTime(struct soap *soap, struct _ns1__GetTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTime);
	if (soap_out_PointerTo_ns1__GetTime(soap, tag?tag:"ns1:GetTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTime(struct soap *soap, struct _ns1__GetTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result))
		soap_serialize__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result, sizeof(struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag?tag:"ns1:m_tz_update1Response-m_tz_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdate1Response_m_USCOREtz_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result))
		soap_serialize__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result, sizeof(struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result);
	if (soap_out_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag?tag:"ns1:TZ_Day1Response-TZ_Day1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(struct soap *soap, struct _ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDay1Response_TZ_USCOREDay1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag?tag:"ns1:hb_fp_dy_end1Response-hb_fp_dy_end1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREend1Response_hb_USCOREfp_USCOREdy_USCOREend1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result))
		soap_serialize__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyue1Response_get_USCOREyue1Result, sizeof(struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result);
	if (soap_out_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag?tag:"ns1:get_yue1Response-get_yue1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(struct soap *soap, struct _ns1__get_USCOREyue1Response_get_USCOREyue1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyue1Response_get_USCOREyue1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result))
		soap_serialize__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result, sizeof(struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result);
	if (soap_out_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag?tag:"ns1:get_yyzd1Response-get_yyzd1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(struct soap *soap, struct _ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzd1Response_get_USCOREyyzd1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result))
		soap_serialize__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result, sizeof(struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result);
	if (soap_out_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag?tag:"ns1:get_hbfp1Response-get_hbfp1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(struct soap *soap, struct _ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfp1Response_get_USCOREhbfp1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result))
		soap_serialize__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result, sizeof(struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag?tag:"ns1:hbtsf_update1Response-hbtsf_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(struct soap *soap, struct _ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdate1Response_hbtsf_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result))
		soap_serialize__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result, sizeof(struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag?tag:"ns1:hbwsh_update1Response-hbwsh_update1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(struct soap *soap, struct _ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdate1Response_hbwsh_USCOREupdate1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result))
		soap_serialize__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmx1Response_get_USCOREmx1Result, sizeof(struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result);
	if (soap_out_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag?tag:"ns1:get_mx1Response-get_mx1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(struct soap *soap, struct _ns1__get_USCOREmx1Response_get_USCOREmx1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmx1Response_get_USCOREmx1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result))
		soap_serialize__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result, sizeof(struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag?tag:"ns1:get_hbwsh1Response-get_hbwsh1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(struct soap *soap, struct _ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh1Response_get_USCOREhbwsh1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result))
		soap_serialize__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result, sizeof(struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result);
	if (soap_out_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag?tag:"ns1:get_hbgs1Response-get_hbgs1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(struct soap *soap, struct _ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgs1Response_get_USCOREhbgs1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult))
		soap_serialize__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, int id, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult **)soap_malloc(soap, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult, sizeof(struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult);
	if (soap_out_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag?tag:"ns1:fp_dy_endResponse-fp_dy_endResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__fp_USCOREdy_USCOREendResponse_fp_USCOREdy_USCOREendResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult))
		soap_serialize__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult, sizeof(struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult);
	if (soap_out_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag?tag:"ns1:get_zbfpResponse-get_zbfpResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(struct soap *soap, struct _ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzbfpResponse_get_USCOREzbfpResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult))
		soap_serialize__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult, sizeof(struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag?tag:"ns1:ZB_TZ_MonthResponse-ZB_TZ_MonthResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREMonthResponse_ZB_USCORETZ_USCOREMonthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult))
		soap_serialize__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const char *tag, int id, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, const char *tag, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult **)soap_malloc(soap, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult, sizeof(struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult);
	if (soap_out_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag?tag:"ns1:ZB_TZ_DayResponse-ZB_TZ_DayResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(struct soap *soap, struct _ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ZB_USCORETZ_USCOREDayResponse_ZB_USCORETZ_USCOREDayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult))
		soap_serialize__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult, sizeof(struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag?tag:"ns1:tsf_updateResponse-tsf_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(struct soap *soap, struct _ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__tsf_USCOREupdateResponse_tsf_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult))
		soap_serialize__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult, sizeof(struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag?tag:"ns1:wsh_updateResponse-wsh_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(struct soap *soap, struct _ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__wsh_USCOREupdateResponse_wsh_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult))
		soap_serialize__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult, sizeof(struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult);
	if (soap_out_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag?tag:"ns1:get_zb_mxResponse-get_zb_mxResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREzb_USCOREmxResponse_get_USCOREzb_USCOREmxResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult))
		soap_serialize__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse_get_USCOREwshResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREwshResponse_get_USCOREwshResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREwshResponse_get_USCOREwshResult, sizeof(struct _ns1__get_USCOREwshResponse_get_USCOREwshResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult);
	if (soap_out_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag?tag:"ns1:get_wshResponse-get_wshResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREwshResponse_get_USCOREwshResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(struct soap *soap, struct _ns1__get_USCOREwshResponse_get_USCOREwshResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREwshResponse_get_USCOREwshResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult))
		soap_serialize__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, int id, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, const char *tag, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult **)soap_malloc(soap, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult, sizeof(struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult);
	if (soap_out_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag?tag:"ns1:hb_fp_dy_endResponse-hb_fp_dy_endResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(struct soap *soap, struct _ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hb_USCOREfp_USCOREdy_USCOREendResponse_hb_USCOREfp_USCOREdy_USCOREendResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult))
		soap_serialize__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult, sizeof(struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag?tag:"ns1:hbtsf_yue_updateResponse-hbtsf_yue_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREyue_USCOREupdateResponse_hbtsf_USCOREyue_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult))
		soap_serialize__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult, sizeof(struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag?tag:"ns1:hbwsh_yue_updateResponse-hbwsh_yue_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREyue_USCOREupdateResponse_hbwsh_USCOREyue_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult))
		soap_serialize__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse_get_USCOREyueResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyueResponse_get_USCOREyueResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyueResponse_get_USCOREyueResult, sizeof(struct _ns1__get_USCOREyueResponse_get_USCOREyueResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult);
	if (soap_out_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag?tag:"ns1:get_yueResponse-get_yueResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyueResponse_get_USCOREyueResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREyueResponse_get_USCOREyueResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyueResponse_get_USCOREyueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult))
		soap_serialize__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult, sizeof(struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult);
	if (soap_out_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag?tag:"ns1:get_hbwsh_yueResponse-get_hbwsh_yueResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(struct soap *soap, struct _ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwsh_USCOREyueResponse_get_USCOREhbwsh_USCOREyueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult))
		soap_serialize__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult, sizeof(struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult);
	if (soap_out_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag?tag:"ns1:get_yyzdResponse-get_yyzdResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(struct soap *soap, struct _ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREyyzdResponse_get_USCOREyyzdResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult))
		soap_serialize__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult, sizeof(struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult);
	if (soap_out_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag?tag:"ns1:get_hbfpResponse-get_hbfpResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(struct soap *soap, struct _ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbfpResponse_get_USCOREhbfpResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult))
		soap_serialize__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult, sizeof(struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag?tag:"ns1:m_zb_tz_updateResponse-m_zb_tz_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREzb_USCOREtz_USCOREupdateResponse_m_USCOREzb_USCOREtz_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult))
		soap_serialize__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult, sizeof(struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag?tag:"ns1:m_tz_updateResponse-m_tz_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(struct soap *soap, struct _ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__m_USCOREtz_USCOREupdateResponse_m_USCOREtz_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult))
		soap_serialize__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult, sizeof(struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult);
	if (soap_out_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag?tag:"ns1:TZ_MonthResponse-TZ_MonthResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(struct soap *soap, struct _ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREMonthResponse_TZ_USCOREMonthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult))
		soap_serialize__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const char *tag, int id, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, const char *tag, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult **)soap_malloc(soap, sizeof(struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult, sizeof(struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult);
	if (soap_out_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag?tag:"ns1:TZ_DayResponse-TZ_DayResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(struct soap *soap, struct _ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TZ_USCOREDayResponse_TZ_USCOREDayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult))
		soap_serialize__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult, sizeof(struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag?tag:"ns1:hbtsf_updateResponse-hbtsf_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(struct soap *soap, struct _ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbtsf_USCOREupdateResponse_hbtsf_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult))
		soap_serialize__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const char *tag, int id, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, const char *tag, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult **)soap_malloc(soap, sizeof(struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult, sizeof(struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult);
	if (soap_out_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag?tag:"ns1:hbwsh_updateResponse-hbwsh_updateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(struct soap *soap, struct _ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__hbwsh_USCOREupdateResponse_hbwsh_USCOREupdateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult))
		soap_serialize__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse_get_USCOREmxResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREmxResponse_get_USCOREmxResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREmxResponse_get_USCOREmxResult, sizeof(struct _ns1__get_USCOREmxResponse_get_USCOREmxResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult);
	if (soap_out_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag?tag:"ns1:get_mxResponse-get_mxResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREmxResponse_get_USCOREmxResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(struct soap *soap, struct _ns1__get_USCOREmxResponse_get_USCOREmxResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREmxResponse_get_USCOREmxResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult))
		soap_serialize__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult, sizeof(struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult);
	if (soap_out_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag?tag:"ns1:get_hbwshResponse-get_hbwshResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(struct soap *soap, struct _ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbwshResponse_get_USCOREhbwshResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult))
		soap_serialize__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const char *tag, int id, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, const char *tag, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult **)soap_malloc(soap, sizeof(struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult, sizeof(struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult);
	if (soap_out_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag?tag:"ns1:get_hbgsResponse-get_hbgsResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(struct soap *soap, struct _ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__get_USCOREhbgsResponse_get_USCOREhbgsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, struct _ns1__FromBASE64Response_FromBASE64Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result))
		soap_serialize__ns1__FromBASE64Response_FromBASE64Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const char *tag, int id, struct _ns1__FromBASE64Response_FromBASE64Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__FromBASE64Response_FromBASE64Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response_FromBASE64Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, const char *tag, struct _ns1__FromBASE64Response_FromBASE64Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__FromBASE64Response_FromBASE64Result **)soap_malloc(soap, sizeof(struct _ns1__FromBASE64Response_FromBASE64Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__FromBASE64Response_FromBASE64Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__FromBASE64Response_FromBASE64Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FromBASE64Response_FromBASE64Result, sizeof(struct _ns1__FromBASE64Response_FromBASE64Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, struct _ns1__FromBASE64Response_FromBASE64Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__FromBASE64Response_FromBASE64Result);
	if (soap_out_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, tag?tag:"ns1:FromBASE64Response-FromBASE64Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__FromBASE64Response_FromBASE64Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__FromBASE64Response_FromBASE64Result(struct soap *soap, struct _ns1__FromBASE64Response_FromBASE64Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FromBASE64Response_FromBASE64Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, struct _ns1__ToBASE64Response_ToBASE64Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result))
		soap_serialize__ns1__ToBASE64Response_ToBASE64Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const char *tag, int id, struct _ns1__ToBASE64Response_ToBASE64Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ToBASE64Response_ToBASE64Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response_ToBASE64Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, const char *tag, struct _ns1__ToBASE64Response_ToBASE64Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ToBASE64Response_ToBASE64Result **)soap_malloc(soap, sizeof(struct _ns1__ToBASE64Response_ToBASE64Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ToBASE64Response_ToBASE64Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ToBASE64Response_ToBASE64Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ToBASE64Response_ToBASE64Result, sizeof(struct _ns1__ToBASE64Response_ToBASE64Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, struct _ns1__ToBASE64Response_ToBASE64Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ToBASE64Response_ToBASE64Result);
	if (soap_out_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, tag?tag:"ns1:ToBASE64Response-ToBASE64Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ToBASE64Response_ToBASE64Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__ToBASE64Response_ToBASE64Result(struct soap *soap, struct _ns1__ToBASE64Response_ToBASE64Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ToBASE64Response_ToBASE64Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, struct _ns1__CheckSHA1Response_CheckSHA1Result *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result))
		soap_serialize__ns1__CheckSHA1Response_CheckSHA1Result(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const char *tag, int id, struct _ns1__CheckSHA1Response_CheckSHA1Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CheckSHA1Response_CheckSHA1Result(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response_CheckSHA1Result ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, const char *tag, struct _ns1__CheckSHA1Response_CheckSHA1Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CheckSHA1Response_CheckSHA1Result **)soap_malloc(soap, sizeof(struct _ns1__CheckSHA1Response_CheckSHA1Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CheckSHA1Response_CheckSHA1Result(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckSHA1Response_CheckSHA1Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckSHA1Response_CheckSHA1Result, sizeof(struct _ns1__CheckSHA1Response_CheckSHA1Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, struct _ns1__CheckSHA1Response_CheckSHA1Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result);
	if (soap_out_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, tag?tag:"ns1:CheckSHA1Response-CheckSHA1Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckSHA1Response_CheckSHA1Result ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(struct soap *soap, struct _ns1__CheckSHA1Response_CheckSHA1Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckSHA1Response_CheckSHA1Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, struct _ns1__GetHostInfoResponse_GetHostInfoResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult))
		soap_serialize__ns1__GetHostInfoResponse_GetHostInfoResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const char *tag, int id, struct _ns1__GetHostInfoResponse_GetHostInfoResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse_GetHostInfoResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, const char *tag, struct _ns1__GetHostInfoResponse_GetHostInfoResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetHostInfoResponse_GetHostInfoResult **)soap_malloc(soap, sizeof(struct _ns1__GetHostInfoResponse_GetHostInfoResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetHostInfoResponse_GetHostInfoResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHostInfoResponse_GetHostInfoResult, sizeof(struct _ns1__GetHostInfoResponse_GetHostInfoResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, struct _ns1__GetHostInfoResponse_GetHostInfoResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult);
	if (soap_out_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag?tag:"ns1:GetHostInfoResponse-GetHostInfoResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetHostInfoResponse_GetHostInfoResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(struct soap *soap, struct _ns1__GetHostInfoResponse_GetHostInfoResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHostInfoResponse_GetHostInfoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
